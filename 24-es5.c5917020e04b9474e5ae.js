!function(){function e(e){return function(e){if(Array.isArray(e))return o(e)}(e)||function(e){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(e))return Array.from(e)}(e)||t(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function n(e,n){var o;if("undefined"==typeof Symbol||null==e[Symbol.iterator]){if(Array.isArray(e)||(o=t(e))||n&&e&&"number"==typeof e.length){o&&(e=o);var s=0,i=function(){};return{s:i,n:function(){return s>=e.length?{done:!0}:{done:!1,value:e[s++]}},e:function(e){throw e},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,a=!0,l=!1;return{s:function(){o=e[Symbol.iterator]()},n:function(){var e=o.next();return a=e.done,e},e:function(e){l=!0,r=e},f:function(){try{a||null==o.return||o.return()}finally{if(l)throw r}}}}function t(e,n){if(e){if("string"==typeof e)return o(e,n);var t=Object.prototype.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?o(e,n):void 0}}function o(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,o=new Array(n);t<n;t++)o[t]=e[t];return o}function s(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function i(e,n){for(var t=0;t<n.length;t++){var o=n[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}function r(e,n,t){return n&&i(e.prototype,n),t&&i(e,t),e}(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{rtBl:function(t,o,i){"use strict";i.r(o),i.d(o,"ToolManagementModule",function(){return $e});var a,l=i("mrSG"),c=i("fXoL"),d=i("ofXK"),h=i("tyNb"),u=i("3Pt+"),p=i("aceb"),m=i("vkgz"),b=i("tk/3"),f=i("l5mm"),w=i("XNiG"),g=i("NXyV"),v=i("LRne"),x=i("EY2u"),y=i("lJxs"),k=i("coGc"),A=i("eIep"),L=i("FQpF"),S=i("nYR2"),C=i("7qw2"),R=C.a+"api/v2",T=C.c+"api/v2/";!function(e){e[e.PAUSE=0]="PAUSE",e[e.RESUME=1]="RESUME",e[e.START=2]="START",e[e.STOP=3]="STOP"}(a||(a={}));var I=function(){function e(n){s(this,e),this.http=n}return r(e,[{key:"camalize",value:function(e){return e.toLowerCase()}},{key:"getReservedConstants",value:function(){return this.http.get(R+"/reserved_variables")}},{key:"GetAssetTypes",value:function(){var e=this;return this.http.get(R+"/asset_types").pipe(Object(y.a)(function(n){return n.map(function(n){return n.name=e.camalize(n.name),n})}))}},{key:"getDelay",value:function(e){return console.log("getDelay"),Object(f.a)(e)}},{key:"getLogs",value:function(e,n,t,o){var s,i=this,r=0,l=new w.a,c=0;return Object(g.a)(function(){return t.pipe().subscribe(function(t){var d=Object(v.a)(x.a).pipe(Object(k.a)(function(){return e=Object(f.a)(c),c=o,e;var e}),Object(A.a)(function(t){var o=new b.e({"X-Id":e,"X-Lines":n.toString(),"X-Seek":r+""});return i.http.get(T+"/tool/host",{headers:o,observe:"response",responseType:"text"}).pipe(Object(m.a)(function(e){var n=e.headers.get("X-File-Range"),t=e.headers.get("X-File-Size");if(null!=n&&null!=t){var o=n.split("-")[1];r=parseInt(o),parseInt(t)}}),Object(y.a)(function(e){return""+e.body}))}));if(t==a.RESUME)s&&s.unsubscribe(),s=d.pipe(Object(L.a)(function(e){return d})).subscribe(function(e){l.next(e)});else if(t==a.PAUSE)s&&(s.unsubscribe(),s=void 0);else if(t==a.STOP)return console.log("stopped"),l.complete(),void s.unsubscribe()}),l})}},{key:"createTool",value:function(e){return this.http.post(R+"/tool",e)}},{key:"editTool",value:function(e,n){return this.http.put("".concat(R,"/tool/").concat(e),n)}},{key:"runTool",value:function(e,n){return this.http.post("".concat(R,"/build/run/").concat(e),n)}},{key:"getTool",value:function(e){return this.http.get("".concat(R,"/tool/").concat(e))}},{key:"getTools",value:function(){return this.http.get(R+"/tool")}},{key:"createBuild",value:function(e,n){return this.http.post("".concat(R,"/build/").concat(e),n)}},{key:"editBuild",value:function(e,n,t){return this.http.put("".concat(R,"/build/").concat(n,"/").concat(e),t)}},{key:"updateBuildConfig",value:function(e,n){return this.http.put("".concat(R,"/build/config/").concat(e),n)}},{key:"updateBuildConfigSoftlink",value:function(e,n){return this.http.put("".concat(R,"/build/config/softlink/").concat(e),n)}},{key:"getBuild",value:function(e,n){return this.http.get("".concat(R,"/build/").concat(e,"/").concat(n))}},{key:"getBuildConfig",value:function(e){return this.http.get("".concat(R,"/build/config/").concat(e))}},{key:"getBuildConfigSoftlink",value:function(e){return this.http.get("".concat(R,"/build/config/softlink/").concat(e))}},{key:"getBuilds",value:function(e){return this.http.get("".concat(R,"/builds/").concat(e))}},{key:"getBuildExecoturs",value:function(e){return this.http.get("".concat(R,"/build/executors/").concat(e))}},{key:"getBuildExecutorStatus",value:function(e){return this.http.get("".concat(R,"/build/executors/status/").concat(e))}},{key:"getToolImages",value:function(e){return this.http.get("".concat(R,"/deployment/images/").concat(e))}},{key:"getToolImagesTest",value:function(e){return this.http.get("".concat(R,"/test-deployment/images/").concat(e))}},{key:"getToolImageTags",value:function(e){return this.http.get("".concat(R,"/deployment/images/tags/").concat(e))}},{key:"getToolImageTagsTest",value:function(e){return this.http.get("".concat(R,"/test-deployment/images/tags/").concat(e))}},{key:"getBuildUploadUrl",value:function(e,n){return this.http.post(R+"/build/upload/init",{id:e,filename:n})}},{key:"getBuildDownloadUrl",value:function(e){return this.http.post(R+"/build/download/init",e)}},{key:"uploadWithUrl",value:function(e,n){var t=new FormData;console.log("file_debug",e.name),console.log("file_debug",e.size),t.append("files",e);var o=new b.e,s=this.http.put(n,e,{reportProgress:!0,observe:"events",headers:o}),i=new w.a;return s.pipe(Object(S.a)(function(){return console.log("complete...")})).subscribe(function(e){if(e.type===b.d.UploadProgress){var n=Math.round(100*e.loaded/e.total);i.next({status:!1,progress:n})}else e instanceof b.f&&(i.next({status:!0,progress:100,fileData:e.body}),i.complete())}),i.asObservable()}},{key:"getDeployment",value:function(e){return this.http.post(R+"/deployment/service",{deployment_id:e})}},{key:"getDeploymentTest",value:function(e){return this.http.post(R+"/test-deployment/service",{deployment_id:e})}},{key:"runDeployment",value:function(e){return this.http.post(R+"/deployment/run",{job_id:e})}},{key:"runDeploymentTest",value:function(e){return this.http.post(R+"/test-deployment/run",{job_id:e})}},{key:"execJob",value:function(e,n){return this.http.post("".concat(R,"/job/exec/").concat(e),n)}},{key:"stopDeployment",value:function(e){return this.http.delete(R+"/deployment/service",{params:{job_id:e}})}},{key:"stopDeploymentTest",value:function(e){return this.http.delete(R+"/test-deployment/service",{params:{job_id:e}})}},{key:"getJobStatus",value:function(e){return this.http.get("".concat(R,"/job/status/").concat(e))}},{key:"getJobs",value:function(e){return this.http.get("".concat(R,"/jobs/").concat(e))}},{key:"purgeDeployment",value:function(){return this.http.delete(R+"/deployment/purge")}},{key:"purgeDeploymentTest",value:function(){return this.http.delete(R+"/test-deployment/purge")}},{key:"getDeployments",value:function(e){return this.http.get("".concat(R,"/deployment/services/").concat(e))}},{key:"getDeploymentsTest",value:function(e){return this.http.get("".concat(R,"/test-deployment/services/").concat(e))}},{key:"createDeployment",value:function(e){return this.http.post("".concat(R,"/deployment/service/").concat(e),{})}},{key:"createDeploymentTest",value:function(e){return this.http.post("".concat(R,"/test-deployment/service/").concat(e),{})}}]),e}();I.ctorParameters=function(){return[{type:b.b}]},I=Object(l.a)([Object(c.F)({providedIn:"root"})],I);var _=function(){function e(n,t,o,i,r,a){s(this,e),this.fb=n,this.toolApiService=t,this.cdr=o,this.activatedRoute=i,this.router=r,this.dialogService=a,this.LOADING=!1,this.raw_args_editor=new u.d("dsad=\"dsadsa sad sdsa  d dsa\" one='123'  dsdsd d='sad'  fdfd='fdsf  fds' fdsfdsfdfds='23r23r\"fdsfsdf'\n  dfdsfdsfdsfsdf'fdsfdsf'  \"dsadsad\" \n\n"),this.build_id="63d9064e1a63f05fd615b2c0",this.assetTypes$=this.toolApiService.GetAssetTypes(),this.form=new u.e({id:new u.d(""),entrypoint:this.fb.array([new u.d("/bin/entrypoint")]),cmd:this.fb.array([this.fb.control("/bin/cmd")]),args:this.fb.array([this.fb.control("hello"),this.fb.control("hello")]),assets:new u.d([]),substitute_var:new u.d(!0),variables:new u.b([new u.e({key:new u.d("key"),value:new u.d("value")})]),success_endpoint:new u.d("http://success_endpoint.com/usr/bin/mobsf"),failure_endpoint:new u.d(""),config:new u.e({process:new u.b([new u.e({key:new u.d("key"),value:new u.d("value")})]),reserved:new u.b([new u.e({key:new u.d("key"),value:new u.d("value")})]),_reserved:new u.e({message_queue_topic:new u.d("")}),system:new u.b([new u.e({key:new u.d("key"),value:new u.d("value")})]),_process:new u.e({input_api:new u.d(""),input_api_token:new u.d(""),output_api:new u.d(""),file_upload_api:new u.d("")}),_system:new u.e({base_path:new u.d(""),input_dir:new u.d(""),output_dir:new u.d(""),results_json:new u.d(""),results_schema:new u.d(""),log_to_file:new u.d(!0),stdout_file:new u.d(""),stderr_file:new u.d(""),enable_logging:new u.d(!0),max_output_filesize:new u.d(1e3),sample_inputfile:new u.d(""),sample_outputfile:new u.d("")})})})}return r(e,[{key:"parseArgs",value:function(e){for(var n,t=/([^'"\s]*"([^"]*)["]*[^'"\s]*|[^'"\s]*'([^']*)[']*[^'"\s]*|[^\s"']+)/gm,o=[];null!==(n=t.exec(e));){n.index===t.lastIndex&&t.lastIndex++;var s=n[0];o.push(s),console.log("argument",n)}this.setArgs(o)}},{key:"getArgs",value:function(){return this.form.get("args")}},{key:"setArgs",value:function(e){var n=this;this.form.get("args");var t=this.fb.array([]);e.forEach(function(e){t.push(n.fb.control(e))}),this.form.setControl("args",t)}},{key:"deleteArg",value:function(e){this.getArgs().removeAt(e)}},{key:"getVariables",value:function(){return this.form.get("variables")}},{key:"getConfProcess",value:function(){return this.form.get("config").get("process")}},{key:"getConfSystem",value:function(){return this.form.get("config").get("system")}},{key:"getConfReserved",value:function(){return this.form.get("config").get("reserved")}},{key:"deleteVariables",value:function(e){this.getVariables().removeAt(e)}},{key:"deleteConfProcess",value:function(e){this.getConfProcess().removeAt(e)}},{key:"deleteConfSystem",value:function(e){this.getConfSystem().removeAt(e)}},{key:"deleteConfReserved",value:function(e){this.getConfReserved().removeAt(e)}},{key:"open",value:function(e){var t,o=this,s="",i=n(this.getArgs().controls);try{for(i.s();!(t=i.n()).done;){s+=t.value.value+" "}}catch(r){i.e(r)}finally{i.f()}console.log("openDialog",s),this.dialogService.open(e,{context:{args:s,cmd:this.form.get("cmd").value}}).onClose.subscribe(function(e){e&&(o.form.setControl("cmd",o.fb.array([o.fb.control(null==e?void 0:e.cmd)])),o.parseArgs(null==e?void 0:e.args))})}},{key:"goTo",value:function(e){this.router.navigate(["./",{outlets:{view:e}}],{relativeTo:this.activatedRoute.parent})}},{key:"ngOnInit",value:function(){var e=this;this.activatedRoute.paramMap.pipe(Object(m.a)(function(n){n.has("id")&&(e.build_id=n.get("id")),e.loadConfig()})).subscribe()}},{key:"addArg",value:function(){this.getArgs().push(this.fb.control(""))}},{key:"addVar",value:function(){this.getVariables().push(new u.e({key:new u.d(""),value:new u.d("")}))}},{key:"addConfProcess",value:function(){this.getConfProcess().push(new u.e({key:new u.d(""),value:new u.d("")}))}},{key:"addSystemProcess",value:function(){this.getConfSystem().push(new u.e({key:new u.d(""),value:new u.d("")}))}},{key:"addReservedProcess",value:function(){this.getConfReserved().push(new u.e({key:new u.d(""),value:new u.d("")}))}},{key:"formToJson",value:function(){var e=this.form.getRawValue();console.debug("rawData",e);var n={};e.variables.forEach(function(e){n[e.key]=e.value});var t={process:{},reserved:{},system:{}};return e.config.process.forEach(function(e){t.process[e.key]=e.value}),e.config.reserved.forEach(function(e){t.reserved[e.key]=e.value}),e.config.system.forEach(function(e){t.system[e.key]=e.value}),delete e._process,delete e._reserved,delete e._system,e.config=t,e.variables=n,e}},{key:"save",value:function(){var e=this;this.toolApiService.updateBuildConfigSoftlink(this.build_id,this.formToJson()).subscribe(function(n){e.goTo(["images"])})}},{key:"loadConfig",value:function(){var e=this;this.LOADING=!0,this.toolApiService.getBuildConfigSoftlink(this.build_id).subscribe(function(n){var t;if(n||(n={}),n.id&&e.form.setControl("id",e.fb.control(n.id)),n.cmd){var o=[];0==(null===(t=n.cmd)||void 0===t?void 0:t.length)&&(n.cmd=[""]),n.cmd.forEach(function(n){o.push(e.fb.control(n))}),e.form.setControl("cmd",e.fb.array(o))}if(n.entrypoint){var s=[];n.entrypoint.forEach(function(n){s.push(e.fb.control(n))}),e.form.setControl("entrypoint",e.fb.array(s))}if(n.args){var i=[];n.args.forEach(function(n){i.push(e.fb.control(n))}),e.form.setControl("args",e.fb.array(i))}n.substitute_var&&e.form.setControl("substitute_var",e.fb.control(n.substitute_var)),n.success_endpoint&&e.form.setControl("success_endpoint",e.fb.control(n.success_endpoint)),n.failure_endpoint&&e.form.setControl("failure_endpoint",e.fb.control(n.failure_endpoint)),n.assets&&e.form.setControl("assets",e.fb.control(n.assets));var r=e.fb.array([]);if(n.variables&&Object.keys(n.variables).forEach(function(t){r.push(e.fb.group({key:e.fb.control(t),value:e.fb.control(n.variables[t])}))}),e.form.setControl("variables",r),n.config){var a=[],l=[],c=[];n.config.process&&Object.keys(n.config.process).forEach(function(t){a.push(e.fb.group({key:e.fb.control(t),value:e.fb.control(n.config.process[t])}))}),n.config.system&&Object.keys(n.config.system).forEach(function(t){l.push(e.fb.group({key:e.fb.control(t),value:e.fb.control(n.config.system[t])}))}),n.config.reserved&&Object.keys(n.config.reserved).forEach(function(t){c.push(e.fb.group({key:e.fb.control(t),value:e.fb.control(n.config.reserved[t])}))});var d=e.fb.group({process:e.fb.array(a),reserved:e.fb.array(c),system:e.fb.array(l)});e.form.setControl("config",d)}e.LOADING=!1,e.cdr.markForCheck()})}},{key:"autoGrowTextZone",value:function(e){e.target.style.height="0px",e.target.style.height=e.target.scrollHeight+25+"px"}}]),e}();_.ctorParameters=function(){return[{type:u.c},{type:I},{type:c.k},{type:h.a},{type:h.f},{type:p.j}]},_.propDecorators={close:[{type:c.I,args:["close"]}],refrence_id:[{type:c.I,args:["refrence_id"]}],build_id:[{type:c.I,args:["build_id"]}]},_=Object(l.a)([Object(c.n)({selector:"app-build-config",template:'<ng-template #rawArgsEditorDialog let-data let-ref="dialogRef">\n  <nb-card >\n    <nb-card-header>\n\n\n      <button shape="round" ghost status="basic" class="action" size="large" nbButton>\n        <nb-icon icon="info">\n\n        </nb-icon>\n      </button>\n\n      <span class="subtitle text-hint lineV">\n        Build Configuration\n\n      </span>\n    </nb-card-header>\n\n\n    <nb-card-body>\n\n      <div fxFlex>\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Command\n          </p>\n        </div>\n\n\n        <nb-form-field>\n\n\n          <input #cmd  [value]="data.cmd" nbInput fullWidth placeholder="Argument Parser">\n        </nb-form-field>\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Arguments\n          </p>\n        </div>\n\n        <nb-form-field>\n\n          <textarea #args (keyup)="autoGrowTextZone($event)" nbInput fullWidth\n            placeholder="Argument Parser">{{data.args}}</textarea>\n        </nb-form-field>\n\n      </div>\n    </nb-card-body>\n    <nb-card-footer fxLayoutAlign="end center" fxLayoutGap="1rem">\n      <button size="small" ghost  nbButton (click)="ref.close()">Cancel</button>\n      <button size="small" status="success" nbButton (click)="ref.close( { cmd:  cmd?.value ,  args: args?.value  }  )">Save</button>\n    </nb-card-footer>\n  </nb-card>\n</ng-template>\n\n<ng-container [formGroup]="form" *ngIf=" LOADING == false ; else loading">\n\n  <nb-layout-header fixed>\n    <div fxFlex fxLayout="row">\n\n      <div fxLayoutAlign="start center" fxLayout="row">\n\n        <button (click)="goTo( [ \'images\' ] )" shape="round" ghost status="basic" class="action" size="large" nbButton>\n          <nb-icon icon="arrow-back-outline">\n\n          </nb-icon>\n        </button>\n\n        <span class="subtitle text-hint lineV">\n          Build Creator\n        </span>\n\n      </div>\n\n\n    </div>\n\n    <div style="margin-right: 1rem;">\n\n      <button (click)="save()" hero size="medium" shape="round" status="primary" nbButton>\n        <span>\n          Save\n        </span>\n        <nb-icon icon="play-circle"></nb-icon>\n      </button>\n    </div>\n  </nb-layout-header>\n\n\n  <nb-card fxFill>\n    <nb-card-header fxLayoutAlign="space-between center" fxLayout="row">\n      <div fxLayoutAlign="start center" fxLayout="row">\n\n\n        <button (click)="close.next(true)" shape="round" ghost status="basic" class="action" size="large" nbButton>\n          <nb-icon icon="info">\n\n          </nb-icon>\n        </button>\n\n        <span class="subtitle text-hint lineV">\n          Build Configuration\n\n        </span>\n\n      </div>\n\n\n\n\n      <div fxLayout="column">\n\n        <div fxLayout="row" fxLayoutAlign="end" fxFlex>\n          <nb-select scrollStrategy="reposition" formControlName="assets" multiple size="small"\n            placeholder="Supported Assets">\n\n            <nb-option style="text-transform: capitalize;" *ngFor="let assetType of assetTypes$ | async"\n              [value]="assetType?.identifier">{{assetType?.name}}</nb-option>\n\n          </nb-select>\n\n\n        </div>\n      </div>\n    </nb-card-header>\n\n    <nb-card-body>\n\n\n\n      \x3c!-- Identifier --\x3e\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Identifier\n          </p>\n        </div>\n\n        <div fxLayout="row" fxLayoutGap="1rem">\n          <nb-form-field fxFlex fieldSize="small">\n            <input fullWidth cdkFocusInitial formControlName="id" nbInput placeholder="/bin/watchdog">\n          </nb-form-field>\n        </div>\n      </div>\n\n      \x3c!-- Entrypoint --\x3e\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Entrypoint\n          </p>\n        </div>\n\n\n        <ng-container formArrayName="entrypoint">\n\n          <ng-container *ngFor="let entrypoint of this.form.get(\'entrypoint\').controls ; let i=index ">\n\n            <div fxLayout="row" fxLayoutGap="1rem">\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth cdkFocusInitial [formControlName]="i" nbInput placeholder="/bin/watchdog">\n              </nb-form-field>\n            </div>\n\n          </ng-container>\n        </ng-container>\n\n      </div>\n\n      <app-divider></app-divider>\n\n      \x3c!-- Command --\x3e\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Command\n          </p>\n        </div>\n\n\n\n\n        <ng-container formArrayName="cmd">\n\n          <ng-container *ngFor="let _cmd of this.form.get(\'cmd\').controls ; let i=index ">\n\n\n            \x3c!-- <div [style.marginBottom]="\'0.5rem\'" fxLayout="row" fxLayoutGap="1rem"> --\x3e\n\n            <div fxFlex fxLayoutGap="1rem">\n              <nb-form-field fieldSize="small">\n                <input cdkFocusInitial fullWidth [formControlName]="i" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n            </div>\n\n\n\n\n            \x3c!-- </div> --\x3e\n\n\n          </ng-container>\n\n\n        </ng-container>\n\n\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Arguments --\x3e\n      <div fxLayout="column">\n\n        <div fxLayout="row">\n          <p fxFlex class="subtitle-2 text-hint">\n            Arguments\n          </p>\n\n          <button (click)="addArg()" ghost nbButton status="danger">\n            Add\n          </button>\n\n\n          <button (click)="open(rawArgsEditorDialog)" ghost nbButton status="danger">\n            Raw Editor\n          </button>\n        </div>\n\n\n\n        <div fxFlex>\n\n          <ng-container formArrayName="args">\n\n            <ng-container *ngFor="let arg of this.form.get(\'args\').controls ; let i=index ">\n\n\n              <div [style.marginBottom]="\'0.5rem\'" fxLayout="row" fxLayoutGap="1rem">\n                <nb-form-field fxFlex fieldSize="small">\n                  <input fullWidth cdkFocusInitial [formControlName]="i" nbInput placeholder="/usr/bin/mobsf">\n\n\n                </nb-form-field>\n\n\n                <button ghost nbSuffix nbButton (click)="deleteArg(i)">\n                  <nb-icon icon="trash-outline">\n                  </nb-icon>\n                </button>\n\n              </div>\n\n\n            </ng-container>\n\n\n          </ng-container>\n        </div>\n\n        <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'args\').controls.length" fxFlex>\n          <p class="subtitle-2 text-hint">\n            No Arguments Defined\n          </p>\n        </div>\n\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Variables --\x3e\n      <div fxLayout="column">\n\n        <div fxLayout="row">\n          <p fxFlex class="subtitle-2 text-hint">\n            Variables\n          </p>\n\n\n\n          <button (click)="addVar()" ghost nbButton status="danger">\n            Add\n          </button>\n\n\n        </div>\n\n\n        <ng-container formArrayName="variables">\n\n          <ng-container *ngFor="let variable of this.form.get(\'variables\').controls ; let i=index ">\n\n            <div [style.marginBottom]="\'0.5rem\'" [formGroupName]="i" fxLayout="row" fxLayoutGap="1rem">\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="key" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n\n\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="value" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n              <button ghost nbButton (click)="deleteVariables(i)">\n                <nb-icon icon="trash-outline">\n                </nb-icon>\n              </button>\n\n\n\n\n            </div>\n\n\n          </ng-container>\n\n\n        </ng-container>\n\n\n        <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'variables\').controls.length" fxFlex>\n          <p class="subtitle-2 text-hint">\n            No Variables Defined\n          </p>\n        </div>\n\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Substitute Variables --\x3e\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Substitute Variables\n          </p>\n        </div>\n\n        <div fxLayout="row" fxLayoutGap="1rem">\n\n          <nb-checkbox formControlName="substitute_var">Substitute Variables </nb-checkbox>\n\n        </div>\n      </div>\n\n\n      <app-divider></app-divider>\n\n\n\n\n      \x3c!-- success_endpoint --\x3e\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Success Endpoint\n          </p>\n        </div>\n\n        <div fxLayout="row" fxLayoutGap="1rem">\n          <nb-form-field fxFlex fieldSize="small">\n            <input fullWidth cdkFocusInitial formControlName="success_endpoint" nbInput\n              placeholder="http://success_endpoint.com/usr/bin/mobsf">\n          </nb-form-field>\n        </div>\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- failure_endpoint --\x3e\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Failure Endpoint\n          </p>\n        </div>\n\n        <div fxLayout="row" fxLayoutGap="1rem">\n          <nb-form-field fxFlex fieldSize="small">\n            <input fullWidth cdkFocusInitial formControlName="failure_endpoint" nbInput\n              placeholder="http://failure_endpoint.com/usr/bin/mobsf">\n          </nb-form-field>\n        </div>\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Process Env. Variables --\x3e\n      <div fxLayout="column" formGroupName="config">\n\n        <div fxLayout="row">\n          <p fxFlex class="subtitle-2 text-hint">\n            Environment Variables\n          </p>\n\n\n\n          <button (click)="addConfProcess()" ghost nbButton status="danger">\n            Add\n          </button>\n\n\n        </div>\n\n\n        <ng-container formArrayName="process">\n\n          <ng-container *ngFor="let variable of this.form.get(\'config\').get(\'process\').controls ; let i=index ">\n\n            <div [style.marginBottom]="\'0.5rem\'" [formGroupName]="i" fxLayout="row" fxLayoutGap="1rem">\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="key" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n\n\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="value" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n              <button ghost nbButton (click)="deleteConfProcess(i)">\n                <nb-icon icon="trash-outline">\n                </nb-icon>\n              </button>\n\n\n\n\n            </div>\n\n\n          </ng-container>\n\n\n        </ng-container>\n\n\n        <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'config\').get(\'process\').controls .length"\n          fxFlex>\n          <p class="subtitle-2 text-hint">\n            No Environment Variables Defined\n          </p>\n        </div>\n\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Reserved Env. Variables --\x3e\n      <div fxLayout="column" formGroupName="config">\n\n        <div fxLayout="row">\n          <p fxFlex class="subtitle-2 text-hint">\n            Reserved Environment Variables\n          </p>\n\n\n\n          <button (click)="addReservedProcess()" ghost nbButton status="danger">\n            Add\n          </button>\n\n\n        </div>\n\n\n        <ng-container formArrayName="reserved">\n\n          <ng-container *ngFor="let variable of this.form.get(\'config\').get(\'reserved\').controls ; let i=index ">\n\n            <div [style.marginBottom]="\'0.5rem\'" [formGroupName]="i" fxLayout="row" fxLayoutGap="1rem">\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="key" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n\n\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="value" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n              <button ghost nbButton (click)="deleteConfReserved(i)">\n                <nb-icon icon="trash-outline">\n                </nb-icon>\n              </button>\n\n\n\n\n            </div>\n\n\n          </ng-container>\n\n\n        </ng-container>\n\n        <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'config\').get(\'reserved\').controls .length"\n          fxFlex>\n          <p class="subtitle-2 text-hint">\n            No Reserved Variables Defined\n          </p>\n        </div>\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Systen Env. Variables --\x3e\n      <div fxLayout="column" formGroupName="config">\n\n        <div fxLayout="row">\n          <p fxFlex class="subtitle-2 text-hint">\n            Systen Environment Variables\n          </p>\n\n\n\n          <button (click)="addSystemProcess()" ghost nbButton status="danger">\n            Add\n          </button>\n\n\n        </div>\n\n\n        <ng-container formArrayName="system">\n\n          <ng-container *ngFor="let variable of this.form.get(\'config\').get(\'system\').controls ; let i=index ">\n\n            <div [style.marginBottom]="\'0.5rem\'" [formGroupName]="i" fxLayout="row" fxLayoutGap="1rem">\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="key" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n\n\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="value" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n              <button ghost nbButton (click)="deleteConfSystem(i)">\n                <nb-icon icon="trash-outline">\n                </nb-icon>\n              </button>\n\n\n\n\n            </div>\n\n\n          </ng-container>\n\n\n        </ng-container>\n\n        <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'config\').get(\'system\').controls .length"\n          fxFlex>\n          <p class="subtitle-2 text-hint">\n            No System Variables Defined\n          </p>\n        </div>\n      </div>\n\n      <app-divider></app-divider>\n\n\n\n\n\n    </nb-card-body>\n\n\n\n  </nb-card>\n\n\n\n\n  \x3c!-- </nb-layout-column> --\x3e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</ng-container>\n\n<ng-template #loading>\n  <div fxLayoutAlign="center center">\n    <ngx-progress-spinner></ngx-progress-spinner>\n  </div>\n\n</ng-template>',styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\nnb-layout-column {\n  background-color: var(--color-basic-100) !important;\n}\nnb-card {\n  margin: 0;\n}\nnb-card .container {\n  margin-top: 1rem;\n}\nnb-card textarea {\n  resize: none;\n}\n.label-text {\n  border-left: 2px var(--text-hint-color) solid !important;\n  margin-bottom: 1rem;\n  padding-left: 4px;\n}\n.subtitle {\n  margin: 0;\n  padding-left: 4px;\n}\nnb-card-header {\n  padding: 0.4rem;\n  box-shadow: 2px 2px 3px rgba(0, 0, 0, 0.16), 2px 2px 3px rgba(0, 0, 0, 0.23);\n}\nnb-card {\n  border: 0;\n}\n.buildBtn {\n  border-radius: 0;\n}"]})],_);var j=i("2Vo4"),F=i("5+tZ"),P=i("pLZG"),M=function(){function e(){s(this,e),this.toolId=new j.a("dfault")}return r(e,[{key:"ToolId",get:function(){return this.toolId.asObservable()}},{key:"SetToolId",value:function(e){console.log("SetToolId",e),this.toolId.next(e)}}]),e}();M.ctorParameters=function(){return[]},M=Object(l.a)([Object(c.F)({providedIn:"root"})],M);var z=function(){function e(n,t,o,i,r){s(this,e),this.toolApiService=n,this.cdr=t,this.router=o,this.activatedRoute=i,this.sharedDataService=r,this.edit_mode=!1,this.build_id=void 0,this.meta_tags=new Set,this.bundke_upload_progress=new j.a({progress:20,uploading:!1}),this.buildTypes=[{name:"Docker File",id:"dockerfile",active:!0,children:[{name:"Dockerfile",id:"dockerfile",active:!0}]},{name:"Docker Image",id:"repository",active:!0,children:[{name:"Docker Hub",id:"registry_public",active:!0},{name:"Private Repository",id:"registry_private",active:!1}]},{name:"Docker Bundle",id:"repository",children:[{name:"Git Repository",id:"bundle_git",active:!0},{name:"Bundle Url",id:"bundle_url",active:!1},{name:"Upload Bundle",id:"bundle_upload",active:!0}]}],this.gitRepositories=[{name:"GitHub",id:"github"},{name:"GitLab",id:"gitlab"},{name:"Bitbucket",id:"bitbucket"},{name:"Other",id:"other"}],this.bundleType=[{name:"Zip",id:"zip"},{name:"Tar",id:"tar"}],this._common_data_form_fields={type:new u.d("zip"),url:new u.d("",[]),bucket:new u.d("",[u.n.required]),filename:new u.d("",[u.n.required]),identifier:new u.d("",[u.n.required]),version:new u.d("",[u.n.required])},this.config_form=new u.e({dockerfile:new u.e({authentication:new u.d("none",[]),data:new u.e(Object.assign({dockerfile:new u.d("FROM SCRATCH",[u.n.required])},this._common_data_form_fields)),auth_mode:new u.e({none:new u.e({}),credentials:new u.e({username:new u.d("",[u.n.required]),password:new u.d("",[u.n.required])}),access_token:new u.e({access_token:new u.d("",[u.n.required])})})}),registry_public:new u.e({authentication:new u.d("none",[]),data:new u.e({image_name:new u.d("",[u.n.required]),image_tag:new u.d("latest",[u.n.required])}),auth_mode:new u.e({none:new u.e({}),credentials:new u.e({username:new u.d("",[u.n.required]),password:new u.d("",[u.n.required])}),access_token:new u.e({access_token:new u.d("",[u.n.required])})})}),registry_private:new u.e({authentication:new u.d("none",[]),data:new u.e({image_name:new u.d("",[u.n.required]),image_tag:new u.d("latest",[u.n.required]),registry_url:new u.d("")}),auth_mode:new u.e({none:new u.e({}),credentials:new u.e({username:new u.d("",[u.n.required]),password:new u.d("",[u.n.required])}),access_token:new u.e({access_token:new u.d("",[u.n.required])})})}),bundle_git:new u.e({authentication:new u.d("none",[]),data:new u.e({repository:new u.d("github",[u.n.required]),repository_url:new u.d("",[u.n.required,u.n.pattern("(git)?(://)(.*)(.git)(/)?")]),repository_context:new u.d("",[])}),auth_mode:new u.e({none:new u.e({}),credentials:new u.e({username:new u.d("",[u.n.required]),password:new u.d("",[u.n.required])}),access_token:new u.e({access_token:new u.d("",[u.n.required])}),privatekey:new u.e({privatekey:new u.d("",[u.n.required])})})}),bundle_url:new u.e({authentication:new u.d("none",[]),data:new u.e({type:new u.d("tar"),url:new u.d("",[u.n.required])}),auth_mode:new u.e({none:new u.e({})})}),bundle_upload:new u.e({authentication:new u.d("none",[]),meta:new u.e({progress:new u.d(54)}),data:new u.e({type:new u.d("zip"),url:new u.d("",[u.n.required]),bucket:new u.d("",[u.n.required]),filename:new u.d("",[u.n.required]),identifier:new u.d("",[u.n.required]),version:new u.d("",[u.n.required])}),auth_mode:new u.e({none:new u.e({})})})}),this.form=new u.e({tool:new u.e({name:new u.d({value:"tool_name",disabled:!0},[u.n.required]),alias:new u.d({value:"tool_name",disabled:!0},[u.n.required])}),tool_name:new u.d({value:"tool_name",disabled:!0},[u.n.required]),tool_tag:new u.d({value:"tool_tag",disabled:!0},[u.n.required]),build_type:new u.d("bundle_git"),desc:new u.d("")}),this.readonly_mode=!1}return r(e,[{key:"onTagRemove",value:function(e){this.meta_tags.delete(e.text)}},{key:"onTagAdd",value:function(e){var n=e.value,t=e.input;n&&this.meta_tags.add(n),t.nativeElement.value=""}},{key:"ngOnInit",value:function(){var e=this;this.sharedDataService.ToolId.subscribe(function(n){e.init(n)})}},{key:"init",value:function(e){var n=this;this.refrence_id=e,this.edit_mode&&Object(v.a)(this.prefilled_build_data).pipe(Object(F.b)(function(e){return e?Object(v.a)(e).pipe(Object(y.a)(function(e){return n.readonly_mode=!0,e})):n.toolApiService.getBuild(n.refrence_id,n.build_id).pipe(Object(y.a)(function(e){return n.readonly_mode=!1,e}))})).subscribe(function(e){var t=e.build,o=(e.meta||{tags:[]}).tags||[];n.meta_tags=new Set(o);var s=t.type,i=e.auth,r=e.tool,a=i.mode;i=i.auth;var l=t.config;console.log("build",t),console.log("build_type",s),console.log("auth",i),console.log("auth_mode",a),console.log("config",l);var c=n.config_form.get(s);if(c){var d=c.get("data"),h=c.get("auth_mode"),u=c.get("authentication");u&&u.setValue(a),h&&(h=h.get(a),Object.keys(i).forEach(function(e){h.contains(e)&&(console.log("config key",e,h.get(e)),h.get(e).setValue(i[e]))}),console.log("authentication_form",h)),d&&Object.keys(l).forEach(function(e){d.contains(e)&&(console.log("config key",e,d.get(e)),d.get(e).setValue(l[e]))})}s&&n.form.get("build_type").setValue(s),r&&(r.name&&n.form.get("tool").get("name").setValue(r.name),r.alias&&n.form.get("tool").get("alias").setValue(r.alias)),n.readonly_mode?(n.form.disable(),n.config_form.disable()):(n.form.enable(),n.config_form.enable())})}},{key:"download",value:function(e){console.log("download",e),this.toolApiService.getBuildDownloadUrl(e).pipe(Object(y.a)(function(e){return e.url}),Object(m.a)(function(e){var n=document.createElement("a");n.href=e,n.target="_blank",n.click()})).subscribe()}},{key:"upload",value:function(e,n){var t=this,o={};this.toolApiService.getBuildUploadUrl("test_id",e.name).pipe(Object(y.a)(function(e){return o=e,e.url})).pipe(Object(y.a)(function(n){return t.toolApiService.uploadWithUrl(e,n)}),Object(F.b)(function(e){return e}),Object(m.a)(function(e){t.bundke_upload_progress.next({uploading:!0,progress:e.progress})}),Object(P.a)(function(e){return e.status})).subscribe(function(e){t.bundke_upload_progress.next({uploading:!1,progress:0});var s=n.controls;Object.keys(o).forEach(function(e){s[e].setValue(o[e])}),console.log("controls",s),t.cdr.markForCheck()})}},{key:"saveChanges",value:function(){this.edit_mode?this.editBuild():this.createBuild()}},{key:"createBuild",value:function(){var e=this,n=this.form.get("build_type").value,t=this.config_form.get(n),o=t.get("authentication").value,s={auth:{auth:t.get("auth_mode").get(o).value,mode:o},build:{config:t.get("data").value,type:n},meta:{tags:Array.from(this.meta_tags.values())},refrence_id:this.refrence_id};this.toolApiService.createBuild(n,s).subscribe(function(n){console.log(n),e.goTo(["builds"])}),console.log("config",s)}},{key:"goTo",value:function(e){this.router.navigate(["./",{outlets:{view:e}}],{relativeTo:this.activatedRoute.parent})}},{key:"editBuild",value:function(){var e=this,n=this.form.get("build_type").value,t=this.config_form.get(n),o=t.get("authentication").value,s={auth:{auth:t.get("auth_mode").get(o).value,mode:o},build:{config:t.get("data").value,type:n},meta:{tags:Array.from(this.meta_tags.values())},refrence_id:this.refrence_id};this.toolApiService.editBuild(this.build_id,n,s).subscribe(function(n){e.goTo(["builds"])}),console.log("config",s)}},{key:"autoGrowTextZone",value:function(e){e.target.style.height="0px",e.target.style.height=e.target.scrollHeight+25+"px"}}]),e}();z.ctorParameters=function(){return[{type:I},{type:c.k},{type:h.f},{type:h.a},{type:M}]},z.propDecorators={edit_mode:[{type:c.I,args:["edit_mode"]}],build_id:[{type:c.I,args:["build_id"]}],close:[{type:c.I,args:["close"]}],refrence_id:[{type:c.I,args:["refrence_id"]}],prefilled_build_data:[{type:c.I,args:["build_data"]}]},z=Object(l.a)([Object(c.n)({selector:"app-build-create",template:'\x3c!-- File:  Dockerfile --\x3e\n\n<ng-template #dockerfile [formGroup]="config_form">\n\n  <ng-container formGroupName="dockerfile">\n\n    <div fxFlex formGroupName="data" fxLayout="column">\n\n      <div>\n        <p class="subtitle-2 text-hint">\n          Dockerfile\n        </p>\n      </div>\n\n      <div fxLayout="row" fxLayoutGap="1rem">\n\n        <nb-form-field fxFlex>\n          <textarea (keyup)="autoGrowTextZone($event)" formControlName="dockerfile" fullWidth nbInput\n            placeholder=" Dockerfile">\n\n          </textarea>\n\n        </nb-form-field>\n\n\n      </div>\n\n\n\n    </div>\n\n    <app-divider></app-divider>\n\n\n  </ng-container>\n\n</ng-template>\n\n\x3c!-- Image:  Docker Hub --\x3e\n<ng-template #registry_public [formGroup]="config_form">\n\n  <ng-container formGroupName="registry_public">\n\n    <div fxLayout="column">\n\n\n      <div formGroupName="data" fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Docker Image\n          </p>\n        </div>\n\n        <div fxLayout="row" fxLayoutGap="1rem">\n\n          <nb-form-field>\n            <input formControlName="image_name" fullWidth nbInput placeholder="Image Name">\n\n          </nb-form-field>\n\n          <nb-form-field>\n            <input formControlName="image_tag" fullWidth nbInput placeholder="Tag Name">\n          </nb-form-field>\n        </div>\n\n\n\n      </div>\n\n      <app-divider></app-divider>\n\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Credentials\n          </p>\n        </div>\n        <div>\n\n          <nb-select size="medium" status="primary" formControlName="authentication" filled\n            placeholder="Authentication">\n\n            <nb-option value="none">\n              No Auth\n            </nb-option>\n            <nb-option value="credentials">\n              Credentials\n            </nb-option>\n\n\n          </nb-select>\n        </div>\n\n      </div>\n\n      <app-divider></app-divider>\n\n      <ng-container formGroupName="auth_mode">\n\n        <ng-container formGroupName="credentials"\n          *ngIf="config_form.value.registry_public.authentication == \'credentials\' ">\n\n          \x3c!-- <div class="subtitle text-hint container label-text">\n          Username\n        </div> --\x3e\n\n          <div fxLayout="row" class="container">\n            <nb-form-field>\n              <nb-icon icon="at-outline" nbPrefix></nb-icon>\n              <input formControlName="username" fullWidth nbInput placeholder="Username">\n            </nb-form-field>\n          </div>\n\n          <div fxLayout="row" class="container">\n\n            <nb-form-field>\n              <nb-icon icon="hash-outline" nbPrefix></nb-icon>\n\n              <input formControlName="password" fullWidth nbInput placeholder="Password">\n            </nb-form-field>\n          </div>\n\n        </ng-container>\n\n        <ng-container formGroupName="access_token"\n          *ngIf="config_form.value.registry_public.authentication == \'access_token\' ">\n\n          <div fxLayout="row" class="container">\n            <nb-form-field fxFlex>\n              <textarea formControlName="auth_token" fullWidth nbInput placeholder="Auth token"></textarea>\n            </nb-form-field>\n\n          </div>\n\n        </ng-container>\n\n      </ng-container>\n\n\n    </div>\n  </ng-container>\n\n</ng-template>\n\n\n\x3c!-- Image: Private Repository --\x3e\n<ng-template #registry_private [formGroup]="config_form">\n\n  <ng-container formGroupName="registry_private">\n\n    <div fxLayout="column">\n\n      <div fxLayoutGap="1rem" formGroupName="data" fxLayout="column">\n\n\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Private Docker Registry\n          </p>\n        </div>\n\n        <div fxLayout="row" fxLayoutGap="1rem">\n\n          <nb-form-field>\n            <input formControlName="registry_url" fullWidth nbInput placeholder="Registry Url">\n\n          </nb-form-field>\n\n\n        </div>\n        <div fxLayout="row" fxLayoutGap="1rem">\n\n          <nb-form-field>\n            <input formControlName="image_name" fullWidth nbInput placeholder="Image Name">\n\n          </nb-form-field>\n\n          <nb-form-field>\n            <input formControlName="image_tag" fullWidth nbInput placeholder="Tag Name">\n          </nb-form-field>\n        </div>\n\n\n\n      </div>\n\n      <app-divider></app-divider>\n\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Credentials\n          </p>\n        </div>\n        <div>\n\n          <nb-select size="medium" status="primary" formControlName="authentication" filled\n            placeholder="Authentication">\n\n            <nb-option value="none">\n              No Auth\n            </nb-option>\n            <nb-option value="credentials">\n              Credentials\n            </nb-option>\n\n\n          </nb-select>\n        </div>\n\n      </div>\n\n      <app-divider></app-divider>\n\n      <ng-container formGroupName="auth_mode">\n\n        <ng-container formGroupName="credentials"\n          *ngIf="config_form.value.registry_private.authentication == \'credentials\' ">\n\n          \x3c!-- <div class="subtitle text-hint container label-text">\n          Username\n        </div> --\x3e\n\n          <div fxLayoutGap="1rem" fxLayout="row" class="container">\n\n\n            <div fxLayout="row" class="container">\n              <nb-form-field>\n                <nb-icon icon="at-outline" nbPrefix></nb-icon>\n                <input formControlName="username" fullWidth nbInput placeholder="Username">\n              </nb-form-field>\n            </div>\n\n            <div fxLayout="row" class="container">\n\n              <nb-form-field>\n                <nb-icon icon="hash-outline" nbPrefix></nb-icon>\n\n                <input formControlName="password" fullWidth nbInput placeholder="Password">\n              </nb-form-field>\n            </div>\n\n          </div>\n\n        </ng-container>\n\n        <ng-container formGroupName="access_token"\n          *ngIf="config_form.value.registry_private.authentication == \'access_token\' ">\n\n          <div fxLayout="row" class="container">\n            <nb-form-field fxFlex>\n              <textarea formControlName="auth_token" fullWidth nbInput placeholder="Auth token"></textarea>\n            </nb-form-field>\n\n          </div>\n\n        </ng-container>\n\n      </ng-container>\n\n    </div>\n  </ng-container>\n\n</ng-template>\n\n\n\x3c!-- Bundle: Git Repository --\x3e\n<ng-template #bundle_git [formGroup]="config_form">\n\n\n  <ng-container formGroupName="bundle_git">\n\n    <div fxFlex fxLayoutGap="1rem" fxLayout="column">\n\n\n      <ng-container formGroupName="data">\n\n        <div fxLayoutAlign="start center" fxLayout="row" fxLayoutGap="1rem">\n\n\n          <div fxFlex>\n            <p class="subtitle-2 text-hint">\n              Repository\n            </p>\n          </div>\n\n          <nb-select size="small" status="primary" formControlName="repository" outline placeholder="Repository">\n\n            <nb-option *ngFor="let repo of gitRepositories" [value]="repo.id">\n              {{repo?.name}}\n            </nb-option>\n\n\n          </nb-select>\n        </div>\n\n        <div fxLayout="row">\n\n          <nb-form-field fxFlex>\n            <span nbPrefix>\n              Url\n            </span>\n\n            <input formControlName="repository_url" fullWidth nbInput placeholder="Repository URL">\n\n          </nb-form-field>\n\n\n        </div>\n\n\n        <div fxLayout="row">\n\n          <nb-form-field fxFlex>\n            <span nbPrefix>\n              file://\n            </span>\n\n            <input fieldSize="small" formControlName="repository_context" fullWidth nbInput\n              placeholder="Repository Context">\n\n          </nb-form-field>\n\n\n        </div>\n\n      </ng-container>\n\n      <div fxLayoutAlign="end center" fxLayout="row">\n\n        <nb-select size="tiny" status="danger" filled formControlName="authentication" placeholder="Authentication">\n\n          <nb-option value="none">\n            No Auth\n          </nb-option>\n          <nb-option value="credentials">\n            Credentials\n          </nb-option>\n          <nb-option value="access_token">\n            Auth Token\n          </nb-option>\n          <nb-option value="privatekey">\n            SSH Key\n          </nb-option>\n        </nb-select>\n      </div>\n\n      <div fxLayout="row" fxLayoutGap="1rem">\n\n        <ng-container formGroupName="auth_mode">\n\n          <ng-container formGroupName="credentials"\n            *ngIf="config_form.value.bundle_git.authentication == \'credentials\' ">\n\n            \x3c!-- <div class="subtitle text-hint container label-text">\n          Username\n        </div> --\x3e\n\n\n\n            <div fxFlex>\n\n              <nb-form-field>\n                <nb-icon icon="at-outline" nbPrefix></nb-icon>\n                <input fieldSize="small" formControlName="username" nbInput placeholder="Username">\n              </nb-form-field>\n            </div>\n\n            <div fxFlex>\n\n              <nb-form-field>\n                <nb-icon icon="hash-outline" nbPrefix></nb-icon>\n\n                <input fieldSize="small" formControlName="password" nbInput placeholder="Password">\n              </nb-form-field>\n\n            </div>\n\n\n          </ng-container>\n\n          <ng-container formGroupName="access_token"\n            *ngIf="config_form.value.bundle_git.authentication == \'access_token\' ">\n\n            <div fxFlex>\n              <nb-form-field fxFlex>\n                <textarea fieldSize="small" formControlName="auth_token" fullWidth nbInput\n                  placeholder="Auth token"></textarea>\n              </nb-form-field>\n\n            </div>\n\n          </ng-container>\n\n          <ng-container formGroupName="privatekey" *ngIf="config_form.value.bundle_git.authentication == \'privatekey\' ">\n\n            <div fxFlex>\n              <nb-form-field fxFlex>\n                <textarea fieldSize="small" formControlName="privatekey" fullWidth nbInput\n                  placeholder="SSH Key"></textarea>\n              </nb-form-field>\n\n            </div>\n\n          </ng-container>\n\n        </ng-container>\n      </div>\n\n    </div>\n\n\n\n\n  </ng-container>\n\n\n</ng-template>\n\n\n\x3c!-- Bundle: Url  --\x3e\n<ng-template #bundle_url [formGroup]="config_form">\n  <ng-container formGroupName="bundle_url">\n\n\n\n\n    <div fxFlex formGroupName="data" fxLayout="column" fxLayoutGap="1rem">\n\n\n      <div fxLayout="row">\n\n\n        <nb-select size="small" status="primary" formControlName="type" filled placeholder="Repository">\n\n          <nb-option *ngFor="let bundle of bundleType" [value]="bundle.id">\n            {{bundle?.name}}\n          </nb-option>\n\n\n        </nb-select>\n\n      </div>\n\n      <div fxLayout="row">\n\n\n        <nb-form-field fxFlex>\n\n          <span nbPrefix>Url</span>\n\n          <input fieldSize="small" formControlName="url" fullWidth nbInput\n            placeholder="git://github.com/meddler-io/first-tool.git">\n\n        </nb-form-field>\n\n\n      </div>\n\n\n    </div>\n\n\n\n\n  </ng-container>\n\n\n</ng-template>\n\n\x3c!-- Bundle: Upload  --\x3e\n<ng-template #bundle_upload [formGroup]="config_form">\n\n  <ng-container formGroupName="bundle_upload">\n\n\n    <ng-container formGroupName="data">\n\n\n      <div fxLayout="column" fxLayoutGap="1rem">\n\n        <div fxLayout="row">\n\n          <nb-select size="small" status="primary" formControlName="type" filled placeholder="Repository">\n\n            <nb-option *ngFor="let bundle of bundleType" [value]="bundle.id">\n              {{bundle?.name}}\n            </nb-option>\n\n\n          </nb-select>\n\n\n        </div>\n\n\n\n\n        <div fxLayout="row" fxLayoutGap="1rem">\n          <input type="file" #file style="display: none"\n            (change)="upload( $event.target.files[0] ,  config_form.get(  \'bundle_upload\').get(\'data\') )">\n\n\n          <button *ngIf=" config_form.get(\'bundle_upload\').get(\'data\').invalid " (click)="file.click()" nbButton\n            size="small">\n            Upload\n\n          </button>\n\n          <button status="primary" [disabled]=" config_form.get(\'bundle_upload\').get(\'data\').invalid "\n            (click)="download( config_form.get(\'bundle_upload\').get(\'data\').value )" nbButton size="small">\n            Download\n\n          </button>\n\n\n          <button (click)=" config_form.get(\'bundle_upload\').get(\'data\').get(\'url\').setValue(\'\') " nbButton\n            size="small">\n            Reset\n\n          </button>\n\n        </div>\n\n        <div fxLayout="row">\n\n          <ng-container *ngIf="bundke_upload_progress | async as bundke_upload_progress">\n\n            <div fxFlex fxLayout="row">\n\n              <nb-progress-bar *ngIf="bundke_upload_progress?.uploading" size="tiny" fxFlex\n                [value]="bundke_upload_progress?.progress" status="success" [displayValue]="true">\n              </nb-progress-bar>\n            </div>\n          </ng-container>\n        </div>\n\n      </div>\n\n\n    </ng-container>\n\n\n  </ng-container>\n\n\n</ng-template>\n\n\n\n<ng-container [formGroup]="form">\n\n  \x3c!-- <nb-layout> --\x3e\n\n  <nb-layout-header fixed>\n    <div fxFlex fxLayout="row">\n\n      <div fxLayoutAlign="start center" fxLayout="row">\n\n        <button (click)="goTo( [ \'builds\' ] )" shape="round" ghost status="basic" class="action" size="large" nbButton>\n          <nb-icon icon="arrow-back-outline">\n\n          </nb-icon>\n        </button>\n\n        <span class="subtitle text-hint lineV">\n          Build Configurator\n        </span>\n\n      </div>\n\n      <button (click)="close.next(true)" shape="round" ghost status="basic" class="action" size="large" nbButton>\n        <nb-icon icon="info">\n\n        </nb-icon>\n      </button>\n\n\n    </div>\n    <div\n    *ngIf="!readonly_mode"\n    fxLayoutAlign="center center "\n    style="margin-right: 1rem;">\n\n\n\n      <button [disabled]="\n\n      config_form?.get( form.get(\'build_type\').value )?.get(\'data\')?.invalid \n      ||\n      config_form?.get( form.get(\'build_type\').value )?.get(\'auth_mode\')?.get(  config_form?.get( form.get(\'build_type\').value )?.get(\'authentication\')?.value ).invalid\n      \n      \n      " (click)="saveChanges()" hero size="medium" shape="round" status="primary" nbButton>\n        <span>\n          Save\n        </span>\n        <nb-icon icon="play-circle"></nb-icon>\n      </button>\n    </div>\n\n  </nb-layout-header>\n\n\n  \x3c!-- <nb-layout-column> --\x3e\n\n  <nb-card  >\n\n    <nb-card-header fxLayoutAlign="space-between center" fxLayout="row">\n\n\n      <div fxLayoutAlign="space-between center" fxLayout="row" fxLayoutGap="1rem">\n        <p class="subtitle text-basic">\n          Build Info\n        </p>\n\n        <button shape="round" ghost nbButton>\n          <nb-icon icon="info"></nb-icon>\n        </button>\n      </div>\n    </nb-card-header>\n\n\n\n    <nb-card-body>\n\n\n\n\n\n      <div fxLayoutGap="1rem" fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Name\n          </p>\n        </div>\n\n        <div formGroupName="tool" fxLayout="row" fxLayoutGap="1rem">\n\n          <nb-form-field>\n\n            <input cdkFocusInitial formControlName="name" nbInput placeholder="Tool Name">\n\n          </nb-form-field>\n          <nb-form-field fieldSize="small">\n            <input formControlName="alias" nbInput placeholder="Tool tag">\n          </nb-form-field>\n        </div>\n      </div>\n\n      <app-divider></app-divider>\n\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Description\n          </p>\n        </div>\n\n        <div fxLayout="row">\n\n          <nb-form-field fxFlex>\n            <textarea formControlName="desc" fullWidth nbInput placeholder="Description"></textarea>\n          </nb-form-field>\n\n        </div>\n\n\n        <app-divider></app-divider>\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Tags\n          </p>\n        </div>\n        <div fxLayout="row">\n\n          <nb-tag-list fxFlex (tagRemove)="onTagRemove($event)">\n            <nb-tag size="small" *ngFor="let tag of meta_tags" [text]="tag" [removable]="!readonly_mode"></nb-tag>\n            <input *ngIf="!readonly_mode" type="text" nbTagInput (tagAdd)="onTagAdd($event)" fullWidth>\n\n          </nb-tag-list>\n\n        </div>\n\n        <app-divider></app-divider>\n\n      </div>\n\n      <app-divider></app-divider>\n\n\n\n\n      <div fxLayoutAlign="space-between center" fxLayout="row" fxLayoutGap="1rem">\n        <p fxFlex class="subtitle text-basic">\n          Tools Source\n        </p>\n\n\n        <nb-select size="small" #buildTypeSelect hero [status]="  form?.value?.build_type ? \'primary\' : \'danger\' "\n          formControlName="build_type" placeholder="Select Build Type">\n          <nb-option-group *ngFor="let group of buildTypes" [title]="group.name">\n            <nb-option [disabled]="!option?.active" *ngFor="let option of group.children " [value]="option.id">\n              {{option?.name}}\n            </nb-option>\n          </nb-option-group>\n        </nb-select>\n\n\n\n      </div>\n\n      <app-divider></app-divider>\n\n\n\n\n\n      \x3c!-- <div class="subtitle text-hint container label-text">\n        Information\n      </div> --\x3e\n\n\n      <div fxLayoutAlign="space-between center" fxLayout="row" fxLayoutGap="1rem">\n\n        <ng-container [ngSwitch]="form.value.build_type">\n\n          <ng-container *ngSwitchCase="\'dockerfile\'">\n            <ng-template *ngTemplateOutlet="dockerfile"> </ng-template>\n          </ng-container>\n\n          <ng-container *ngSwitchCase="\'registry_public\'">\n            <ng-template *ngTemplateOutlet="registry_public"> </ng-template>\n          </ng-container>\n\n          <ng-container *ngSwitchCase="\'registry_private\'">\n            <ng-template *ngTemplateOutlet="registry_private"> </ng-template>\n          </ng-container>\n\n\n          <ng-container *ngSwitchCase="\'bundle_git\'">\n            <ng-template *ngTemplateOutlet="bundle_git"> </ng-template>\n          </ng-container>\n\n\n          <ng-container *ngSwitchCase="\'bundle_url\'">\n            <ng-template *ngTemplateOutlet="bundle_url"> </ng-template>\n          </ng-container>\n\n\n          <ng-container *ngSwitchCase="\'bundle_upload\'">\n            <ng-template *ngTemplateOutlet="bundle_upload"> </ng-template>\n          </ng-container>\n\n\n\n\n        </ng-container>\n\n\n      </div>\n\n    </nb-card-body>\n\n\n\n  </nb-card>\n\n  \x3c!-- </nb-layout-column> --\x3e\n\x3c!-- </nb-layout> --\x3e\n\n</ng-container>',changeDetection:c.j.OnPush,styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\nnb-card {\n  margin: 0;\n}\nnb-card textarea {\n  resize: none;\n}\n.label-text {\n  border-left: 2px var(--text-hint-color) solid !important;\n  margin-bottom: 1rem;\n  padding-left: 4px;\n}\n.subtitle {\n  margin: 0;\n  padding-left: 4px;\n}\nnb-card-header {\n  padding: 0.4rem;\n  box-shadow: 2px 2px 3px rgba(0, 0, 0, 0.16), 2px 2px 3px rgba(0, 0, 0, 0.23);\n}\nnb-card-footer {\n  padding: 0;\n}\nnb-card {\n  border: 0;\n}\n.buildBtn {\n  border-radius: 0;\n}"]})],z);var B=i("SDw7"),O=i("KPRU"),D=i("ZfaG"),W=i("quSY"),E=function(){function e(n,t,o,i,r,a){s(this,e),this.toolApiService=n,this.drawerMngr=t,this.document=o,this.sharedDataService=i,this.activatedRoute=r,this.router=a,this.refrence_id="refrence_id",this.sharedServiceSubscription$=W.a.EMPTY,this.tabs=[]}return r(e,[{key:"ngOnDestroy",value:function(){this.sharedServiceSubscription$.unsubscribe()}},{key:"ngOnInit",value:function(){var e=this;this.sharedServiceSubscription$=this.sharedDataService.ToolId.pipe(Object(m.a)(function(n){e.refrence_id=n})).subscribe(function(){e.loadData()})}},{key:"goTo",value:function(e){this.router.navigate(["./",{outlets:{view:e}}],{relativeTo:this.activatedRoute.parent})}},{key:"loadData",value:function(){var e=this;this.builds$=this.toolApiService.getBuilds(this.refrence_id).pipe(Object(m.a)(function(n){n.length<1&&e.goTo(["build_create"])}),Object(y.a)(function(e){return e}))}},{key:"openDrawer",value:function(e,n){var t=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:B.a.Left,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"50",i=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],r=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],a=arguments.length>6?arguments[6]:void 0;n||(n={}),console.log("context",n),this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:o,template:e,size:s,context:n,closeOnOutsideClick:i,parentContainer:a,isRoot:r,zIndex:1e3,cssClass:"backdrop_color"}).onDestroy(function(){t.document.body.classList.remove("cdk-global-scrollblock")})}},{key:"openLogs",value:function(e,n){var t=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:B.a.Left,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"50%",i=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],r=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],a=arguments.length>6?arguments[6]:void 0;this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:o,template:e,size:s,closeOnOutsideClick:i,parentContainer:a,isRoot:r,zIndex:1e3,cssClass:"backdrop_color",context:{id:n}}).onDestroy(function(){t.document.body.classList.remove("cdk-global-scrollblock")})}},{key:"runTask",value:function(e){var n=this,t={TraceId:e,fprocess:"echo hello world"};this.toolApiService.runTool(e,t).subscribe(function(t){console.log(t),n.openLogs(n.logTemplate,e)})}}]),e}();E.ctorParameters=function(){return[{type:I},{type:O.a},{type:Document,decorators:[{type:c.D,args:[d.d]}]},{type:M},{type:h.a},{type:h.f}]},E.propDecorators={buildCreateTemplate:[{type:c.qb,args:["buildCreateTemplate",{static:!1}]}],logTemplate:[{type:c.qb,args:["logsTemplate",{static:!1}]}]},E=Object(l.a)([Object(c.n)({selector:"app-build-list",template:'<ng-container *ngIf=" builds$ | async as builds ; else loading">\n\n\n  \x3c!-- <nb-layout-header *ngIf="false" @init subHeader>\n\n\n\n    <div fxFlex fxLayout="row" fxLayoutAlign="space-between center">\n\n      <div fxLayout="row" fxLayoutAlign="start center">\n\n        <button shape="round" [routerLink]="[\'/tools\' ]" ghost status="basic" class="action" size="large" nbButton>\n          <nb-icon icon="arrow-back-outline">\n\n          </nb-icon>\n        </button>\n\n        <div class="h6 text-hint">\n\n          Builds\n\n        </div>\n      </div>\n\n\n\n      <div [style.marginRight]=" \'0.5rem\' " fxFlex fxLayout="row" fxLayoutAlign="end center">\n\n        <button (click)="openDrawer(buildCreateTemplate)" class="newBtn" shape="round" nbButton>\n\n          <div class="icon"></div>\n\n          <span>\n            Create Build\n\n          </span>\n        </button>\n\n\n      </div>\n\n    </div>\n\n  </nb-layout-header> --\x3e\n\n\n\n  <nb-accordion cdkScrollable @init>\n    <nb-accordion-item [expanded]="index == 0" *ngFor="let build of builds  ; index as index">\n      <nb-accordion-item-header fxLayoutAlign="space-between">\n\n        <span>\n          {{ build?.name || \'Build Name\' }}\n\n        </span>\n\n        <span class="text-hint">\n          {{ \'@\' + ( build?.tool?.alias || \'Alias\' ) }}\n        </span>\n      </nb-accordion-item-header>\n      <nb-accordion-item-body>\n\n        <nb-card>\n          <nb-card-body>\n            <div class="text-hint">\n              {{ build?.description || \'Build Description\' }}\n\n            </div>\n\n            <div class="text-hint">\n              {{ build?.doc || date }}\n\n            </div>\n\n          </nb-card-body>\n          <nb-card-footer fxLayoutGap="1rem" fxLayoutAlign="end center">\n\n            <button *ngIf="false" (click)="openDrawer(buildconfigTemplate , context =  { \'build_id\':  build?._id } )"\n              status="basic" ghost size="small" nbButton>\n\n              <nb-icon icon="file-text-outline"></nb-icon>\n              Config\n            </button>\n\n            <button (click)="openLogs(logsTemplate, build?._id)" status="basic" ghost size="small" nbButton>\n\n              <nb-icon icon="file-text-outline"></nb-icon>\n              Build Logs\n            </button>\n\n            <button (click)="openDrawer(logsTemplate)" status="basic" ghost size="small" nbButton>\n\n              <nb-icon icon="settings-2-outline"></nb-icon>\n              Monitor\n            </button>\n\n\n            <button status="basic" ghost size="small" nbButton>\n\n              <nb-icon icon="diagonal-arrow-left-down-outline"></nb-icon>\n              Fork\n            </button>\n\n\n\n          </nb-card-footer>\n\n          <nb-card-footer fxLayoutGap="1rem" fxLayoutAlign="end center">\n\n\n            <nb-select scrollStrategy="reposition" [style.marginRight]="\'1rem\'" [selected]="0"\n              *ngIf="build?.executors?.length > 0" placeholder="Success" size="small" status="danger" filled>\n              <nb-option status="success" *ngFor="let topic of build?.executors ; index as index" [value]="index">\n                \x3c!-- {{topic?._id}} --\x3e\n                Version {{ build?.executors?.length -   index }}\n              </nb-option>\n\n            </nb-select>\n\n            <button\n              (click)="openDrawer(buildEditTemplate  , context =  { \'build_id\':  build?._id , \'edit_mode\': true } )"\n              status="basic" size="small" nbButton>Edit</button>\n\n            <button (click)="runTask( build?._id ) " status="primary" size="small" nbButton>Build</button>\n\n\n          </nb-card-footer>\n        </nb-card>\n\n\n      </nb-accordion-item-body>\n    </nb-accordion-item>\n\n  </nb-accordion>\n\n\n</ng-container>\n\n\n<ng-template #loading>\n  <div fxLayoutAlign="center center">\n    <ngx-progress-spinner></ngx-progress-spinner>\n  </div>\n\n</ng-template>\n\n<ng-template #logsTemplate let-close="close" let-context="context">\n\n  <app-log-stream [close]="close" [log_id]="context?.id"></app-log-stream>\n\n\n</ng-template>\n\n<ng-template let-close="close" let-context="context" #buildEditTemplate>\n\n  <app-build-create [edit_mode]="context.edit_mode" [close]="close" [build_id]="context.build_id"\n    [refrence_id]="refrence_id"></app-build-create>\n\n</ng-template>\n\n<ng-template let-close="close" #buildCreateTemplate>\n\n  <app-build-create [close]="close" [refrence_id]="refrence_id"></app-build-create>\n\n</ng-template>\n\n\n\n\n<ng-template let-close="close" let-context="context" #buildconfigTemplate>\n\n  <app-build-config [close]="close" [build_id]="context?.build_id"></app-build-config>\n\n</ng-template>',changeDetection:c.j.OnPush,animations:e(D.a),styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\n:host ::ng-deep nb-route-tabset {\n  overflow-x: auto;\n  overflow-y: hidden;\n  padding-bottom: 0.2rem !important;\n  /* IE and Edge */\n  /* Firefox */\n}\n:host ::ng-deep nb-route-tabset ::-webkit-scrollbar {\n  display: none;\n}\n:host ::ng-deep nb-route-tabset .tab {\n  margin-right: 0.5rem;\n}\nnb-accordion {\n  margin: 0 !important;\n}\nnb-accordion-item {\n  margin-top: 0.4rem;\n}\nnb-accordion-item nb-accordion-item-header:hover {\n  background: var(--color-basic-700);\n  color: #fff;\n}\nnb-card {\n  margin-bottom: 0;\n  border: 0;\n}\nnb-accordion {\n  margin: 1rem;\n}\n.h6 {\n  margin-left: 1rem;\n}\nnb-accordion-item-header.accordion-item-header-expanded {\n  border-left: 2px var(--text-basic-color) solid !important;\n}\nbutton.newBtn {\n  padding: 0.3rem !important;\n  padding-left: 1rem !important;\n  padding-right: 1rem !important;\n  text-transform: capitalize !important;\n  box-shadow: 0 1px 2px 0 rgba(60, 64, 67, 0.302), 0 1px 3px 1px rgba(60, 64, 67, 0.149) !important;\n  align-items: center !important;\n  background-color: #fff !important;\n  border: 1px solid transparent;\n  border-radius: 24px;\n  color: #3c4043 !important;\n}\nbutton.newBtn span {\n  margin-right: 1rem;\n  margin-top: 0.5rem;\n  margin-bottom: 0.5rem;\n  font-weight: 600;\n}\nbutton.newBtn .icon {\n  margin-right: 1rem;\n  background-image: url(\"data:image/svg+xml;charset=UTF-8,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2236%22 height=%2236%22 viewBox=%220 0 36 36%22%3E%3Cpath fill=%22%2334A853%22 d=%22M16 16v14h4V20z%22/%3E%3Cpath fill=%22%234285F4%22 d=%22M30 16H20l-4 4h14z%22/%3E%3Cpath fill=%22%23FBBC05%22 d=%22M6 16v4h10l4-4z%22/%3E%3Cpath fill=%22%23EA4335%22 d=%22M20 16V6h-4v14z%22/%3E%3Cpath fill=%22none%22 d=%22M0 0h36v36H0z%22/%3E%3C/svg%3E\");\n  width: 2rem !important;\n  height: 2rem !important;\n}\nbutton.newBtn:hover {\n  box-shadow: 0 3px 5px 0 rgba(60, 64, 67, 0.302), 0 3px 5px 1px rgba(60, 64, 67, 0.149) !important;\n  background-color: #fff !important;\n}\n.icon {\n  background-image: url(\"data:image/svg+xml;charset=UTF-8,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2236%22 height=%2236%22 viewBox=%220 0 36 36%22%3E%3Cpath fill=%22%2334A853%22 d=%22M16 16v14h4V20z%22/%3E%3Cpath fill=%22%234285F4%22 d=%22M30 16H20l-4 4h14z%22/%3E%3Cpath fill=%22%23FBBC05%22 d=%22M6 16v4h10l4-4z%22/%3E%3Cpath fill=%22%23EA4335%22 d=%22M20 16V6h-4v14z%22/%3E%3Cpath fill=%22none%22 d=%22M0 0h36v36H0z%22/%3E%3C/svg%3E\");\n}\n.head {\n  height: 4rem;\n  background: var(--background-alternative-color-2);\n  box-shadow: 2px 2px 3px rgba(255, 255, 255, 0.16), 2px 2px 3px rgba(255, 255, 255, 0.23);\n  color: #fff;\n}\n.content {\n  height: calc(100% - 4rem);\n  overflow: auto;\n}\n.action {\n  margin-left: 5px;\n}\n.action:hover nb-icon {\n  color: var(--color-alternate-500);\n}\nnb-tab {\n  padding: 0px;\n}\nnb-card {\n  max-height: calc(100vh - 7rem);\n  margin: 0;\n}\nnb-card .container {\n  margin-top: 1rem;\n}\nnb-card textarea {\n  resize: none;\n}\nnb-card nb-card-header {\n  padding: 0.4rem;\n}"]})],E);var G=i("rDax"),N=i("+rOU"),$=function(){function e(n,t,o,i,r,a,l,c,d,h,u){s(this,e),this.toolApiService=n,this.cdr=t,this.drawerMngr=o,this.document=i,this.activatedRoute=r,this.sharedDataService=a,this.dialogService=l,this.applicationRef=c,this.overlay=h,this.router=u,this.isOpen=!1,this.images=[],this.sharedServiceSubscription$=W.a.EMPTY,this.appElementRef=d.get(c.componentTypes[0]).elementRef}return r(e,[{key:"goTo",value:function(e){this.router.navigate(["./",{outlets:{view:e}}],{relativeTo:this.activatedRoute.parent})}},{key:"ngOnDestroy",value:function(){this.sharedServiceSubscription$.unsubscribe()}},{key:"ngOnInit",value:function(){var e=this;this.sharedServiceSubscription$=this.sharedDataService.ToolId.pipe(Object(m.a)(function(n){e.tool_id=n})).subscribe(function(){e.loadData()})}},{key:"loadData",value:function(){var e=this;this.toolApiService.getToolImageTags(this.tool_id).subscribe(function(n){e.images=n,e.cdr.markForCheck()})}},{key:"openDiaog",value:function(e,n){var t=this.overlay.create({hasBackdrop:!0,maxWidth:"50vw",panelClass:"rightNav"}),o=new N.c(_);t.addPanelClass("example-overlay"),t.backdropClick().subscribe(function(){return t.dispose()}),t.attach(o)}},{key:"openDrawer",value:function(e,n){var t=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:B.a.Left,s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],i=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],r=arguments.length>6?arguments[6]:void 0;n||(n={}),console.log("context",n),this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:o,template:e,context:n,closeOnOutsideClick:s,parentContainer:r,isRoot:i,zIndex:1e3,cssClass:"backdrop_color"}).onDestroy(function(){t.document.body.classList.remove("cdk-global-scrollblock")})}},{key:"deploy_test",value:function(e){this.toolApiService.createDeploymentTest(e).subscribe(function(e){console.log(e)})}},{key:"deploy",value:function(e){this.toolApiService.createDeployment(e).subscribe(function(e){console.log(e)})}}]),e}();$.ctorParameters=function(){return[{type:I},{type:c.k},{type:O.a},{type:Document,decorators:[{type:c.D,args:[d.d]}]},{type:h.a},{type:M},{type:p.j},{type:c.g},{type:c.H},{type:G.e},{type:h.f}]},$.propDecorators={tool_id:[{type:c.I,args:["tool_id"]}],hello:[{type:c.qb,args:["hello"]}],mainWindow:[{type:c.qb,args:["tpmainWindowl"]}]},$=Object(l.a)([Object(c.n)({selector:"app-built-image-list",template:'<div #mainWindow>\n\n\n  <nb-accordion>\n    <nb-accordion-item [expanded]="index == 0" *ngFor="let build of images  ; index as index">\n      <nb-accordion-item-header fxLayoutAlign="space-between">\n\n        <span>\n          {{ build?.name || \'Build Name\' }}\n\n        </span>\n\n        <span class="text-hint">\n          {{ \'@\' + ( build?.tool?.alias || \'Alias\' ) }}\n        </span>\n      </nb-accordion-item-header>\n      <nb-accordion-item-body>\n\n        <nb-card>\n          <nb-card-body>\n            <div class="text-hint">\n              {{ build?.description || \'Build Description\' }}\n\n            </div>\n\n            <div class="text-hint">\n              {{ build?.doc || date }}\n\n            </div>\n\n          </nb-card-body>\n          <nb-card-footer fxLayoutGap="1rem" fxLayoutAlign="end center">\n\n            \x3c!-- (click)="openDrawer(buildconfigTemplate , context =  { \'build_id\':  build?._id } )"  --\x3e\n            <button (click)="goTo( [  \'images\',  \'config\' , build?._id ] )" status="basic" ghost size="small" nbButton>\n\n              <nb-icon icon="file-text-outline"></nb-icon>\n              Config\n            </button>\n\n            <button (click)="openDrawer(logsTemplate, context = {\n            \'id\': build?._id\n\n          }  )" status="basic" ghost size="small" nbButton>\n\n              <nb-icon icon="file-text-outline"></nb-icon>\n              Logs\n            </button>\n\n\n            <button (click)="openDrawer(buildEditTemplate, context = {\n              \'id\': build?._id\n              , \'build\': build?.build\n            }  )" status="basic" ghost size="small" nbButton>\n\n              <nb-icon icon="file-text-outline"></nb-icon>\n              Build Details\n            </button>\n\n\n            <ng-template let-close="close" let-context="context" #buildEditTemplate>\n\n              <app-build-create [edit_mode]="true" [close]="close"\n              \n              [build_data]="context.build"\n              [build_id]="context.build_id"\n                [refrence_id]="refrence_id"></app-build-create>\n\n            </ng-template>\n\n\n\n          </nb-card-footer>\n\n          <nb-card-footer fxLayoutGap="1rem" fxLayoutAlign="end center">\n\n\n            <nb-select [style.marginRight]="\'1rem\'" [selected]="0" *ngIf="build?.executors?.length > 0"\n              placeholder="Success" size="small" status="danger" filled>\n              <nb-option status="success" *ngFor="let topic of build?.executors ; index as index" [value]="index">\n                {{topic?._id}}\n\n              </nb-option>\n\n            </nb-select>\n\n            <button *ngIf="false"\n              (click)="openDrawer(buildEditTemplate  , context =  { \'build_id\':  build?._id , \'edit_mode\': true  } )"\n              status="basic" size="small" nbButton>Edit</button>\n\n            \x3c!-- <button (click)="runTask( build?._id ) " status="primary" size="small" nbButton>Build</button> --\x3e\n\n            <button outline (click)="deploy_test( build?._id ) " status="info" size="small" nbButton>Test</button>\n            <button outline (click)="deploy( build?._id ) " status="danger" size="small" nbButton>Deploy</button>\n          </nb-card-footer>\n        </nb-card>\n\n\n      </nb-accordion-item-body>\n    </nb-accordion-item>\n\n  </nb-accordion>\n\n</div>\n\n<ng-template #logsTemplate let-close="close" let-context="context">\n\n  <app-log-stream [close]="close" [deep_link]="true" [log_id]="context?.id"></app-log-stream>\n\n\n</ng-template>\n\n\n\n<ng-container #loading *ngIf="!images || images.length == 0">\n  <div fxLayoutAlign="center center">\n    <ngx-progress-spinner></ngx-progress-spinner>\n  </div>\n\n</ng-container>\n\n\n\x3c!--  --\x3e\n\n\x3c!-- Template Outlets --\x3e\n\n\n<ng-template #loading>\n  <div fxLayoutAlign="center center">\n    <ngx-progress-spinner></ngx-progress-spinner>\n  </div>\n\n</ng-template>\n\n<ng-template #logsTemplate let-close="close" let-context="context">\n\n  <app-log-stream [close]="close" [log_id]="context?.id"></app-log-stream>\n\n\n</ng-template>\n\n<ng-template let-close="close" let-context="context" #buildEditTemplate>\n\n  <app-build-create [edit_mode]="context.edit_mode" [close]="close" [build_id]="context.build_id"\n    [refrence_id]="refrence_id"></app-build-create>\n\n</ng-template>\n\n<ng-template let-close="close" #buildCreateTemplate>\n\n  <app-build-create [close]="close" [refrence_id]="refrence_id"></app-build-create>\n\n</ng-template>\n\n\n\n\n<ng-template let-ref="dialogRef" let-data="context" #buildconfigTemplate>\n\n\n  <app-build-config [close]="close" [build_id]="context?.build_id"></app-build-config>\n\n\n\n</ng-template>\n\n\n\x3c!-- This template displays the overlay content and is connected to the button --\x3e\n\n<ng-template cdkConnectedOverlay [cdkConnectedOverlayOrigin]="trigger" [cdkConnectedOverlayOpen]="isOpen">\n\n  <app-build-config [close]="close" build_id="63d9064e1a63f05fd615b2c0"></app-build-config>\n\n</ng-template>',styles:["nb-accordion-item {\n  margin-bottom: 1rem;\n}\n\nnb-card {\n  margin-bottom: 0;\n}"]})],$);var q=function(){function e(n,t,o,i,r,a,l){var c=this;s(this,e),this.toolApiService=n,this.drawerMngr=t,this.document=o,this.activatedRoute=i,this.cdr=r,this.sharedDataService=a,this.router=l,this.isTest=!1,this.sharedServiceSubscription$=W.a.EMPTY,this.activatedRoute.paramMap.subscribe(function(e){c.ngOnInit()})}return r(e,[{key:"goTo",value:function(e){this.router.navigate(["./",{outlets:{view:e}}],{relativeTo:this.activatedRoute.parent})}},{key:"ngOnDestroy",value:function(){var e;null===(e=this.dialogRef)||void 0===e||e.destroy(),this.sharedServiceSubscription$.unsubscribe()}},{key:"setEnvironment",value:function(e){var n=this;return this.activatedRoute.data.pipe(Object(y.a)(function(t){return n.isTest=1==(null==t?void 0:t.test),console.log("_data_",n.isTest),e}))}},{key:"ngOnInit",value:function(){var e,n,t=this;null===(e=this.dialogRef)||void 0===e||e.destroy(),null===(n=this.sharedServiceSubscription$)||void 0===n||n.unsubscribe(),this.sharedServiceSubscription$=this.sharedDataService.ToolId.pipe(Object(m.a)(function(e){t.tool_id=e})).pipe(Object(F.b)(function(e){return t.setEnvironment(e)})).subscribe(function(){t.loadData()})}},{key:"loadData",value:function(){var e=this;console.log("ngOnInit"),(this.isTest?this.toolApiService.getDeploymentsTest(this.tool_id):this.toolApiService.getDeployments(this.tool_id)).pipe(Object(y.a)(function(n){var t=[];return n.forEach(function(n,o){var s=n,i={id:s,details:e.isTest?e.toolApiService.getDeploymentTest(s):e.toolApiService.getDeployment(s)};t.push(i)}),t})).subscribe(function(n){e.deployments=n,e.cdr.markForCheck()})}},{key:"stopJob",value:function(e){(this.isTest?this.toolApiService.stopDeploymentTest(e):this.toolApiService.stopDeployment(e)).subscribe()}},{key:"purge",value:function(){(this.isTest?this.toolApiService.purgeDeploymentTest():this.toolApiService.purgeDeployment()).subscribe()}},{key:"runJob",value:function(e){console.log("runJob",e)}},{key:"execJob",value:function(e){this.toolApiService.execJob(e,{}).subscribe()}},{key:"openDrawer",value:function(e,n){var t=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:B.a.Left,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"50",i=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],r=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],a=arguments.length>6?arguments[6]:void 0;n||(n={}),console.log("context",n),this.document.body.classList.add("cdk-global-scrollblock"),this.dialogRef=this.drawerMngr.create({direction:o,template:e,size:s,context:n,closeOnOutsideClick:i,parentContainer:a,isRoot:r,zIndex:1e3,cssClass:"backdrop_color"}),this.dialogRef.onDestroy(function(){t.document.body.classList.remove("cdk-global-scrollblock")})}}]),e}();q.ctorParameters=function(){return[{type:I},{type:O.a},{type:Document,decorators:[{type:c.D,args:[d.d]}]},{type:h.a},{type:c.k},{type:M},{type:h.f}]},q.propDecorators={tool_id:[{type:c.I,args:["tool_id"]}]},q=Object(l.a)([Object(c.n)({selector:"app-deployment-ui",template:'<div fxLayout="column">\n  <ng-container *ngFor="let deploy of deployments  ; index as index">\n\n    <nb-card *ngIf="deploy.details | async as details">\n      <nb-card-header>\n        \x3c!-- Name --\x3e\n        <div class="row">\n          <div fxFlex class="text-hint">\n\n            @{{ details?.Name }}\n\n          </div>\n          <div fxFlex class="subtitle-2">\n            {{details?.Status}}\n\n\n            \x3c!-- @{{ details?.BuildDetails | json  }} --\x3e\n\n\n          </div>\n        </div>\n\n      </nb-card-header>\n\n      <nb-card-body>\n\n\n        \x3c!-- Namespace --\x3e\n        <div class="row">\n          <div fxFlex class="subtitle">\n            Namespace\n\n          </div>\n          <div fxFlex class="subtitle-2">\n            {{ details?.Namespace }}\n\n          </div>\n        </div>\n\n\n\n        \x3c!-- Status --\x3e\n        <div class="row">\n          <div fxFlex class="subtitle">\n            Status\n\n          </div>\n          <div fxFlex class="subtitle-2">\n            {{ details?.Status }}\n\n          </div>\n        </div>\n\n\n        \x3c!-- Submitted On --\x3e\n        <div class="row">\n          <div fxFlex class="subtitle">\n            SubmitTime\n\n          </div>\n          <div fxFlex class="subtitle-2">\n            {{ details?.SubmitTime / 1000000 | date:"dd-MM-YY , HH:mm:ss" }}\n\n          </div>\n        </div>\n\n\n\n\n\n      </nb-card-body>\n\n\n      <nb-card-footer fxLayoutGap="1rem" fxLayoutAlign="start">\n\n\n        <button (click)="purge(  )" status="primary" ghost size="small" nbButton>\n\n          <nb-icon icon="settings-2-outline"></nb-icon>\n          Purge\n        </button>\n\n\n        \x3c!-- <button (click)="execJob( deploy?.id )" status="primary" ghost size="small" nbButton>\n\n          <nb-icon icon="settings-2-outline"></nb-icon>\n          Exec\n        </button> --\x3e\n\n        \x3c!-- (click)="openDrawer(jobConfigTemplate , context =  { config: details?.JobConfig , id : deploy?.id }  ) " --\x3e\n        <button (click)="goTo( [ isTest ? \'test-deployments\' :  \'deployments\',  \'config\' , deploy?.id ] )" status="success" ghost size="small" nbButton>\n\n          <nb-icon icon="settings-2-outline"></nb-icon>\n          Run\n        </button>\n\n\n        <button (click)="stopJob( deploy?.id )" status="basic" ghost size="small" nbButton>\n\n          <nb-icon icon="settings-2-outline"></nb-icon>\n          Stop\n        </button>\n\n        <button (click)="openDrawer(logsTemplate)" status="danger" ghost size="small" nbButton>\n\n          <nb-icon icon="settings-2-outline"></nb-icon>\n          Logs\n        </button>\n\n\n        <button status="basic" ghost size="small" nbButton>\n\n          <nb-icon icon="diagonal-arrow-left-down-outline"></nb-icon>\n\n          {{details?.Status}}\n        </button>\n\n\n\n      </nb-card-footer>\n    </nb-card>\n  </ng-container>\n\n</div>\n\n\n<ng-template #logsTemplate let-close="close" let-context="context">\n\n  <app-log-stream [close]="close" [deep_link]="true" [log_id]="context?.id"></app-log-stream>\n\n</ng-template>\n\n\n<ng-template let-close="close" let-context="context" #jobConfigTemplate>\n\n  <app-job-config [config]="context?.config" [id]="context?.id"></app-job-config>\n\n</ng-template>\n\n\n<ng-container #loading *ngIf="!deployments || deployments.length == 0">\n  <div fxLayoutAlign="center center">\n    <ngx-progress-spinner></ngx-progress-spinner>\n  </div>\n\n</ng-container>',styles:["nb-card-footer {\n  padding: 0.3rem;\n  overflow-x: scroll;\n  overflow-y: hidden;\n}"]})],q);var V=i("w1tV"),U=i("y8eJ"),J=i("c0TW"),H=function(){function e(n,t,o,i,r,a,l,c,d){for(var h in s(this,e),this.fb=n,this.toolApiService=t,this.cdr=o,this.drawerMngr=i,this.document=r,this.assetApiService=a,this.activatedRoute=l,this.router=c,this.dialogService=d,this.raw_args_editor=new u.d("dsad=\"dsadsa sad sdsa  d dsa\" one='123'  dsdsd d='sad'  fdfd='fdsf  fds' fdsfdsfdfds='23r23r\"fdsfsdf'\n  dfdsfdsfdsfsdf'fdsfdsf'  \"dsadsad\" \n\n"),this.isTest=!1,this.helper_data={},this.LOADING=!1,this.build_id="6023ed566c2cdfd6f2edb435",this.assetTypes$=this.toolApiService.GetAssetTypes(),this.form=new u.e({id:new u.d(""),entrypoint:this.fb.array([new u.d({value:""})]),assets:new u.d([]),cmd:this.fb.array([this.fb.control("/bin/cmd")]),args:this.fb.array([this.fb.control("hello"),this.fb.control("hello")]),config_files:this.fb.array([this.fb.control("")]),substitute_var:new u.d(!0),variables:new u.b([]),success_endpoint:new u.d("http://success_endpoint.com/usr/bin/mobsf"),failure_endpoint:new u.d(""),config:new u.e({process:new u.b([]),reserved:new u.b([]),_reserved:new u.e({}),system:new u.b([]),_process:new u.e({input_api:new u.d(""),input_api_token:new u.d(""),output_api:new u.d(""),file_upload_api:new u.d("")}),_system:new u.e({base_path:new u.d(""),input_dir:new u.d(""),output_dir:new u.d(""),results_json:new u.d(""),results_schema:new u.d(""),log_to_file:new u.d(!0),stdout_file:new u.d(""),stderr_file:new u.d(""),enable_logging:new u.d(!0),max_output_filesize:new u.d(1e3),sample_inputfile:new u.d(""),sample_outputfile:new u.d("")})})}),this.asset$={},this.reservedConstants$=this.toolApiService.getReservedConstants().pipe(Object(V.a)()),J.b)console.log("logger",h.valueOf(),J.b[h]),this.asset$[J.b[h]]=this.assetApiService.getAsset(J.b[h]);console.debug("asset",this.asset$)}return r(e,[{key:"parseArgs",value:function(e){for(var n,t=/([^'"\s]*"([^"]*)["]*[^'"\s]*|[^'"\s]*'([^']*)[']*[^'"\s]*|[^\s"']+)/gm,o=[];null!==(n=t.exec(e));){n.index===t.lastIndex&&t.lastIndex++;var s=n[0];o.push(s),console.log("argument",n)}this.setArgs(o)}},{key:"getArgs",value:function(){return this.form.get("args")}},{key:"getConfigFiles",value:function(){return this.form.get("config_files")}},{key:"setArgs",value:function(e){var n=this;this.form.get("args");var t=this.fb.array([]);e.forEach(function(e){t.push(n.fb.control(e))}),this.form.setControl("args",t)}},{key:"deleteArg",value:function(e){this.getArgs().removeAt(e)}},{key:"getVariables",value:function(){return this.form.get("variables")}},{key:"getConfProcess",value:function(){return this.form.get("config").get("process")}},{key:"getConfSystem",value:function(){return this.form.get("config").get("system")}},{key:"getConfReserved",value:function(){return this.form.get("config").get("reserved")}},{key:"deleteVariables",value:function(e){this.getVariables().removeAt(e)}},{key:"deleteConfProcess",value:function(e){this.getConfProcess().removeAt(e)}},{key:"deleteConfSystem",value:function(e){this.getConfSystem().removeAt(e)}},{key:"deleteConfReserved",value:function(e){this.getConfReserved().removeAt(e)}},{key:"setEnvironment",value:function(e){var n=this;return this.activatedRoute.data.pipe(Object(y.a)(function(t){return n.isTest=1==(null==t?void 0:t.test),console.log("_data_",n.isTest),n.isTest?n.form.enable():n.form.disable(),e}))}},{key:"open",value:function(e){var t,o=this,s="",i=n(this.getArgs().controls);try{for(i.s();!(t=i.n()).done;){s+=t.value.value+" "}}catch(r){i.e(r)}finally{i.f()}console.log("openDialog",s),this.dialogService.open(e,{context:{args:s,cmd:this.form.get("cmd").value}}).onClose.subscribe(function(e){e&&(o.form.setControl("cmd",o.fb.array([o.fb.control(null==e?void 0:e.cmd)])),o.parseArgs(null==e?void 0:e.args))})}},{key:"ngAfterViewChecked",value:function(){}},{key:"ngAfterViewInit",value:function(){}},{key:"goTo",value:function(e){this.router.navigate(["./",{outlets:{view:e}}],{relativeTo:this.activatedRoute.parent})}},{key:"ngOnInit",value:function(){var e=this;this.activatedRoute.paramMap.pipe(Object(F.b)(function(n){return e.setEnvironment(n)})).pipe(Object(m.a)(function(n){n.has("id")&&(e.id=n.get("id")),e.loadConfig()})).subscribe()}},{key:"addArg",value:function(){this.getArgs().push(this.fb.control(""))}},{key:"addConfigFile",value:function(){this.getConfigFiles().push(this.fb.control("",[u.n.required]))}},{key:"deleteConfigFile",value:function(e){this.getConfigFiles().removeAt(e)}},{key:"addVar",value:function(){this.getVariables().push(new u.e({key:new u.d(""),value:new u.d("")}))}},{key:"addConfProcess",value:function(){this.getConfProcess().push(new u.e({key:new u.d(""),value:new u.d("")}))}},{key:"addSystemProcess",value:function(){this.getConfSystem().push(new u.e({key:new u.d(""),value:new u.d("")}))}},{key:"addReservedProcess",value:function(){this.getConfReserved().push(new u.e({key:new u.d(""),value:new u.d("")}))}},{key:"formToJson",value:function(){var e=this.form.getRawValue(),n={};e.variables.forEach(function(e){n[e.key]=e.value}),e.variables=n;var t={process:{},reserved:{},system:{}};return e.config.process.forEach(function(e){t.process[e.key]=e.value}),e.config.reserved.forEach(function(e){t.reserved[e.key]=e.value}),e.config.system.forEach(function(e){t.system[e.key]=e.value}),delete e._process,delete e._reserved,delete e._system,e.config=t,e}},{key:"save",value:function(){var e,n=null===(e=this.id)||void 0===e?void 0:e.split(":").pop();this.toolApiService.updateBuildConfigSoftlink(n,this.formToJson()).subscribe(function(e){})}},{key:"loadConfig",value:function(){var e,n=this;this.LOADING=!0,this.toolApiService.getBuildConfigSoftlink(null===(e=this.id)||void 0===e?void 0:e.split(":").pop()).subscribe(function(e){var t;if(console.log("config",e),e||(e={}),e.id&&n.form.setControl("id",n.fb.control(e.id)),e.cmd){var o=[];0==(null===(t=e.cmd)||void 0===t?void 0:t.length)&&(e.cmd=[""]),e.cmd.forEach(function(e){o.push(n.fb.control(e))}),n.form.setControl("cmd",n.fb.array(o))}if(e.entrypoint){var s=n.fb.array([]);e.entrypoint.forEach(function(e){s.push(n.fb.control({value:e,disabled:!0}))}),console.log("entrypointControl",s),n.form.setControl("entrypoint",s)}if(e.entrypoint){var i=[];e.args.forEach(function(e){i.push(n.fb.control(e))}),n.form.setControl("args",n.fb.array(i))}e.substitute_var&&n.form.setControl("substitute_var",n.fb.control(e.substitute_var)),e.success_endpoint&&n.form.setControl("success_endpoint",n.fb.control(e.success_endpoint)),e.failure_endpoint&&n.form.setControl("failure_endpoint",n.fb.control(e.failure_endpoint)),e.assets&&n.form.setControl("assets",n.fb.control(e.assets));var r=n.fb.array([]);if(e.variables&&Object.keys(e.variables).forEach(function(t){r.push(n.fb.group({key:n.fb.control(t),value:n.fb.control(e.variables[t])}))}),n.form.setControl("variables",r),e.config){var a=[],l=[],c=[];e.config.process&&Object.keys(e.config.process).forEach(function(t){a.push(n.fb.group({key:n.fb.control(t),value:n.fb.control(e.config.process[t])}))}),e.config.system&&Object.keys(e.config.system).forEach(function(t){l.push(n.fb.group({key:n.fb.control(t),value:n.fb.control(e.config.system[t])}))}),e.config.reserved&&Object.keys(e.config.reserved).forEach(function(t){c.push(n.fb.group({key:n.fb.control({value:t}),value:n.fb.control({value:e.config.reserved[t]})}))});var d=n.fb.group({process:n.fb.array(a),reserved:n.fb.array(c),system:n.fb.array(l)});n.form.setControl("config",d)}n.LOADING=!1,n.isTest?n.form.enable():n.form.disable(),n.cdr.markForCheck()})}},{key:"run",value:function(){var e=this;this.toolApiService.execJob(this.id,this.formToJson()).subscribe(function(n){var t=n._id;e.openLogs(e.logsTemplate,t)})}},{key:"openLogs",value:function(e,n){var t=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:B.a.Left,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"50%",i=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],r=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],a=arguments.length>6?arguments[6]:void 0;this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:o,template:e,size:s,closeOnOutsideClick:i,parentContainer:a,isRoot:r,zIndex:1e3,cssClass:"backdrop_color",context:{id:n}}).onDestroy(function(){t.document.body.classList.remove("cdk-global-scrollblock")})}},{key:"onSelectionChange",value:function(e){}},{key:"onSelectionChanged",value:function(e){}},{key:"autoGrowTextZone",value:function(e){e.target.style.height="0px",e.target.style.height=e.target.scrollHeight+25+"px"}}]),e}();H.ctorParameters=function(){return[{type:u.c},{type:I},{type:c.k},{type:O.a},{type:Document,decorators:[{type:c.D,args:[d.d]}]},{type:U.a},{type:h.a},{type:h.f},{type:p.j}]},H.propDecorators={logsTemplate:[{type:c.qb,args:["logsTemplate",{static:!1}]}],id:[{type:c.I,args:["id"]}],config:[{type:c.I,args:["config"]}],close:[{type:c.I,args:["close"]}],refrence_id:[{type:c.I,args:["refrence_id"]}],build_id:[{type:c.I,args:["build_id"]}]},H=Object(l.a)([Object(c.n)({selector:"app-job-config",template:'<ng-template #rawArgsEditorDialog let-data let-ref="dialogRef">\n  <nb-card>\n    <nb-card-header>\n\n\n      <button shape="round" ghost status="basic" class="action" size="large" nbButton>\n        <nb-icon icon="info">\n\n        </nb-icon>\n      </button>\n\n      <span class="subtitle text-hint lineV">\n        Build Configuration\n\n      </span>\n    </nb-card-header>\n\n\n    <nb-card-body>\n\n      <div fxFlex>\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Command\n          </p>\n        </div>\n\n\n        <nb-form-field>\n\n\n          <input #cmd [value]="data.cmd" nbInput fullWidth placeholder="Argument Parser">\n        </nb-form-field>\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Arguments\n          </p>\n        </div>\n\n        <nb-form-field>\n\n          <textarea #args (keyup)="autoGrowTextZone($event)" nbInput fullWidth\n            placeholder="Argument Parser">{{data.args}}</textarea>\n        </nb-form-field>\n\n      </div>\n    </nb-card-body>\n    <nb-card-footer fxLayoutAlign="end center" fxLayoutGap="1rem">\n      <button size="small" ghost nbButton (click)="ref.close()">Cancel</button>\n      <button size="small" status="success" nbButton\n        (click)="ref.close( { cmd:  cmd?.value ,  args: args?.value  }  )">Save</button>\n    </nb-card-footer>\n  </nb-card>\n</ng-template>\n\n\n<ng-container [formGroup]="form" *ngIf=" LOADING == false ; else loading">\n  \x3c!--  --\x3e\n\n  <nb-layout-header fixed>\n    <div fxFlex fxLayout="row">\n\n      <div fxLayoutAlign="start center" fxLayout="row">\n\n        <button (click)="goTo( [ \'deployments\' ] )" shape="round" ghost status="basic" class="action" size="large"\n          nbButton>\n          <nb-icon icon="arrow-back-outline">\n\n          </nb-icon>\n        </button>\n\n        <span class="subtitle text-hint lineV">\n          Job Executor\n\n        </span>\n\n      </div>\n\n\n    </div>\n\n    <div fxLayoutGap="1rem" style="margin-right: 1rem;">\n\n      <button *ngIf="isTest" (click)="save()" outline size="medium" shape="round" status="info" nbButton>\n        <span>\n          Save\n        </span>\n\n      </button>\n\n      <button (click)="run()" outline size="medium" shape="round" status="danger" nbButton>\n        <nb-icon icon="play-circle"></nb-icon>\n        <span>\n          Run\n        </span>\n      </button>\n    </div>\n  </nb-layout-header>\n\n\n\n\n\n  \x3c!--  --\x3e\n  <nb-card fxFill>\n\n\n    <nb-card-header fxLayoutAlign="space-between center" fxLayout="row">\n      <div fxLayoutAlign="start center" fxLayout="row">\n\n\n        <button (click)="close.next(true)" shape="round" ghost status="basic" class="action" size="large" nbButton>\n          <nb-icon icon="info">\n\n          </nb-icon>\n        </button>\n\n        <span class="subtitle text-hint lineV">\n          Job Configuration\n\n        </span>\n\n      </div>\n\n\n\n\n      <div fxLayout="column">\n\n        <div fxLayout="row" fxLayoutAlign="end" fxFlex>\n\n\n          <button (click)="goTo( [ \'images\' , \'config\'  , id?.split(\':\').pop() ] )" ghost nbButton status="danger">\n            Edit\n          </button>\n\n          <nb-select *ngIf="false" scrollStrategy="reposition" formControlName="assets" multiple size="small"\n            placeholder="Supported Assets">\n\n            <nb-option style="text-transform: capitalize;" *ngFor="let assetType of assetTypes$ | async"\n              [value]="assetType?.identifier">{{assetType?.name}}</nb-option>\n\n          </nb-select>\n\n\n        </div>\n      </div>\n    </nb-card-header>\n\n    <nb-card-body>\n      <div fxLayout="column">\n\n\n\n\n        <div>\n          <p style="text-transform: capitalize;" class="subtitle-1 text-primary">\n\n            Helper Data\n\n\n\n          </p>\n        </div>\n\n        <ng-container *ngFor="let assetType of assetTypes$ | async">\n\n\n          <div *ngIf="form?.controls[\'assets\']?.value?.includes( assetType?.identifier )" fxLayout="column">\n\n\n\n            <div fxLayoutGap="1rem" fxLayoutAlign="start center" fxLayout="row">\n\n              <div fxLayoutAlign="center center">\n                <p style="text-transform: capitalize;" class="subtitle-2 text-hint">\n                  {{assetType?.name}}\n                </p>\n\n              </div>\n\n\n              <app-divider fxFlex></app-divider>\n\n\n              <div fxLayoutGap="0.5rem" fxLayout="row">\n\n\n\n\n\n                <div fxLayoutAlign="center center">\n\n                  <nb-toggle [checked]="true" #toggleBtn></nb-toggle>\n                </div>\n\n              </div>\n            </div>\n\n            <ng-container *ngIf="toggleBtn?.checked">\n\n              <div fxFlex fxLayoutAlign="end center ">\n                <nb-select [(ngModel)]="helper_data[assetType?.identifier]" [ngModelOptions]="{standalone: true}"\n                  (selectedChange)="onSelectionChanged($event)" size="small" placeholder="Supported Assets">\n\n                  <nb-option [value]="asset?._id" *ngFor="let asset of asset$[assetType?.identifier] | async">{{\n                    asset?.name\n                    ||\n                    asset?.value }}</nb-option>\n\n                </nb-select>\n              </div>\n\n              <app-divider></app-divider>\n\n\n              <div>\n                <p style="text-transform: capitalize;" class="subtitle-2 text-hint">\n                  Input Variables\n\n\n                </p>\n              </div>\n\n              <div>\n\n                <nb-tag-list>\n                  <nb-tag appearance="outline" *ngFor="let tag of  assetType?.config?.input_variables | keyvalue"\n                    [text]="tag?.key" status="basic"></nb-tag>\n                </nb-tag-list>\n\n\n              </div>\n\n              <app-divider></app-divider>\n\n\n              <div>\n                <p style="text-transform: capitalize;" class="subtitle-2 text-hint">\n                  Output Variables\n                </p>\n              </div>\n              <div>\n\n                <nb-tag-list>\n                  <nb-tag appearance="outline" *ngFor="let tag of assetType?.config?.output_variables | keyvalue"\n                    [text]="tag?.key" status="info"></nb-tag>\n                </nb-tag-list>\n              </div>\n\n              <app-divider></app-divider>\n\n            </ng-container>\n\n\n          </div>\n\n\n\n\n        </ng-container>\n\n        \x3c!-- Entrypoint --\x3e\n        <div fxLayout="column">\n\n          <div>\n            <p class="subtitle-2 text-hint">\n              Entrypoint\n            </p>\n          </div>\n\n\n          <ng-container formArrayName="entrypoint">\n\n            <ng-container *ngFor="let entrypoint of this.form.get(\'entrypoint\').controls ; let i=index ">\n\n              <div fxLayout="row" fxLayoutGap="1rem">\n                <nb-form-field fxFlex fieldSize="small">\n                  <input fullWidth [formControlName]="i" nbInput placeholder="/bin/watchdog">\n                </nb-form-field>\n              </div>\n\n            </ng-container>\n          </ng-container>\n\n        </div>\n\n        <app-divider></app-divider>\n\n        \x3c!-- Command --\x3e\n        <div fxLayout="column">\n\n          <div>\n            <p class="subtitle-2 text-hint">\n              Command\n            </p>\n          </div>\n\n          <div fxFlex>\n\n\n            <ng-container formArrayName="cmd">\n\n              <ng-container *ngFor="let _cmd of this.form.get(\'cmd\').controls ; let i=index ">\n\n\n                <div [style.marginBottom]="\'0.5rem\'" fxLayout="row" fxLayoutGap="1rem">\n\n                  <div fxLayout="row" fxLayoutGap="1rem">\n                    <nb-form-field fxFlex fieldSize="small">\n                      <input fullWidth [formControlName]="i" nbInput placeholder="/usr/bin/mobsf">\n                    </nb-form-field>\n                  </div>\n\n\n\n\n                </div>\n\n\n              </ng-container>\n\n\n            </ng-container>\n\n          </div>\n\n        </div>\n\n        <app-divider></app-divider>\n\n\n        \x3c!-- Arguments --\x3e\n        <div fxLayout="column">\n\n          <div fxLayout="row">\n            <p fxFlex class="subtitle-2 text-hint">\n              Arguments\n            </p>\n\n            <button (click)="addArg()" ghost nbButton status="danger">\n              Add\n            </button>\n\n\n            <button (click)="open(rawArgsEditorDialog)" ghost nbButton status="danger">\n              Raw Editor\n            </button>\n\n          </div>\n\n\n          <div fxFlex>\n\n            <ng-container formArrayName="args">\n\n              <ng-container *ngFor="let arg of this.form.get(\'args\').controls ; let i=index ">\n\n\n                <div [style.marginBottom]="\'0.5rem\'" fxLayout="row" fxLayoutGap="1rem">\n                  <nb-form-field fxFlex fieldSize="small">\n\n\n                    <input fullWidth [formControlName]="i" nbInput placeholder="/usr/bin/mobsf">\n\n\n                  </nb-form-field>\n\n\n                  <button ghost nbSuffix nbButton (click)="deleteArg(i)">\n                    <nb-icon icon="trash-outline">\n                    </nb-icon>\n                  </button>\n\n                </div>\n\n\n              </ng-container>\n\n\n            </ng-container>\n          </div>\n\n          <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'args\').controls.length" fxFlex>\n            <p class="subtitle-2 text-hint">\n              No Arguments Defined\n            </p>\n          </div>\n\n        </div>\n\n        <app-divider></app-divider>\n\n\n        \x3c!-- Variables --\x3e\n        <div fxLayout="column">\n\n          <div fxLayout="row">\n            <p fxFlex class="subtitle-2 text-hint">\n              Variables\n            </p>\n\n\n\n            <button (click)="addVar()" ghost nbButton status="danger">\n              Add\n            </button>\n\n\n          </div>\n\n\n          <ng-container formArrayName="variables">\n            <nb-autocomplete #autoCompleteVariables (selectedChange)="onSelectionChange($event)">\n\n              <nb-option *ngFor="let option of reservedConstants$ | async" [value]="option">\n                {{ option }}\n              </nb-option>\n\n            </nb-autocomplete>\n\n\n\n            <ng-container *ngFor="let variable of this.form.get(\'variables\').controls ; let i=index ">\n\n              <div [style.marginBottom]="\'0.5rem\'" [formGroupName]="i" fxLayout="row" fxLayoutGap="1rem">\n\n\n                <nb-form-field fxFlex fieldSize="small">\n                  <span nbPrefix>$</span>\n\n                  <input scrollStrategy="reposition" [nbAutocomplete]="autoCompleteVariables" fullWidth\n                    formControlName="key" nbInput placeholder="/usr/bin/mobsf">\n                </nb-form-field>\n\n\n\n\n\n\n                <nb-form-field fxFlex fieldSize="small">\n                  <input scrollStrategy="reposition" [nbAutocomplete]="autoCompleteVariables" fullWidth\n                    formControlName="value" nbInput placeholder="/usr/bin/mobsf">\n                </nb-form-field>\n\n\n                <button ghost nbButton (click)="deleteVariables(i)">\n                  <nb-icon icon="trash-outline">\n                  </nb-icon>\n                </button>\n\n\n\n\n              </div>\n\n\n            </ng-container>\n\n\n          </ng-container>\n\n\n          <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'variables\').controls.length" fxFlex>\n            <p class="subtitle-2 text-hint">\n              No Variables Defined\n            </p>\n          </div>\n\n        </div>\n\n        <app-divider></app-divider>\n\n\n        \x3c!-- Substitute Variables --\x3e\n        <div fxLayout="column">\n\n\n\n\n          <div fxLayout="row">\n            <p fxFlex class="subtitle-2 text-hint">\n              Substitute Variables\n\n            </p>\n\n\n\n\n            <nb-toggle formControlName="substitute_var"></nb-toggle>\n\n\n\n          </div>\n\n          \x3c!--  --\x3e\n\n\n        </div>\n\n\n        <app-divider></app-divider>\n\n        \x3c!-- Configs / File Uploads --\x3e\n\n\n        <div fxLayout="column">\n\n          <div fxLayout="row">\n            <p fxFlex class="subtitle-2 text-hint">\n              Configuration Files\n            </p>\n\n            <button (click)="addConfigFile()" ghost nbButton status="danger">\n              Add\n            </button>\n\n \n          </div>\n\n\n          <div fxFlex>\n\n            <ng-container formArrayName="config_files">\n\n              <ng-container *ngFor="let arg of this.form.get(\'config_files\').controls ; let i=index ">\n\n\n                <div [style.marginBottom]="\'0.5rem\'" fxLayout="row" fxLayoutGap="1rem">\n                  <nb-form-field fxFlex fieldSize="small">\n\n\n                    <input fullWidth [formControlName]="i" nbInput placeholder="/usr/bin/mobsf">\n\n\n                  </nb-form-field>\n\n\n                  <button status="info" ghost nbSuffix nbButton (click)="deleteArg(i)">\n                    <nb-icon icon="upload-outline">\n                    </nb-icon>\n                  </button>\n\n                  <button ghost nbSuffix nbButton (click)="deleteArg(i)">\n                    <nb-icon icon="trash-outline">\n                    </nb-icon>\n                  </button>\n\n                </div>\n\n\n              </ng-container>\n\n\n            </ng-container>\n          </div>\n\n          <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'config_files\').controls.length" fxFlex>\n            <p class="subtitle-2 text-hint">\n              No configuration files\n            </p>\n          </div>\n\n        </div>\n\n\n        \x3c!--  --\x3e\n\n\n\n        \x3c!-- success_endpoint --\x3e\n        <div fxLayout="column">\n\n          <div>\n            <p class="subtitle-2 text-hint">\n              Success Endpoint\n            </p>\n          </div>\n\n          <div fxLayout="row" fxLayoutGap="1rem">\n            <nb-form-field fxFlex fieldSize="small">\n              <input fullWidth formControlName="success_endpoint" nbInput\n                placeholder="http://success_endpoint.com/usr/bin/mobsf">\n            </nb-form-field>\n          </div>\n        </div>\n\n        <app-divider></app-divider>\n\n\n        \x3c!-- failure_endpoint --\x3e\n        <div fxLayout="column">\n\n          <div>\n            <p class="subtitle-2 text-hint">\n              Failure Endpoint\n            </p>\n          </div>\n\n          <div fxLayout="row" fxLayoutGap="1rem">\n            <nb-form-field fxFlex fieldSize="small">\n              <input fullWidth formControlName="failure_endpoint" nbInput\n                placeholder="http://failure_endpoint.com/usr/bin/mobsf">\n            </nb-form-field>\n          </div>\n        </div>\n\n        <app-divider></app-divider>\n\n\n        \x3c!-- Process Env. Variables --\x3e\n        <div fxLayout="column" formGroupName="config">\n\n          <div fxLayout="row">\n            <p fxFlex class="subtitle-2 text-hint">\n              Environment Variables\n            </p>\n\n\n\n            <button (click)="addConfProcess()" ghost nbButton status="danger">\n              Add\n            </button>\n\n\n          </div>\n\n\n          <ng-container formArrayName="process">\n\n            <ng-container *ngFor="let variable of this.form.get(\'config\').get(\'process\').controls ; let i=index ">\n\n              <div [style.marginBottom]="\'0.5rem\'" [formGroupName]="i" fxLayout="row" fxLayoutGap="1rem">\n\n\n                <nb-form-field fxFlex fieldSize="small">\n                  <span nbPrefix>$</span>\n\n                  <input scrollStrategy="reposition" [nbAutocomplete]="autoCompleteVariables" fullWidth\n                    formControlName="key" nbInput placeholder="/usr/bin/mobsf">\n                </nb-form-field>\n\n\n\n\n\n\n                <nb-form-field fxFlex fieldSize="small">\n                  <input scrollStrategy="reposition" fullWidth formControlName="value" nbInput\n                    placeholder="/usr/bin/mobsf">\n                </nb-form-field>\n\n\n                <button ghost nbButton (click)="deleteConfProcess(i)">\n                  <nb-icon icon="trash-outline">\n                  </nb-icon>\n                </button>\n\n\n\n\n              </div>\n\n\n            </ng-container>\n\n\n          </ng-container>\n\n\n          <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'config\').get(\'process\').controls .length"\n            fxFlex>\n            <p class="subtitle-2 text-hint">\n              No Environment Variables Defined\n            </p>\n          </div>\n\n        </div>\n\n        <app-divider></app-divider>\n\n\n        \x3c!-- Reserved Env. Variables --\x3e\n        <div fxLayout="column" formGroupName="config">\n\n          <div fxLayout="row">\n            <p fxFlex class="subtitle-2 text-hint">\n              Reserved Environment Variables\n            </p>\n\n\n\n            <button (click)="addReservedProcess()" ghost nbButton status="danger">\n              Add\n            </button>\n\n\n          </div>\n\n\n          <ng-container formArrayName="reserved">\n\n            <ng-container *ngFor="let variable of this.form.get(\'config\').get(\'reserved\').controls ; let i=index ">\n\n              <div [style.marginBottom]="\'0.5rem\'" [formGroupName]="i" fxLayout="row" fxLayoutGap="1rem">\n\n\n                <nb-form-field fxFlex fieldSize="small">\n                  <span nbPrefix>$</span>\n\n                  <input scrollStrategy="reposition" [nbAutocomplete]="autoCompleteVariables" fullWidth\n                    formControlName="key" nbInput placeholder="/usr/bin/mobsf">\n                </nb-form-field>\n\n\n\n\n\n\n                <nb-form-field fxFlex fieldSize="small">\n                  <input scrollStrategy="reposition" fullWidth formControlName="value" nbInput\n                    placeholder="/usr/bin/mobsf">\n                </nb-form-field>\n\n\n                <button ghost nbButton (click)="deleteConfReserved(i)">\n                  <nb-icon icon="trash-outline">\n                  </nb-icon>\n                </button>\n\n\n\n\n              </div>\n\n\n            </ng-container>\n\n\n          </ng-container>\n\n          <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'config\').get(\'reserved\').controls .length"\n            fxFlex>\n            <p class="subtitle-2 text-hint">\n              No Reserved Variables Defined\n            </p>\n          </div>\n        </div>\n\n        <app-divider></app-divider>\n\n\n        \x3c!-- Systen Env. Variables --\x3e\n        <div fxLayout="column" formGroupName="config">\n\n          <div fxLayout="row">\n            <p fxFlex class="subtitle-2 text-hint">\n              Systen Environment Variables\n            </p>\n\n\n\n            <button (click)="addSystemProcess()" ghost nbButton status="danger">\n              Add\n            </button>\n\n\n          </div>\n\n\n          <ng-container formArrayName="system">\n\n            <ng-container *ngFor="let variable of this.form.get(\'config\').get(\'system\').controls ; let i=index ">\n\n              <div [style.marginBottom]="\'0.5rem\'" [formGroupName]="i" fxLayout="row" fxLayoutGap="1rem">\n\n\n                <nb-form-field fxFlex fieldSize="small">\n                  <span nbPrefix>$</span>\n\n                  <input [nbAutocomplete]="autoCompleteVariables" fullWidth formControlName="key" nbInput\n                    placeholder="/usr/bin/mobsf">\n                </nb-form-field>\n\n\n\n\n\n\n                <nb-form-field fxFlex fieldSize="small">\n                  <input fullWidth formControlName="value" nbInput placeholder="/usr/bin/mobsf">\n                </nb-form-field>\n\n\n                <button ghost nbButton (click)="deleteConfSystem(i)">\n                  <nb-icon icon="trash-outline">\n                  </nb-icon>\n                </button>\n\n\n\n\n              </div>\n\n\n            </ng-container>\n\n\n          </ng-container>\n\n          <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'config\').get(\'system\').controls .length"\n            fxFlex>\n            <p class="subtitle-2 text-hint">\n              No System Variables Defined\n            </p>\n          </div>\n        </div>\n\n        <app-divider></app-divider>\n\n\n      </div>\n    </nb-card-body>\n\n\n\n  </nb-card>\n\n\n\n</ng-container>\n\n<ng-template #loading>\n  <div fxLayoutAlign="center center">\n    <ngx-progress-spinner></ngx-progress-spinner>\n  </div>\n\n</ng-template>\n\n<ng-template #logsTemplate let-close="close" let-context="context">\n\n  <app-log-stream [close]="close" [deep_link]="true" [log_id]="context?.id"></app-log-stream>\n\n\n</ng-template>',styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\nnb-layout-column {\n  background-color: var(--color-basic-100) !important;\n}\nnb-card {\n  margin: 0;\n}\nnb-card .container {\n  margin-top: 1rem;\n}\nnb-card textarea {\n  resize: none;\n}\n.label-text {\n  border-left: 2px var(--text-hint-color) solid !important;\n  margin-bottom: 1rem;\n  padding-left: 4px;\n}\n.subtitle {\n  margin: 0;\n  padding-left: 4px;\n}\nnb-card-header {\n  padding: 0.4rem;\n  box-shadow: 2px 2px 3px rgba(0, 0, 0, 0.16), 2px 2px 3px rgba(0, 0, 0, 0.23);\n}\nnb-card-footer {\n  padding: 0;\n}\nnb-card {\n  border: 0;\n}\n.buildBtn {\n  border-radius: 0;\n}"]})],H);var Y,Z=i("G1Gu"),K=i("3E0/"),X=i("/d8p"),Q=i("1G5W");!function(e){e.IMAGE_BUILDER="image_builder",e.JOB="job"}(Y||(Y={}));var ee=function(){function e(n,t){s(this,e),this.toolApiService=n,this.cdr=t,this.logSource=Y.IMAGE_BUILDER,this.LOG_STREAM_STATUS$=a,this.testLogs="",this.deep_link=!1,this.log_id="npop3",this.topic=void 0,this.topics_=[],this.build_list=[],this.tailing=!1,this.streaming=!0,this.pollJobStatusSubscription$=W.a.EMPTY,this.scrollSubscruption=W.a.EMPTY}return r(e,[{key:"ngOnDestroy",value:function(){console.log("unsubscribe"),this.topic.subscription.unsubscribe(),this.topic.pauseStreamer$.next(a.STOP),this.pollJobStatusSubscription$.unsubscribe()}},{key:"toggleTail",value:function(e){1==e?this.resumeKeepAtBottom():this.pauseKeepAtBottom()}},{key:"toggleStreamingLogs",value:function(e,n){e?this.pause(n):this.resume(e)}},{key:"getSource",value:function(e){switch(console.log("logsource",this.logSource),this.logSource){case Y.IMAGE_BUILDER:return this.toolApiService.getBuildExecutorStatus(e);case Y.JOB:return this.toolApiService.getJobStatus(e);default:return this.toolApiService.getBuildExecutorStatus(e)}}},{key:"pollJobStatus",value:function(e){var n=this,t=new w.a;this.pollJobStatusSubscription$.unsubscribe(),this.pollJobStatusSubscription$=this.getSource(e).pipe(Object(m.a)(function(e){var o;0==e.poll_again&&t.next(""),n.STATUS=null===(o=e.exec_status)||void 0===o?void 0:o.toLowerCase()}),Object(K.a)(1e3),Object(X.a)(),Object(Q.a)(t)).subscribe(function(e){})}},{key:"ngOnInit",value:function(){1==this.deep_link?this.deepLinkLoadLog():this.getExecutors(this.log_id)}},{key:"deepLinkLoadLog",value:function(){console.log("deep_link"),this.topic={log_id:this.log_id,exec_status:"SUCCESS",title:"val['_id']",desc:"Dummy Description",loaded:!1,initiated:!1,collapsed:!0,loading:new w.a,content:[],content$:new w.a,pauseStreamer$:new j.a(a.RESUME),subscription:W.a.EMPTY},this.streamLogs(0,!0),this.pollJobStatus(this.topic.log_id)}},{key:"resumeKeepAtBottom",value:function(){var e=this;this.scrollSubscruption.unsubscribe(),this.scrollSubscruption=Object(f.a)(300).subscribe(function(n){e.scrollbarRef.scrollTo({bottom:0,duration:150})})}},{key:"pauseKeepAtBottom",value:function(){this.scrollSubscruption.unsubscribe(),this.scrollbarRef.scrollTo({bottom:0,duration:0})}},{key:"streamLogs",value:function(e,n){var t=this;this.topic&&this.topic.loaded||(console.log(this.topic),this.topic.loading.next(!0),this.topic.subscription=this.toolApiService.getLogs(this.topic.log_id,200,this.topic.pauseStreamer$,C.d).pipe(Object(m.a)(function(e){t.topic.initiated=!0})).subscribe(function(e){t.topic.loaded=!0,t.topic.loading.next(!1),null!=e&&null!=e&&0!=e.length&&(t.topic.content.push(e),console.log("log loaded"),t.cdr.markForCheck())},function(e){console.log("error",e)},function(){console.log("completed"),t.topic.pauseStreamer$.next(a.STOP),t.cdr.markForCheck()}))}},{key:"getStatus",value:function(){}},{key:"collapsedChange",value:function(e,n){var t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];n||this.streamLogs(e,t)}},{key:"onSelectionChange",value:function(e){this.topic&&(console.log("onSelectioChange",e),this.topic.subscription.unsubscribe(),this.topic.pauseStreamer$.next(a.STOP),this.topic.content$.complete()),this.topic={log_id:this.build_list[e].log_id,exec_status:this.build_list[e].exec_status,title:"val['_id']",desc:"Dummy Description",loaded:!1,initiated:!1,collapsed:!0,loading:new w.a,content:[],content$:new w.a,pauseStreamer$:new j.a(a.RESUME),subscription:W.a.EMPTY},this.streamLogs(e,!1),this.pollJobStatus(this.topic.log_id),console.log("this.topic",this.topic)}},{key:"getExecutors",value:function(e){var n=this;this.toolApiService.getBuildExecoturs(e).subscribe(function(e){e.forEach(function(e,t){n.build_list.push({log_id:e._id,title:e._id,exec_status:e.exec_status,desc:"Dummy Description",loaded:!1,initiated:!1,collapsed:!0}),n.cdr.markForCheck(),0==t&&n.onSelectionChange(t)})})}},{key:"pause",value:function(e){this.topic.pauseStreamer$.next(a.PAUSE),this.cdr.markForCheck()}},{key:"resume",value:function(e){this.topic.pauseStreamer$.next(a.RESUME),this.cdr.markForCheck()}}]),e}();ee.ctorParameters=function(){return[{type:I},{type:c.k}]},ee.propDecorators={logSource:[{type:c.I,args:["logsource"]}],close:[{type:c.I,args:["close"]}],deep_link:[{type:c.I,args:["deep_link"]}],log_id:[{type:c.I,args:["log_id"]}],scrollbarRef:[{type:c.qb,args:[Z.a,{static:!1}]}]},ee=Object(l.a)([Object(c.n)({selector:"app-log-stream",template:'<nb-card fxFill>\n\n\n  <nb-card-header fxLayoutAlign="space-between center">\n\n    <div fxLayout="row" fxLayoutAlign="start center">\n      <button (click)="close.emit(true)" ghost status="basic" class="action" size="medium" nbButton>\n        <nb-icon class="text-alternate" icon="arrow-back-outline">\n        </nb-icon>\n      </button>\n\n      <div fxFlex>\n\n\n        <div fxLayout="column">\n          <div fxFlex class="subtitle text-alternate">\n            Logs\n          </div>\n\n        </div>\n      </div>\n\n\n\n    </div>\n\n    <div class="overflowFix">\n\n\n      <nb-select [style.marginRight]="\'1rem\'" (selectedChange)="onSelectionChange($event)" [selected]="0"\n        *ngIf="build_list.length > 0" placeholder="Success" size="tiny" status="danger" filled>\n        <nb-option *ngFor="let topic of build_list ; index as index" [value]="index">{{topic?.log_id}}\n        </nb-option>\n\n      </nb-select>\n    </div>\n\n  </nb-card-header>\n\n  <nb-card-body fxLayoutAlign="center center" fxLayout="column" class="content log-container">\n\n\n\n\n\n\n\n\n\n\n    <ng-template #logTemplate let-topic="topic">\n\n      <ng-container>\n\n        <div fxFill fxLayout="column" class="log-container">\n\n\n          <div fxFlexAlign="center" *ngIf=" topic?.content == undefined ||  topic?.content?.length < 1"\n            fxLayoutAlign="center center">\n            <ngx-progress-spinner></ngx-progress-spinner>\n          </div>\n\n\n\n\n\n\n          <ng-scrollbar [style.pointerEvents]=" tailing ? \'none\' : \'all\' " track="vertical" [scrollAuditTime]="20">\n\n            <div fxFlex>\n\n\n              <div class="code">\n\n                <div *ngFor="let content of topic?.content">\n                  <code fxFlex>\n                    <pre [innerText]="content">   </pre>\n                  </code>\n                </div>\n              </div>\n\n\n\n\n            </div>\n\n\n          </ng-scrollbar>\n\n\n\n\n\n        </div>\n\n\n      </ng-container>\n\n\n    </ng-template>\n\n\n\n    <ng-container *ngIf="topic">\n      <ng-container *ngTemplateOutlet="logTemplate; context: { \'topic\': topic } ">\n      </ng-container>\n    </ng-container>\n\n\n\n\n\n\n  </nb-card-body>\n\n\n  <nb-card-footer fxLayoutAlign="space-between center" (click)="save()">\n\n\n    <div class="overlay-button">\n\n      <ng-template #actionBtns let-status="pauseStatus">\n\n        <div class="row" fxFlex fxLayoutAlign="center center" fxLayoutGap="1rem">\n\n\n          <nb-button-group size="small" shape="round" multiple>\n\n            <button hero status="danger" (click)="toggleStreamingLogs($event)" nbButtonToggle size="small">\n              <nb-icon icon="pause-circle">\n              </nb-icon>\n\n              {{ ( status == LOG_STREAM_STATUS$.PAUSE ) ? \'Resume\' : \'Pause\' }}\n\n            </button>\n\n\n\n            <button [(pressed)]="tailing" (pressedChange)="toggleTail($event)" nbButtonToggle size="small">\n              <nb-icon icon="arrowhead-down-outline"></nb-icon>\n              Follow\n            </button>\n          </nb-button-group>\n        </div>\n      </ng-template>\n\n      <ng-container *ngTemplateOutlet="actionBtns; context:{pauseStatus: topic?.pauseStreamer$ | async }">\n      </ng-container>\n    </div>\n\n    <div *ngIf="STATUS">\n      <button style="text-transform:capitalize !important" outline shape="round" status="info" nbButton size="tiny">\n        <nb-icon icon="pause-circle">\n        </nb-icon>\n        {{STATUS}}\n\n      </button>\n\n    </div>\n  </nb-card-footer>\n\n</nb-card>',changeDetection:c.j.OnPush,styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\nnb-card {\n  max-height: calc(100vh - 7rem);\n  margin: 0;\n}\nnb-card .container {\n  margin-top: 1rem;\n}\nnb-card textarea {\n  resize: none;\n}\nnb-card-header {\n  padding: 0.4rem;\n  background: var(--background-alternative-color-2);\n  box-shadow: 2px 2px 3px rgba(255, 255, 255, 0.16), 2px 2px 3px rgba(255, 255, 255, 0.23);\n  border: 0em;\n  color: #fff;\n}\nnb-card-footer {\n  padding: 0.3rem;\n  background: var(--background-alternative-color-2);\n  border: 0em;\n}\n.subtitle {\n  color: #a4b1cd !important;\n  font-weight: 600;\n  line-height: 1rem;\n  font-size: 1rem;\n}\nnb-card {\n  border: 0;\n}\nnb-card-body {\n  border: 0;\n  padding: 0rem;\n}\n.buildBtn {\n  border-radius: 0;\n}\n.log-container {\n  background: var(--background-alternative-color-1);\n  color: var(--text-alternate-color);\n}\n.log-container .ng-trigger-accordionItemBody {\n  margin-left: 1rem;\n  margin-right: 1rem;\n  margin-top: 0.5rem;\n  margin-bottom: 0.5rem;\n}\n.log-container pre {\n  margin: 0;\n}\n.overlay-button {\n  position: -webkit-sticky;\n  position: sticky;\n  bottom: 1rem;\n  right: 1rem;\n}\n:host ::ng-deep nb-accordion nb-accordion-item nb-accordion-item-header:hover {\n  background: var(--background-alternative-color-1);\n  color: var(--text-alternate-color);\n}\n:host ::ng-deep nb-accordion nb-accordion-item nb-accordion-item-header.accordion-item-header-expanded {\n  background: var(--background-alternative-color-2);\n  color: var(--text-alternate-color);\n}\n:host ::ng-deep nb-accordion nb-accordion-item nb-accordion-item-body.marginBody {\n  overflow: scroll;\n  background: var(--background-alternative-color-1);\n  color: var(--text-alternate-color);\n}\n:host ::ng-deep nb-accordion nb-accordion-item nb-accordion-item-body.marginBody .ng-trigger-accordionItemBody {\n  margin-left: 1rem;\n  margin-right: 1rem;\n  margin-top: 0.5rem;\n  margin-bottom: 0.5rem;\n}\n:host ::ng-deep nb-accordion nb-accordion-item nb-accordion-item-body.marginBody pre {\n  margin: 0;\n}\n.head {\n  height: 4rem;\n  background: var(--background-alternative-color-2);\n  box-shadow: 2px 2px 3px rgba(255, 255, 255, 0.16), 2px 2px 3px rgba(255, 255, 255, 0.23);\n  color: #fff;\n}\n.content {\n  height: calc(100% - 4rem);\n}\n.action {\n  margin-left: 5px;\n}\n.action:hover nb-icon {\n  color: var(--color-alternate-500);\n}\n.code {\n  padding: 1rem;\n}\n.overflowFix {\n  overflow: auto;\n}"]})],ee);var ne=function(){function e(n,t,o,i,r){s(this,e),this.toolApiService=n,this.sharedDataService=t,this.cdr=o,this.document=i,this.drawerMngr=r}return r(e,[{key:"ngOnInit",value:function(){var e=this;this.jobs=this.sharedDataService.ToolId.pipe(Object(y.a)(function(n){return e.toolApiService.getJobs(n)}),Object(F.b)(function(e){return e}))}},{key:"openDrawer",value:function(e,n){var t=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:B.a.Left,s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],i=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],r=arguments.length>6?arguments[6]:void 0;n||(n={}),n.logsource=Y.JOB,console.log("context",n),this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:o,template:e,context:n,closeOnOutsideClick:s,parentContainer:r,isRoot:i,zIndex:1e3,cssClass:"backdrop_color"}).onDestroy(function(){t.document.body.classList.remove("cdk-global-scrollblock")})}}]),e}();ne.ctorParameters=function(){return[{type:I},{type:M},{type:c.k},{type:Document,decorators:[{type:c.D,args:[d.d]}]},{type:O.a}]},ne=Object(l.a)([Object(c.n)({selector:"app-job-list",template:'<nb-accordion>\n  <nb-accordion-item *ngFor="let job of jobs | async ;  let i=index  ">\n\n    <nb-accordion-item-header fxLayoutAlign="space-between">\n\n      <span>\n\n        Job {{i + 1}}\n        {{ job?._id  }}\n\n      </span>\n\n      <span class="text-hint">\n        {{ \'@\' +  ( job?.exec_status || \'Unknown\' ) }}\n      </span>\n    </nb-accordion-item-header>\n    <nb-accordion-item-body>\n\n\n      <button [routerLink]="[ \'/jobs\' , \'job\' , job?._id ]" status="basic" filled size="small" nbButton>\n\n        <nb-icon icon="file-text-outline"></nb-icon>\n        Details\n      </button>\n\n      <button (click)="openDrawer(logsTemplate, context = {\n        \'id\': job?._id\n\n      }  )" status="basic" filled size="small" nbButton>\n\n        <nb-icon icon="file-text-outline"></nb-icon>\n        Logs\n      </button>\n\n    </nb-accordion-item-body>\n  </nb-accordion-item>\n</nb-accordion>\n\n\n<ng-template #logsTemplate let-close="close" let-context="context">\n\n\n  <app-log-stream [logsource]="context?.logsource" [close]="close" [deep_link]="true" [log_id]="context?.id">\n  </app-log-stream>\n\n\n</ng-template>\n',styles:[""]})],ne);var te,oe=function(){function e(n,t,o,i,r){s(this,e),this.toolApiService=n,this.drawerMngr=t,this.document=o,this.activatedRoute=i,this.sharedDataService=r,this.tabs=[],this.refrence_id="refrence_id"}return r(e,[{key:"ngOnInit",value:function(){var e=this;this.activatedRoute.params.pipe(Object(y.a)(function(e){return e.id})).pipe(Object(P.a)(function(e){return e})).pipe(Object(m.a)(function(n){e.refrence_id=n,e.sharedDataService.SetToolId(n),e.tabs=[{title:"Builds",route:[{outlets:{view:"builds"}}],responsive:!0},{title:"Images",route:[{outlets:{view:"images"}}],responsive:!0},{title:"Test",route:[{outlets:{view:"test-deployments"}}],responsive:!0},{title:"Deployments",route:[{outlets:{view:"deployments"}}],responsive:!0},{title:"Jobs",route:[{outlets:{view:"jobs"}}],responsive:!0}]})).subscribe(function(n){e.builds$=e.toolApiService.getBuilds(n).pipe(Object(m.a)(function(n){n.length<1&&e.openDrawer(e.buildCreateTemplate)}))})}},{key:"openDrawer",value:function(e,n){var t=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:B.a.Left,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"50",i=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],r=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],a=arguments.length>6?arguments[6]:void 0;n||(n={}),console.log("context",n),this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:o,template:e,size:s,context:n,closeOnOutsideClick:i,parentContainer:a,isRoot:r,zIndex:1e3,cssClass:"backdrop_color"}).onDestroy(function(){t.document.body.classList.remove("cdk-global-scrollblock")})}},{key:"openLogs",value:function(e,n){var t=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:B.a.Left,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"50%",i=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],r=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],a=arguments.length>6?arguments[6]:void 0;this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:o,template:e,size:s,closeOnOutsideClick:i,parentContainer:a,isRoot:r,zIndex:1e3,cssClass:"backdrop_color",context:{id:n}}).onDestroy(function(){t.document.body.classList.remove("cdk-global-scrollblock")})}}]),e}();oe.ctorParameters=function(){return[{type:I},{type:O.a},{type:Document,decorators:[{type:c.D,args:[d.d]}]},{type:h.a},{type:M}]},oe.propDecorators={buildCreateTemplate:[{type:c.qb,args:["buildCreateTemplate",{static:!1}]}],logTemplate:[{type:c.qb,args:["logsTemplate",{static:!1}]}]},oe=Object(l.a)([Object(c.n)({selector:"app-tool-explore",template:'<nb-layout-header fixed>\n  <div fxLayout="row">\n\n    <button shape="round" [routerLink]="[\'/tools\' ]" ghost status="basic" class="action" size="large" nbButton>\n      <nb-icon icon="arrow-back-outline">\n      </nb-icon>\n    </button>\n    <nb-route-tabset fxFlex [tabs]="tabs"></nb-route-tabset>\n\n\n\n  </div>\n\n  <div fxFlex fxLayoutAlign="end center ">\n\n    <input type="hidden" [routerLink]=" [{ outlets: { view: \'builds\' } }] " routerLinkActive\n      #buildRoute="routerLinkActive">\n\n\n    <button [routerLink]=" [{ outlets: { view: \'build_create\' } }] " *ngIf="buildRoute.isActive"\n      style="margin-right: 1rem;" shape="round" outline status="basic" class="action" size="medium" nbButton>\n      <nb-icon icon="plus-outline">\n      </nb-icon>\n      Create\n    </button>\n  </div>\n\n\n</nb-layout-header>\n\n<nb-layout-column>\n  <router-outlet name="view">\n\n  </router-outlet>\n</nb-layout-column>\n\n\n\n\n<ng-container *ngIf="false">\n\n  <nb-card fxFill>\n\n    <nb-card-header>\n\n      <div fxLayout="row">\n\n        <button shape="round" [routerLink]="[\'/tools\' ]" ghost status="basic" class="action" size="large" nbButton>\n          <nb-icon icon="arrow-back-outline">\n          </nb-icon>\n        </button>\n        <nb-route-tabset fxFlex [tabs]="tabs"></nb-route-tabset>\n\n\n      </div>\n\n\n    </nb-card-header>\n\n\n    <nb-card-body cdkScrollable>\n\n\n      <router-outlet name="view">\n\n      </router-outlet>\n    </nb-card-body>\n\n  </nb-card>\n\n</ng-container>',styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\n.head {\n  height: 4rem;\n  background: var(--background-alternative-color-2);\n  box-shadow: 2px 2px 3px rgba(255, 255, 255, 0.16), 2px 2px 3px rgba(255, 255, 255, 0.23);\n  color: #fff;\n}\n.content {\n  height: calc(100% - 4rem);\n  overflow: auto;\n}\n.action {\n  margin-left: 5px;\n}\n.action:hover nb-icon {\n  color: var(--color-alternate-500);\n}\nnb-tab {\n  padding: 0px;\n}\nnb-card {\n  max-height: calc(100vh - 7rem);\n  margin: 0;\n}\nnb-card .container {\n  margin-top: 1rem;\n}\nnb-card textarea {\n  resize: none;\n}\nnb-card nb-card-header {\n  padding: 0.4rem;\n}"]})],oe),function(e){e.HOST="host",e.DOMAIN="domain",e.ANDROID="android",e.IOS="ios",e.WEB="web",e.REPOSITORY="repository",e.DOCKER="docker"}(te||(te={}));var se="host",ie="domain",re=function(){function e(){s(this,e)}return r(e,[{key:"getToolMenu",get:function(){return[{name:"Tools",icon:"eva-arrow-left",type:te.HOST,link:["/tool","host","import"],id:se,path:["/tool/host"],children:[{name:"Create Tool",icon:"external-link-outline",link:["/tool","host","import"],id:se},{name:"Configure",icon:"external-link-outline",link:["/tool","host","configure"],id:"host_configure"}]},{name:"Data Sources",type:te.DOMAIN,link:["/tool","domain","add"],path:["/tool/domain"],id:ie,children:[{name:"Create",icon:"plus-circle-outline",link:["/tool","domain","add"],id:ie},{name:"Manage",icon:"external-link-outline",link:["/tool","domain","configure"],id:"domain_configure"}]},{name:"Plugin Store",type:te.WEB,link:["/tool","web","add"],id:"web",path:["/tool/web"],children:[{name:"Create",icon:"plus-circle-outline",link:["/tool","web","add"],id:"web"},{name:"Import",icon:"external-link-outline",link:["/tool","web","import"],id:"web_create"},{name:"Configure",icon:"external-link-outline",link:["/tool","web","configure"],id:"web_configure"}]}]}}]),e}();re.ctorParameters=function(){return[]},re=Object(l.a)([Object(c.F)({providedIn:"root"})],re);var ae=function(){function e(n,t,o,i,r){s(this,e),this.toolStoreService=n,this.dialogService=t,this.toolApiService=o,this.drawerMngr=i,this.document=r,this.tabs=[{title:"Logs",route:[{}]},{title:"Result",route:[{}]},{title:"Deployments",route:[]}],this.testLogs="",this.readOnly=!1,this.mode="markdown",this.options={mode:this.mode},this.toolMenu=this.toolStoreService.getToolMenu,this.tools$=this.toolApiService.getTools()}return r(e,[{key:"ngOnInit",value:function(){}},{key:"open",value:function(e){this.dialogService.open(e,{dialogClass:"test",closeOnBackdropClick:!1,context:"this is some additional data passed to dialog"})}},{key:"openDrawer",value:function(e,n){var t=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:B.a.Left,s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],i=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],r=arguments.length>6?arguments[6]:void 0;n||(n={}),console.log("context",n),this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:o,template:e,context:n,closeOnOutsideClick:s,parentContainer:r,isRoot:i,zIndex:1e3,cssClass:"backdrop_color"}).onDestroy(function(){t.document.body.classList.remove("cdk-global-scrollblock")})}}]),e}();ae.ctorParameters=function(){return[{type:re},{type:p.j},{type:I},{type:O.a},{type:Document,decorators:[{type:c.D,args:[d.d]}]}]},ae=Object(l.a)([Object(c.n)({selector:"app-tool-home",template:'<nb-layout withScroll="true" center>\n\n\n  <nb-layout-header fixed>\n    <div fxFlex fxLayoutAlign="space-between center">\n      <div class="imageContainer" fxLayoutAlign="center center">\n        <img src="/assets/logo.png">\n      </div>\n\n\n      <div>\n\n\n\n\n\n      </div>\n\n\n    </div>\n\n\n\n  </nb-layout-header>\n\n\n\n  <nb-sidebar *ngIf="false" right fxLayout="column">\n\n\n\n    <nb-list>\n\n      <nb-list-item class="create" @init fxLayoutAlign="center">\n\n\n        <div fxFlex fxLayout="row">\n\n          <button (click)="openDrawer(dialog)" fullWidth class="newBtn" shape="round" nbButton>\n\n            <div class="icon" icon="plus"></div>\n\n            <span>\n              Create Tool\n\n            </span>\n          </button>\n\n        </div>\n      </nb-list-item>\n\n\n      <nb-list-item @init *ngFor="let toolMenuItem of toolMenu; index as index">\n        <app-navbar-list-item [activestate]="activeState" [item]="toolMenuItem" [routerlink]="toolMenuItem.type"\n          fxLayout="column" [title]="toolMenuItem.name" fxFlex>\n\n        </app-navbar-list-item>\n      </nb-list-item>\n\n\n    </nb-list>\n\n\n\n  </nb-sidebar>\n\n\n\n\n\n\n  <nb-layout-column>\n    <router-outlet>\n    </router-outlet>\n    \x3c!-- <app-tool-screen></app-tool-screen> --\x3e\n\n  </nb-layout-column>\n\n  \x3c!-- <nb-layout-column>\n\n    <app-tool-screen></app-tool-screen>\n\n  </nb-layout-column> --\x3e\n\n\n \n</nb-layout>\n\n\n\n\n<ng-template #dialog let-close="close" let-data let-ref="dialogRef">\n  <app-tool-create [close]="close"></app-tool-create>\n</ng-template>\n',animations:e(D.a),styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\n.subtitle {\n  color: #a4b1cd !important;\n  font-weight: 600;\n  line-height: 1rem;\n  font-size: 1rem;\n}\n.avatar {\n  width: 2rem;\n  height: 2rem;\n}\nimg {\n  height: 3rem;\n}\n:host ::ng-deep nb-sidebar {\n  margin-right: 0 !important;\n  margin-left: 0 !important;\n}\n:host ::ng-deep nb-sidebar nb-list-item {\n  padding: 0px !important;\n  border: 0 !important;\n}\n:host ::ng-deep nb-sidebar .item {\n  border: 0;\n}\n:host ::ng-deep nb-sidebar .scrollable {\n  padding: 0px !important;\n}\n:host ::ng-deep nb-sidebar nb-tab {\n  padding: 1.25rem;\n}\nnb-list-item {\n  margin-left: 3px !important;\n  margin-right: 3px !important;\n  margin-top: 0px !important;\n  padding: 0.8rem !important;\n  font-weight: 350 !important;\n}\n:host ::ng-deep nb-layout-header nav {\n  padding: 0rem !important;\n}\n:host ::ng-deep .accordion-item-header-expanded {\n  background: #fff !important;\n  color: #292828 !important;\n  font-weight: 550 !important;\n}\n:host ::ng-deep nb-accordion-item-body .item-body {\n  padding: 0px !important;\n}\n.selected-route {\n  background: #fff !important;\n  color: #000 !important;\n  font-weight: 600 !important;\n}\nnb-sidebar-footer {\n  margin: 0.4rem !important;\n}\nnb-sidebar-header {\n  background: #171a21 !important;\n}\n.colored {\n  color: #3366ff;\n}\n.logo {\n  width: 190px;\n  height: auto;\n}\n.roundBtn {\n  width: 4rem;\n  height: 4rem;\n  line-height: 115px;\n  text-align: center;\n  border: 0px solid red;\n  background-image: url(\"/assets/logo_mini.png\");\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: contain;\n}\npre {\n  font: 500 12px/1.5 Monaco, Consolas, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", \"Courier New\", Courier, monospace;\n  white-space: pre;\n  padding: 0px 0px 0px 31px;\n}\nbutton.newBtn {\n  padding: 0.3rem !important;\n  padding-left: 1rem !important;\n  padding-right: 1rem !important;\n  text-transform: capitalize !important;\n  box-shadow: 0 1px 2px 0 rgba(60, 64, 67, 0.302), 0 1px 3px 1px rgba(60, 64, 67, 0.149) !important;\n  align-items: center !important;\n  background-color: #fff !important;\n  border: 1px solid transparent;\n  border-radius: 24px;\n  color: #3c4043 !important;\n}\nbutton.newBtn span {\n  margin-right: 1rem;\n  margin-top: 0.5rem;\n  margin-bottom: 0.5rem;\n  font-weight: 600;\n}\nbutton.newBtn .icon {\n  margin-right: 1rem;\n  background-image: url(\"data:image/svg+xml;charset=UTF-8,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2236%22 height=%2236%22 viewBox=%220 0 36 36%22%3E%3Cpath fill=%22%2334A853%22 d=%22M16 16v14h4V20z%22/%3E%3Cpath fill=%22%234285F4%22 d=%22M30 16H20l-4 4h14z%22/%3E%3Cpath fill=%22%23FBBC05%22 d=%22M6 16v4h10l4-4z%22/%3E%3Cpath fill=%22%23EA4335%22 d=%22M20 16V6h-4v14z%22/%3E%3Cpath fill=%22none%22 d=%22M0 0h36v36H0z%22/%3E%3C/svg%3E\");\n  width: 2rem !important;\n  height: 2rem !important;\n}\nbutton.newBtn:hover {\n  box-shadow: 0 3px 5px 0 rgba(60, 64, 67, 0.302), 0 3px 5px 1px rgba(60, 64, 67, 0.149) !important;\n  background-color: #fff !important;\n}\n.dialog nb-card {\n  width: 50rem !important;\n  box-shadow: 0 4px 8px 0 rgba(60, 64, 67, 0.302), 0 4px 8px 1px rgba(60, 64, 67, 0.149) !important;\n}\n.create {\n  margin: 1rem !important;\n}\nnb-layout-column {\n  margin-top: 1rem;\n}\n::ng-deep nb-layout-column {\n  padding: 0 !important;\n}"]})],ae);var le=i("JX91"),ce=function(){function e(n,t,o){var i=this;s(this,e),this.toolApiService=n,this.drawerMngr=t,this.document=o,this.trigger=new j.a(!0),this.tools$=this.trigger.pipe(Object(F.b)(function(e){return i.toolApiService.getTools()}))}return r(e,[{key:"ngOnInit",value:function(){var e=this;this.groups=[{name:"Group 1",children:["Option 11","Option 12","Option 13"]},{name:"Group 2",children:["Option 21","Option 22","Option 23"]},{name:"Group 3",children:["Option 31","Option 32","Option 33"]}],this.filteredGroups$=Object(v.a)(this.groups),this.inputFormControl=new u.d,this.filteredGroups$=this.inputFormControl.valueChanges.pipe(Object(le.a)(""),Object(y.a)(function(n){return e.filter(n)}))}},{key:"filterChildren",value:function(e,n){return e.filter(function(e){return e.toLowerCase().includes(n)})}},{key:"filter",value:function(e){var n=this,t=e.toLowerCase();return this.groups.map(function(e){return{name:e.name,children:n.filterChildren(e.children,t)}}).filter(function(e){return e.children.length})}},{key:"trackByFn",value:function(e,n){return n.name}},{key:"openDrawer",value:function(e,n){var t=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:B.a.Left,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"50%",i=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],r=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],a=arguments.length>6?arguments[6]:void 0;n||(n={}),this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:o,template:e,size:s,context:n,closeOnOutsideClick:i,parentContainer:a,isRoot:r,zIndex:1e3,cssClass:"backdrop_color"}).onDestroy(function(){t.document.body.classList.remove("cdk-global-scrollblock"),t.trigger.next(!0)})}}]),e}();ce.ctorParameters=function(){return[{type:I},{type:O.a},{type:Document,decorators:[{type:c.D,args:[d.d]}]}]},ce=Object(l.a)([Object(c.n)({selector:"app-tool-list",template:'<ng-container *ngIf=" tools$ | async as tools ; else loading">\n\n\n\n  <nb-card *ngIf="false">\n    <nb-card-header>\n\n\n      <div fxLayout="row" fxLayoutAlign="start center">\n\n        <button shape="round" [routerLink]="[\'/tools\' , \'\']" ghost status="basic" class="action" size="large" nbButton>\n          <nb-icon icon="arrow-back-outline">\n\n          </nb-icon>\n        </button>\n\n        <div class="h6 text-hint">\n          Tools\n\n        </div>\n\n\n\n\n\n      </div>\n    </nb-card-header>\n    <nb-list>\n      <nb-list-item fxLayout="row" fxLayoutAlign="space-between" *ngFor="let tool of tools">\n\n        <div>\n\n          <div class="title text-hint">\n            {{ tool?.name || \'Tool Name\' }}\n          </div>\n          <div class="desc text-hint">\n            {{ tool?.description || \'Tool Description\' }}\n          </div>\n        </div>\n\n\n        <div>\n\n\n\n\n\n          <button (click)="openDrawer(toolEditTemplate  , context =  { \'tool_id\':  tool?._id , \'edit_mode\': true } )"\n            status="basic" ghost size="small" nbButton>\n\n            <nb-icon icon="settings-2-outline"></nb-icon>\n            Edits\n          </button>\n\n\n          <button status="basic" ghost size="small" nbButton>\n\n            <nb-icon icon="diagonal-arrow-left-down-outline"></nb-icon>\n            Fork\n          </button>\n\n\n          <button [routerLink]="[ \'builds\' , tool?._id ]  " status="success" size="small" nbButton>Explore</button>\n        </div>\n\n\n\n      </nb-list-item>\n    </nb-list>\n  </nb-card>\n\n\n\n  <nb-layout-header subHeader>\n\n    <div fxLayout="row" fxFlex fxLayoutAlign="start center">\n\n      <button shape="round" [routerLink]="[\'/\'  ]" ghost status="basic" class="action" size="large" nbButton>\n        <nb-icon icon="arrow-back-outline">\n\n        </nb-icon>\n      </button>\n\n      <div fxFlex class="h6 text-hint">\n        Tools\n\n      </div>\n\n      <button style="margin-right: 1rem;" (click)="openDrawer(toolEditTemplate)" outline status="primary" shape="round"\n        nbButton>\n\n        \x3c!-- <div class="icon" icon="plus"></div> --\x3e\n\n        <span>\n          Create Tool\n\n        </span>\n      </button>\n    </div>\n\n  </nb-layout-header>\n\n\n\n\n  <nb-accordion>\n    <nb-accordion-item [expanded]="index == 0" *ngFor="let tool of tools   ; index as index ">\n      <nb-accordion-item-header fxLayoutAlign="space-between">\n\n\n        <span>\n          {{ tool?.name || \'Tool Name\' }}\n\n        </span>\n\n        <span class="text-hint">\n          {{ \'@\' + ( tool?.alias || \'Alias\' ) }}\n        </span>\n      </nb-accordion-item-header>\n      <nb-accordion-item-body>\n\n        <nb-card>\n          <nb-card-body>\n            <div>\n\n              <div class="text-hint">\n                {{ tool?.description || \'Tool Description\' }}\n              </div>\n\n            </div>\n          </nb-card-body>\n          <nb-card-footer fxLayoutGap="1rem" fxLayoutAlign="end center">\n\n            <div fxLayoutGap="0.5rem" fxLayoutAlign="end center">\n\n\n              <nb-button-group fxLayoutGap="2px" multiple status="primary" size="small" appearance="filled">\n\n                <button\n                  (click)="openDrawer(toolEditTemplate  , context =  { \'tool_id\':  tool?._id , \'edit_mode\': true } )"\n                  nbButton>\n\n                  <nb-icon icon="settings-2-outline"></nb-icon>\n                  Edit\n                </button>\n                <button\n                  [routerLink]="[  \'/tools\'  , \'builds\', tool?._id , { \'outlets\': {                   \'view\': [\'deployments\']                 } } ]  "\n                  nbButton>\n\n                  <nb-icon icon="flip-2-outline"></nb-icon>\n                  Deployments\n                </button>\n\n\n                <button [routerLink]="[  \'/tools\'  , \'builds\', tool?._id ]  " nbButton>\n                  <nb-icon icon="expand-outline"></nb-icon>\n\n                  Explore\n                </button>\n\n              </nb-button-group>\n\n\n\n\n\n            </div>\n\n          </nb-card-footer>\n\n        </nb-card>\n\n      </nb-accordion-item-body>\n    </nb-accordion-item>\n\n  </nb-accordion>\n\n</ng-container>\n\n\n<ng-template #loading>\n  <div fxLayoutAlign="center center">\n    <ngx-progress-spinner></ngx-progress-spinner>\n  </div>\n\n</ng-template>\n\n\n\n<ng-template #toolEditTemplate let-close="close" let-context="context" let-ref="dialogRef">\n\n  <app-tool-create [edit_mode]="context.edit_mode" [close]="close" [tool_id]="context.tool_id"></app-tool-create>\n</ng-template>',changeDetection:c.j.OnPush,animations:e(D.a),styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\nnb-accordion-item {\n  margin-top: 0.4rem;\n  margin-bottom: 0.4rem;\n}\nnb-accordion-item nb-accordion-item-header .text-hint {\n  color: #000 !important;\n}\nnb-accordion-item nb-accordion-item-header:hover {\n  background: linear-gradient(to right, #457fca, #5b86e5);\n  color: #fff;\n}\nnb-accordion-item nb-accordion-item-header:hover .text-hint {\n  color: #fff !important;\n}\nnb-accordion-item nb-accordion-item-header .text-hint {\n  color: var(--text-basic-color) !important;\n}\nnb-accordion-item nb-accordion-item-header.accordion-item-header-expanded {\n  border-left: 2px var(--text-basic-color) solid !important;\n}\nnb-accordion-item nb-accordion-item-header.accordion-item-header-expanded .text-hint {\n  color: var(--text-alternate-color) !important;\n}\nnb-layout-header {\n  padding: 0rem !important;\n  margin: 0rem !important;\n}\ninput {\n  height: 100%;\n}\nnb-card {\n  margin-bottom: 0;\n  border: 0;\n}\nnb-accordion {\n  margin-top: 1rem;\n}\nbutton.newBtn {\n  padding: 0.3rem !important;\n  padding-left: 1rem !important;\n  padding-right: 1rem !important;\n  text-transform: capitalize !important;\n  box-shadow: 0 1px 2px 0 rgba(60, 64, 67, 0.302), 0 1px 3px 1px rgba(60, 64, 67, 0.149) !important;\n  align-items: center !important;\n  background-color: #fff !important;\n  border: 1px solid transparent;\n  border-radius: 24px;\n  color: #3c4043 !important;\n}\nbutton.newBtn span {\n  margin-right: 1rem;\n  margin-top: 0.5rem;\n  margin-bottom: 0.5rem;\n  font-weight: 600;\n}\nbutton.newBtn .icon {\n  margin-right: 1rem;\n  background-image: url(\"data:image/svg+xml;charset=UTF-8,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2236%22 height=%2236%22 viewBox=%220 0 36 36%22%3E%3Cpath fill=%22%2334A853%22 d=%22M16 16v14h4V20z%22/%3E%3Cpath fill=%22%234285F4%22 d=%22M30 16H20l-4 4h14z%22/%3E%3Cpath fill=%22%23FBBC05%22 d=%22M6 16v4h10l4-4z%22/%3E%3Cpath fill=%22%23EA4335%22 d=%22M20 16V6h-4v14z%22/%3E%3Cpath fill=%22none%22 d=%22M0 0h36v36H0z%22/%3E%3C/svg%3E\");\n  width: 2rem !important;\n  height: 2rem !important;\n}\nbutton.newBtn:hover {\n  box-shadow: 0 3px 5px 0 rgba(60, 64, 67, 0.302), 0 3px 5px 1px rgba(60, 64, 67, 0.149) !important;\n  background-color: #fff !important;\n}\n.h6 {\n  margin-left: 1rem;\n}\n.action {\n  margin-left: 5px;\n}\n.action:hover nb-icon {\n  color: var(--color-primary-500);\n}\nnb-list {\n  margin-top: 0.4rem;\n  margin-bottom: 0.4rem;\n}\nnb-list nb-list-item .text-hint {\n  color: #000 !important;\n}\nnb-list nb-list-item .text-hint {\n  color: var(--text-basic-color) !important;\n}\nnb-list nb-list-item.accordion-item-header-expanded {\n  border-left: 2px var(--text-basic-color) solid !important;\n}\nnb-list nb-list-item.accordion-item-header-expanded .text-hint {\n  color: var(--text-alternate-color) !important;\n}\nnb-card-header {\n  padding: 0rem !important;\n  margin: 0rem !important;\n}"]})],ce);var de=[{path:"",component:ae,children:[{path:"test",component:_},{path:"",component:ce},{path:"builds/:id",component:oe,children:[{path:"",redirectTo:"builds",outlet:"view"},{path:"deployments",component:q,outlet:"view"},{path:"deployments/config/:id",component:H,outlet:"view"},{path:"test-deployments",component:q,outlet:"view",data:{test:!0}},{path:"test-deployments/config/:id",component:H,outlet:"view",data:{test:!0}},{path:"images",component:$,outlet:"view"},{path:"images/config/:id",component:_,outlet:"view"},{path:"builds",component:E,outlet:"view"},{path:"build_create",component:z,outlet:"view"},{path:"jobs",component:ne,outlet:"view"},{path:"**",redirectTo:"builds",outlet:"view"}]},{path:"builds/all/:id",component:E},{path:"details/:id",component:z},{path:"**",redirectTo:"/tools"}]}],he=function e(){s(this,e)};he=Object(l.a)([Object(c.N)({imports:[h.j.forChild(de)],exports:[h.j]})],he);var ue=i("YUcS"),pe=i("EcHK"),me=i("tR1z"),be=function(){function e(){s(this,e)}return r(e,[{key:"ngOnInit",value:function(){}}]),e}();be.ctorParameters=function(){return[]},be=Object(l.a)([Object(c.n)({selector:"app-headbar",template:'<nb-layout-header fixed>\n\n  <div fxFlex fxLayoutAlign="center center">\n    <div fxFlex fxLayoutAlign="start center">\n      <button routerLink="/" nbButton ghost status="danger" size="small">\n        <img class="logo" src="/assets/logo.png">\n      </button>\n    </div>\n  </div>\n\n</nb-layout-header>\n',styles:[""]})],be);var fe=function e(){s(this,e)};fe=Object(l.a)([Object(c.N)({declarations:[],imports:[d.c]})],fe);var we=i("BN9v"),ge=function(){function e(){s(this,e),this.loop=[1,1,1,1,11,1,1,1,2,312,3,213,12,312]}return r(e,[{key:"ngOnInit",value:function(){}}]),e}();ge.ctorParameters=function(){return[]},ge=Object(l.a)([Object(c.n)({selector:"app-tool-build-variants",template:'<app-build-create>\n  \n</app-build-create>\n\n<nb-list fxFlex>\n\n  <nb-list-item  *ngFor="let _ of loop">\n\n    <nb-card status="success" fxFlex>\n      <nb-card-header fxLayoutAlign="space-between center">\n\n        <div fxLayoutGap="1rem" fxLayoutAlign="start center">\n\n          <nb-icon icon="checkmark-circle-2"></nb-icon>\n\n          <span class="subtitle-2 text-alternate">\n            Hello World\n          </span>\n\n\n\n        </div>\n\n        <button status="control" hero nbButton size="tiny">\n          Save\n        </button>\n      </nb-card-header>\n      <nb-card-body>\n\n        <div class="cardcontainer" fxLayout="column">\n\n\n          <div fxFlex fxLayoutAlign="start center" fxLayoutGap="1rem">\n            <nb-icon icon="flip-2"></nb-icon>\n\n            <span>\n              <a class="text-basic">\n                Helllo\n              </a>\n            </span>\n            <span>\n              Word\n            </span>\n          </div>\n\n          <div fxFlex fxLayoutAlign="start center" fxLayoutGap="1rem">\n            <nb-icon icon="flip-2"></nb-icon>\n\n            <span>\n              <a>\n                Helllo\n              </a>\n            </span>\n            <span>\n              Word\n            </span>\n          </div>\n\n\n          <div fxFlex fxLayoutAlign="start center" fxLayoutGap="1rem">\n            <nb-icon icon="flip-2"></nb-icon>\n\n            <span>\n              <a>\n                Helllo\n              </a>\n            </span>\n            <span>\n              Word\n            </span>\n          </div>\n\n\n          <div fxFlex fxLayoutAlign="start center" fxLayoutGap="1rem">\n            <nb-icon icon="flip-2"></nb-icon>\n\n            <span>\n              <a>\n                Helllo\n              </a>\n            </span>\n            <span>\n              Word\n            </span>\n          </div>\n\n\n          <div fxFlex fxLayoutAlign="start center" fxLayoutGap="1rem">\n            <nb-icon icon="flip-2"></nb-icon>\n\n            <span>\n              <a>\n                Helllo\n              </a>\n            </span>\n            <span>\n              Word\n            </span>\n          </div>\n\n        </div>\n\n      </nb-card-body>\n    </nb-card>\n\n  </nb-list-item>\n\n</nb-list>\n',changeDetection:c.j.OnPush,styles:[".cardcontainer {\n  border-radius: 3px;\n  background: white;\n  box-shadow: rgba(9, 30, 66, 0.31) 0px 0px 1px;\n  padding: 1rem;\n  box-sizing: border-box;\n  position: relative;\n}\n\nnb-card-body {\n  background: rgba(244, 245, 247, 0.212);\n  box-sizing: border-box;\n  padding: 8px;\n  border-radius: 0px 0px 5px 5px;\n}"]})],ge);var ve=function(){function e(){s(this,e),this.direction="horizontal"}return r(e,[{key:"ngOnInit",value:function(){}}]),e}();ve.ctorParameters=function(){return[]},ve=Object(l.a)([Object(c.n)({selector:"app-tool-screen",template:" <app-tool-list></app-tool-list>\n",changeDetection:c.j.OnPush,styles:["nb-layout-column:first-child {\n  flex: 1 !important;\n}\n\nnb-layout-column:last-child {\n  flex: 1 !important;\n}"]})],ve);var xe=i("HDdC"),ye=i("Kj3r"),ke=["gutterEls"];function Ae(e,n){if(1&e){var t=c.Xc();c.Wc(0,"div",2,3),c.ed("mousedown",function(e){c.td(t);var n=c.gd().index;return c.gd().startDragging(e,2*n+1,n+1)})("touchstart",function(e){c.td(t);var n=c.gd().index;return c.gd().startDragging(e,2*n+1,n+1)})("mouseup",function(e){c.td(t);var n=c.gd().index;return c.gd().clickGutter(e,n+1)})("touchend",function(e){c.td(t);var n=c.gd().index;return c.gd().clickGutter(e,n+1)}),c.Rc(2,"div",4),c.Vc()}if(2&e){var o=c.gd().index,s=c.gd();c.xd("flex-basis",s.gutterSize,"px")("order",2*o+1)}}function Le(e,n){if(1&e&&c.zd(0,Ae,3,4,"div",1),2&e){var t=n.last;c.md("ngIf",!1===t)}}function Se(e){return void 0!==e.changedTouches&&e.changedTouches.length>0?{x:e.changedTouches[0].clientX,y:e.changedTouches[0].clientY}:void 0!==e.clientX&&void 0!==e.clientY?{x:e.clientX,y:e.clientY}:null}function Ce(e,n){var t=e.nativeElement.getBoundingClientRect();return"horizontal"===n?t.width:t.height}function Re(e){return"boolean"==typeof e?e:"false"!==e}function Te(e,n){return null==e?n:(e=Number(e),!isNaN(e)&&e>=0?e:n)}function Ie(e,n){if("percent"===e){var t=n.reduce(function(e,n){return null!==n?e+n:e},0);return n.every(function(e){return null!==e})&&t>99.9&&t<100.1}if("pixel"===e)return 1===n.filter(function(e){return null===e}).length}function _e(e){return null===e.size?null:!0===e.component.lockSize?e.size:null===e.component.minSize?null:e.component.minSize>e.size?e.size:e.component.minSize}function je(e){return null===e.size?null:!0===e.component.lockSize?e.size:null===e.component.maxSize?null:e.component.maxSize<e.size?e.size:e.component.maxSize}function Fe(e,n,t,o){return n.reduce(function(n,t){var s=function(e,n,t,o){return 0===t?{areaSnapshot:n,pixelAbsorb:0,percentAfterAbsorption:n.sizePercentAtStart,pixelRemain:0}:0===n.sizePixelAtStart&&t<0?{areaSnapshot:n,pixelAbsorb:0,percentAfterAbsorption:0,pixelRemain:t}:"percent"===e?function(e,n,t){var o=(e.sizePixelAtStart+n)/t*100;if(n>0){if(null!==e.area.maxSize&&o>e.area.maxSize){var s=e.area.maxSize/100*t;return{areaSnapshot:e,pixelAbsorb:s,percentAfterAbsorption:e.area.maxSize,pixelRemain:e.sizePixelAtStart+n-s}}return{areaSnapshot:e,pixelAbsorb:n,percentAfterAbsorption:o>100?100:o,pixelRemain:0}}if(n<0){if(null!==e.area.minSize&&o<e.area.minSize){var i=e.area.minSize/100*t;return{areaSnapshot:e,pixelAbsorb:i,percentAfterAbsorption:e.area.minSize,pixelRemain:e.sizePixelAtStart+n-i}}return o<0?{areaSnapshot:e,pixelAbsorb:-e.sizePixelAtStart,percentAfterAbsorption:0,pixelRemain:n+e.sizePixelAtStart}:{areaSnapshot:e,pixelAbsorb:n,percentAfterAbsorption:o,pixelRemain:0}}}(n,t,o):"pixel"===e?function(e,n,t){var o=e.sizePixelAtStart+n;return n>0?null!==e.area.maxSize&&o>e.area.maxSize?{areaSnapshot:e,pixelAbsorb:e.area.maxSize-e.sizePixelAtStart,percentAfterAbsorption:-1,pixelRemain:o-e.area.maxSize}:{areaSnapshot:e,pixelAbsorb:n,percentAfterAbsorption:-1,pixelRemain:0}:n<0?null!==e.area.minSize&&o<e.area.minSize?{areaSnapshot:e,pixelAbsorb:e.area.minSize+n-o,percentAfterAbsorption:-1,pixelRemain:o-e.area.minSize}:o<0?{areaSnapshot:e,pixelAbsorb:-e.sizePixelAtStart,percentAfterAbsorption:-1,pixelRemain:n+e.sizePixelAtStart}:{areaSnapshot:e,pixelAbsorb:n,percentAfterAbsorption:-1,pixelRemain:0}:void 0}(n,t):void 0}(e,t,n.remain,o);return n.list.push(s),n.remain=s.pixelRemain,n},{remain:t,list:[]})}function Pe(e,n){"percent"===e?n.areaSnapshot.area.size=n.percentAfterAbsorption:"pixel"===e&&null!==n.areaSnapshot.area.size&&(n.areaSnapshot.area.size=n.areaSnapshot.sizePixelAtStart+n.pixelAbsorb)}var Me=function(){function n(e,t,o,i){s(this,n),this.ngZone=e,this.elRef=t,this.cdRef=o,this.renderer=i,this._direction="horizontal",this._unit="percent",this._gutterSize=11,this._gutterStep=1,this._restrictMove=!1,this._useTransition=!1,this._disabled=!1,this._dir="ltr",this._gutterDblClickDuration=0,this.dragStart=new c.y(!1),this.dragEnd=new c.y(!1),this.gutterClick=new c.y(!1),this.gutterDblClick=new c.y(!1),this.dragProgressSubject=new w.a,this.dragProgress$=this.dragProgressSubject.asObservable(),this.isDragging=!1,this.isWaitingClear=!1,this.dragListeners=[],this.snapshot=null,this.startPoint=null,this.endPoint=null,this.displayedAreas=[],this.hidedAreas=[],this._clickTimeout=null,this.direction=this._direction}return r(n,[{key:"direction",get:function(){return this._direction},set:function(e){this._direction="vertical"===e?"vertical":"horizontal",this.renderer.addClass(this.elRef.nativeElement,"as-"+this._direction),this.renderer.removeClass(this.elRef.nativeElement,"as-"+("vertical"===this._direction?"horizontal":"vertical")),this.build(!1,!1)}},{key:"unit",get:function(){return this._unit},set:function(e){this._unit="pixel"===e?"pixel":"percent",this.renderer.addClass(this.elRef.nativeElement,"as-"+this._unit),this.renderer.removeClass(this.elRef.nativeElement,"as-"+("pixel"===this._unit?"percent":"pixel")),this.build(!1,!0)}},{key:"gutterSize",get:function(){return this._gutterSize},set:function(e){this._gutterSize=Te(e,11),this.build(!1,!1)}},{key:"gutterStep",get:function(){return this._gutterStep},set:function(e){this._gutterStep=Te(e,1)}},{key:"restrictMove",get:function(){return this._restrictMove},set:function(e){this._restrictMove=Re(e)}},{key:"useTransition",get:function(){return this._useTransition},set:function(e){this._useTransition=Re(e),this._useTransition?this.renderer.addClass(this.elRef.nativeElement,"as-transition"):this.renderer.removeClass(this.elRef.nativeElement,"as-transition")}},{key:"disabled",get:function(){return this._disabled},set:function(e){this._disabled=Re(e),this._disabled?this.renderer.addClass(this.elRef.nativeElement,"as-disabled"):this.renderer.removeClass(this.elRef.nativeElement,"as-disabled")}},{key:"dir",get:function(){return this._dir},set:function(e){this._dir="rtl"===e?"rtl":"ltr",this.renderer.setAttribute(this.elRef.nativeElement,"dir",this._dir)}},{key:"gutterDblClickDuration",get:function(){return this._gutterDblClickDuration},set:function(e){this._gutterDblClickDuration=Te(e,0)}},{key:"transitionEnd",get:function(){var e=this;return new xe.a(function(n){return e.transitionEndSubscriber=n}).pipe(Object(ye.a)(20))}},{key:"ngAfterViewInit",value:function(){var e=this;this.ngZone.runOutsideAngular(function(){setTimeout(function(){return e.renderer.addClass(e.elRef.nativeElement,"as-init")})})}},{key:"getNbGutters",value:function(){return 0===this.displayedAreas.length?0:this.displayedAreas.length-1}},{key:"addArea",value:function(e){var n={component:e,order:0,size:0,minSize:null,maxSize:null};!0===e.visible?(this.displayedAreas.push(n),this.build(!0,!0)):this.hidedAreas.push(n)}},{key:"removeArea",value:function(e){if(this.displayedAreas.some(function(n){return n.component===e})){var n=this.displayedAreas.find(function(n){return n.component===e});this.displayedAreas.splice(this.displayedAreas.indexOf(n),1),this.build(!0,!0)}else if(this.hidedAreas.some(function(n){return n.component===e})){var t=this.hidedAreas.find(function(n){return n.component===e});this.hidedAreas.splice(this.hidedAreas.indexOf(t),1)}}},{key:"updateArea",value:function(e,n,t){!0===e.visible&&this.build(n,t)}},{key:"showArea",value:function(n){var t,o=this.hidedAreas.find(function(e){return e.component===n});if(void 0!==o){var s=this.hidedAreas.splice(this.hidedAreas.indexOf(o),1);(t=this.displayedAreas).push.apply(t,e(s)),this.build(!0,!0)}}},{key:"hideArea",value:function(n){var t,o=this.displayedAreas.find(function(e){return e.component===n});if(void 0!==o){var s=this.displayedAreas.splice(this.displayedAreas.indexOf(o),1);s.forEach(function(e){e.order=0,e.size=0}),(t=this.hidedAreas).push.apply(t,e(s)),this.build(!0,!0)}}},{key:"getVisibleAreaSizes",value:function(){return this.displayedAreas.map(function(e){return null===e.size?"*":e.size})}},{key:"setVisibleAreaSizes",value:function(e){if(e.length!==this.displayedAreas.length)return!1;var n=e.map(function(e){return Te(e,null)});return!1!==Ie(this.unit,n)&&(this.displayedAreas.forEach(function(e,t){return e.component._size=n[t]}),this.build(!1,!0),!0)}},{key:"build",value:function(e,n){if(this.stopDragging(),!0===e&&(this.displayedAreas.every(function(e){return null!==e.component.order})&&this.displayedAreas.sort(function(e,n){return e.component.order-n.component.order}),this.displayedAreas.forEach(function(e,n){e.order=2*n,e.component.setStyleOrder(e.order)})),!0===n){var t=Ie(this.unit,this.displayedAreas.map(function(e){return e.component.size}));switch(this.unit){case"percent":var o=100/this.displayedAreas.length;this.displayedAreas.forEach(function(e){e.size=t?e.component.size:o,e.minSize=_e(e),e.maxSize=je(e)});break;case"pixel":if(t)this.displayedAreas.forEach(function(e){e.size=e.component.size,e.minSize=_e(e),e.maxSize=je(e)});else{var s=this.displayedAreas.filter(function(e){return null===e.component.size});if(0===s.length&&this.displayedAreas.length>0)this.displayedAreas.forEach(function(e,n){e.size=0===n?null:e.component.size,e.minSize=0===n?null:_e(e),e.maxSize=0===n?null:je(e)});else if(s.length>1){var i=!1;this.displayedAreas.forEach(function(e){null===e.component.size?!1===i?(e.size=null,e.minSize=null,e.maxSize=null,i=!0):(e.size=100,e.minSize=null,e.maxSize=null):(e.size=e.component.size,e.minSize=_e(e),e.maxSize=je(e))})}}}}this.refreshStyleSizes(),this.cdRef.markForCheck()}},{key:"refreshStyleSizes",value:function(){var e=this;if("percent"===this.unit)if(1===this.displayedAreas.length)this.displayedAreas[0].component.setStyleFlex(0,0,"100%",!1,!1);else{var n=this.getNbGutters()*this.gutterSize;this.displayedAreas.forEach(function(e){e.component.setStyleFlex(0,0,"calc( ".concat(e.size,"% - ").concat(e.size/100*n,"px )"),null!==e.minSize&&e.minSize===e.size,null!==e.maxSize&&e.maxSize===e.size)})}else"pixel"===this.unit&&this.displayedAreas.forEach(function(n){null===n.size?1===e.displayedAreas.length?n.component.setStyleFlex(1,1,"100%",!1,!1):n.component.setStyleFlex(1,1,"auto",!1,!1):1===e.displayedAreas.length?n.component.setStyleFlex(0,0,"100%",!1,!1):n.component.setStyleFlex(0,0,n.size+"px",null!==n.minSize&&n.minSize===n.size,null!==n.maxSize&&n.maxSize===n.size)})}},{key:"clickGutter",value:function(e,n){var t=this,o=Se(e);this.startPoint&&this.startPoint.x===o.x&&this.startPoint.y===o.y&&(null!==this._clickTimeout?(window.clearTimeout(this._clickTimeout),this._clickTimeout=null,this.notify("dblclick",n),this.stopDragging()):this._clickTimeout=window.setTimeout(function(){t._clickTimeout=null,t.notify("click",n),t.stopDragging()},this.gutterDblClickDuration))}},{key:"startDragging",value:function(n,t,o){var s=this;n.preventDefault(),n.stopPropagation(),this.startPoint=Se(n),null!==this.startPoint&&!0!==this.disabled&&!0!==this.isWaitingClear&&(this.snapshot={gutterNum:o,lastSteppedOffset:0,allAreasSizePixel:Ce(this.elRef,this.direction)-this.getNbGutters()*this.gutterSize,allInvolvedAreasSizePercent:100,areasBeforeGutter:[],areasAfterGutter:[]},this.displayedAreas.forEach(function(e){var n={area:e,sizePixelAtStart:Ce(e.component.elRef,s.direction),sizePercentAtStart:"percent"===s.unit?e.size:-1};e.order<t?!0===s.restrictMove?s.snapshot.areasBeforeGutter=[n]:s.snapshot.areasBeforeGutter.unshift(n):e.order>t&&(!0===s.restrictMove?0===s.snapshot.areasAfterGutter.length&&(s.snapshot.areasAfterGutter=[n]):s.snapshot.areasAfterGutter.push(n))}),this.snapshot.allInvolvedAreasSizePercent=[].concat(e(this.snapshot.areasBeforeGutter),e(this.snapshot.areasAfterGutter)).reduce(function(e,n){return e+n.sizePercentAtStart},0),0!==this.snapshot.areasBeforeGutter.length&&0!==this.snapshot.areasAfterGutter.length&&(this.dragListeners.push(this.renderer.listen("document","mouseup",this.stopDragging.bind(this))),this.dragListeners.push(this.renderer.listen("document","touchend",this.stopDragging.bind(this))),this.dragListeners.push(this.renderer.listen("document","touchcancel",this.stopDragging.bind(this))),this.ngZone.runOutsideAngular(function(){s.dragListeners.push(s.renderer.listen("document","mousemove",s.dragEvent.bind(s))),s.dragListeners.push(s.renderer.listen("document","touchmove",s.dragEvent.bind(s)))}),this.displayedAreas.forEach(function(e){return e.component.lockEvents()}),this.isDragging=!0,this.renderer.addClass(this.elRef.nativeElement,"as-dragging"),this.renderer.addClass(this.gutterEls.toArray()[this.snapshot.gutterNum-1].nativeElement,"as-dragged"),this.notify("start",this.snapshot.gutterNum)))}},{key:"dragEvent",value:function(n){var t=this;if(n.preventDefault(),n.stopPropagation(),null!==this._clickTimeout&&(window.clearTimeout(this._clickTimeout),this._clickTimeout=null),!1!==this.isDragging&&(this.endPoint=Se(n),null!==this.endPoint)){var o="horizontal"===this.direction?this.startPoint.x-this.endPoint.x:this.startPoint.y-this.endPoint.y;"rtl"===this.dir&&(o=-o);var s=Math.round(o/this.gutterStep)*this.gutterStep;if(s!==this.snapshot.lastSteppedOffset){this.snapshot.lastSteppedOffset=s;var i=Fe(this.unit,this.snapshot.areasBeforeGutter,-s,this.snapshot.allAreasSizePixel),r=Fe(this.unit,this.snapshot.areasAfterGutter,s,this.snapshot.allAreasSizePixel);if(0!==i.remain&&0!==r.remain?Math.abs(i.remain)===Math.abs(r.remain)||(Math.abs(i.remain)>Math.abs(r.remain)?r=Fe(this.unit,this.snapshot.areasAfterGutter,s+i.remain,this.snapshot.allAreasSizePixel):i=Fe(this.unit,this.snapshot.areasBeforeGutter,-(s-r.remain),this.snapshot.allAreasSizePixel)):0!==i.remain?r=Fe(this.unit,this.snapshot.areasAfterGutter,s+i.remain,this.snapshot.allAreasSizePixel):0!==r.remain&&(i=Fe(this.unit,this.snapshot.areasBeforeGutter,-(s-r.remain),this.snapshot.allAreasSizePixel)),"percent"===this.unit){var a=[].concat(e(i.list),e(r.list)),l=a.find(function(e){return 0!==e.percentAfterAbsorption&&e.percentAfterAbsorption!==e.areaSnapshot.area.minSize&&e.percentAfterAbsorption!==e.areaSnapshot.area.maxSize});l&&(l.percentAfterAbsorption=this.snapshot.allInvolvedAreasSizePercent-a.filter(function(e){return e!==l}).reduce(function(e,n){return e+n.percentAfterAbsorption},0))}i.list.forEach(function(e){return Pe(t.unit,e)}),r.list.forEach(function(e){return Pe(t.unit,e)}),this.refreshStyleSizes(),this.notify("progress",this.snapshot.gutterNum)}}}},{key:"stopDragging",value:function(e){var n=this;if(e&&(e.preventDefault(),e.stopPropagation()),!1!==this.isDragging){for(this.displayedAreas.forEach(function(e){return e.component.unlockEvents()});this.dragListeners.length>0;){var t=this.dragListeners.pop();t&&t()}this.isDragging=!1,!this.endPoint||this.startPoint.x===this.endPoint.x&&this.startPoint.y===this.endPoint.y||this.notify("end",this.snapshot.gutterNum),this.renderer.removeClass(this.elRef.nativeElement,"as-dragging"),this.renderer.removeClass(this.gutterEls.toArray()[this.snapshot.gutterNum-1].nativeElement,"as-dragged"),this.snapshot=null,this.isWaitingClear=!0,this.ngZone.runOutsideAngular(function(){setTimeout(function(){n.startPoint=null,n.endPoint=null,n.isWaitingClear=!1})})}}},{key:"notify",value:function(e,n){var t=this,o=this.getVisibleAreaSizes();"start"===e?this.dragStart.emit({gutterNum:n,sizes:o}):"end"===e?this.dragEnd.emit({gutterNum:n,sizes:o}):"click"===e?this.gutterClick.emit({gutterNum:n,sizes:o}):"dblclick"===e?this.gutterDblClick.emit({gutterNum:n,sizes:o}):"transitionEnd"===e?this.transitionEndSubscriber&&this.ngZone.run(function(){return t.transitionEndSubscriber.next(o)}):"progress"===e&&this.dragProgressSubject.next({gutterNum:n,sizes:o})}},{key:"ngOnDestroy",value:function(){this.stopDragging()}}]),n}();Me.\u0275fac=function(e){return new(e||Me)(c.Qc(c.S),c.Qc(c.v),c.Qc(c.k),c.Qc(c.bb))},Me.\u0275cmp=c.Kc({type:Me,selectors:[["as-split"]],viewQuery:function(e,n){var t;(1&e&&c.Ed(ke,1),2&e)&&(c.pd(t=c.fd())&&(n.gutterEls=t))},inputs:{direction:"direction",unit:"unit",gutterSize:"gutterSize",gutterStep:"gutterStep",restrictMove:"restrictMove",useTransition:"useTransition",disabled:"disabled",dir:"dir",gutterDblClickDuration:"gutterDblClickDuration"},outputs:{dragStart:"dragStart",dragEnd:"dragEnd",gutterClick:"gutterClick",gutterDblClick:"gutterDblClick",transitionEnd:"transitionEnd"},exportAs:["asSplit"],ngContentSelectors:["*"],decls:2,vars:1,consts:[["ngFor","",3,"ngForOf"],["class","as-split-gutter",3,"flex-basis","order","mousedown","touchstart","mouseup","touchend",4,"ngIf"],[1,"as-split-gutter",3,"mousedown","touchstart","mouseup","touchend"],["gutterEls",""],[1,"as-split-gutter-icon"]],template:function(e,n){1&e&&(c.ld(),c.kd(0),c.zd(1,Le,1,1,"ng-template",0)),2&e&&(c.Ec(1),c.md("ngForOf",n.displayedAreas))},directives:[d.m,d.n],styles:['[_nghost-%COMP%]{display:flex;flex-wrap:nowrap;justify-content:flex-start;align-items:stretch;overflow:hidden;width:100%;height:100%}[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]{flex-grow:0;flex-shrink:0;background-color:#eee;display:flex;align-items:center;justify-content:center}[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%] > .as-split-gutter-icon[_ngcontent-%COMP%]{width:100%;height:100%;background-position:center center;background-repeat:no-repeat}[_nghost-%COMP%]    >.as-split-area{flex-grow:0;flex-shrink:0;overflow-x:hidden;overflow-y:auto}[_nghost-%COMP%]    >.as-split-area.as-hidden{flex:0 1 0px!important;overflow-x:hidden;overflow-y:hidden}.as-horizontal[_nghost-%COMP%]{flex-direction:row}.as-horizontal[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]{flex-direction:row;cursor:col-resize;height:100%}.as-horizontal[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%] > .as-split-gutter-icon[_ngcontent-%COMP%]{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAeCAYAAADkftS9AAAAIklEQVQoU2M4c+bMfxAGAgYYmwGrIIiDjrELjpo5aiZeMwF+yNnOs5KSvgAAAABJRU5ErkJggg==)}.as-horizontal[_nghost-%COMP%]    >.as-split-area{height:100%}.as-vertical[_nghost-%COMP%]{flex-direction:column}.as-vertical[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]{flex-direction:column;cursor:row-resize;width:100%}.as-vertical[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]   .as-split-gutter-icon[_ngcontent-%COMP%]{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAFCAMAAABl/6zIAAAABlBMVEUAAADMzMzIT8AyAAAAAXRSTlMAQObYZgAAABRJREFUeAFjYGRkwIMJSeMHlBkOABP7AEGzSuPKAAAAAElFTkSuQmCC)}.as-vertical[_nghost-%COMP%]    >.as-split-area{width:100%}.as-vertical[_nghost-%COMP%]    >.as-split-area.as-hidden{max-width:0}.as-disabled[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]{cursor:default}.as-disabled[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]   .as-split-gutter-icon[_ngcontent-%COMP%]{background-image:url("")}.as-transition.as-init[_nghost-%COMP%]:not(.as-dragging)    >.as-split-area, .as-transition.as-init[_nghost-%COMP%]:not(.as-dragging) > .as-split-gutter[_ngcontent-%COMP%]{transition:flex-basis .3s}'],changeDetection:0}),Me.ctorParameters=function(){return[{type:c.S},{type:c.v},{type:c.k},{type:c.bb}]},Me.propDecorators={direction:[{type:c.I}],unit:[{type:c.I}],gutterSize:[{type:c.I}],gutterStep:[{type:c.I}],restrictMove:[{type:c.I}],useTransition:[{type:c.I}],disabled:[{type:c.I}],dir:[{type:c.I}],gutterDblClickDuration:[{type:c.I}],dragStart:[{type:c.U}],dragEnd:[{type:c.U}],gutterClick:[{type:c.U}],gutterDblClick:[{type:c.U}],transitionEnd:[{type:c.U}],gutterEls:[{type:c.rb,args:["gutterEls"]}]};var ze=function(){function e(n,t,o,i){s(this,e),this.ngZone=n,this.elRef=t,this.renderer=o,this.split=i,this._order=null,this._size=null,this._minSize=null,this._maxSize=null,this._lockSize=!1,this._visible=!0,this.lockListeners=[],this.renderer.addClass(this.elRef.nativeElement,"as-split-area")}return r(e,[{key:"order",get:function(){return this._order},set:function(e){this._order=Te(e,null),this.split.updateArea(this,!0,!1)}},{key:"size",get:function(){return this._size},set:function(e){this._size=Te(e,null),this.split.updateArea(this,!1,!0)}},{key:"minSize",get:function(){return this._minSize},set:function(e){this._minSize=Te(e,null),this.split.updateArea(this,!1,!0)}},{key:"maxSize",get:function(){return this._maxSize},set:function(e){this._maxSize=Te(e,null),this.split.updateArea(this,!1,!0)}},{key:"lockSize",get:function(){return this._lockSize},set:function(e){this._lockSize=Re(e),this.split.updateArea(this,!1,!0)}},{key:"visible",get:function(){return this._visible},set:function(e){this._visible=Re(e),this._visible?(this.split.showArea(this),this.renderer.removeClass(this.elRef.nativeElement,"as-hidden")):(this.split.hideArea(this),this.renderer.addClass(this.elRef.nativeElement,"as-hidden"))}},{key:"ngOnInit",value:function(){var e=this;this.split.addArea(this),this.ngZone.runOutsideAngular(function(){e.transitionListener=e.renderer.listen(e.elRef.nativeElement,"transitionend",function(n){"flex-basis"===n.propertyName&&e.split.notify("transitionEnd",-1)})})}},{key:"setStyleOrder",value:function(e){this.renderer.setStyle(this.elRef.nativeElement,"order",e)}},{key:"setStyleFlex",value:function(e,n,t,o,s){this.renderer.setStyle(this.elRef.nativeElement,"flex-grow",e),this.renderer.setStyle(this.elRef.nativeElement,"flex-shrink",n),this.renderer.setStyle(this.elRef.nativeElement,"flex-basis",t),!0===o?this.renderer.addClass(this.elRef.nativeElement,"as-min"):this.renderer.removeClass(this.elRef.nativeElement,"as-min"),!0===s?this.renderer.addClass(this.elRef.nativeElement,"as-max"):this.renderer.removeClass(this.elRef.nativeElement,"as-max")}},{key:"lockEvents",value:function(){var e=this;this.ngZone.runOutsideAngular(function(){e.lockListeners.push(e.renderer.listen(e.elRef.nativeElement,"selectstart",function(e){return!1})),e.lockListeners.push(e.renderer.listen(e.elRef.nativeElement,"dragstart",function(e){return!1}))})}},{key:"unlockEvents",value:function(){for(;this.lockListeners.length>0;){var e=this.lockListeners.pop();e&&e()}}},{key:"ngOnDestroy",value:function(){this.unlockEvents(),this.transitionListener&&this.transitionListener(),this.split.removeArea(this)}}]),e}();ze.\u0275fac=function(e){return new(e||ze)(c.Qc(c.S),c.Qc(c.v),c.Qc(c.bb),c.Qc(Me))},ze.\u0275dir=c.Lc({type:ze,selectors:[["as-split-area"],["","as-split-area",""]],inputs:{order:"order",size:"size",minSize:"minSize",maxSize:"maxSize",lockSize:"lockSize",visible:"visible"},exportAs:["asSplitArea"]}),ze.ctorParameters=function(){return[{type:c.S},{type:c.v},{type:c.bb},{type:Me}]},ze.propDecorators={order:[{type:c.I}],size:[{type:c.I}],minSize:[{type:c.I}],maxSize:[{type:c.I}],lockSize:[{type:c.I}],visible:[{type:c.I}]};var Be=function(){function e(){s(this,e)}return r(e,null,[{key:"forRoot",value:function(){return{ngModule:e,providers:[]}}},{key:"forChild",value:function(){return{ngModule:e,providers:[]}}}]),e}();Be.\u0275mod=c.Oc({type:Be}),Be.\u0275inj=c.Nc({factory:function(e){return new(e||Be)},imports:[[d.c]]}),("undefined"==typeof ngJitMode||ngJitMode)&&c.wd(Be,{declarations:function(){return[Me,ze]},imports:function(){return[d.c]},exports:function(){return[Me,ze]}});var Oe=i("1NbL"),De=function(){function e(){s(this,e)}return r(e,[{key:"ngOnInit",value:function(){}}]),e}();De.ctorParameters=function(){return[]},De=Object(l.a)([Object(c.n)({selector:"app-divider",template:'<div class="wrapper">\n  <div class="divider div-transparent"></div>\n</div>\n',styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\n.wrapper {\n  padding-bottom: 4px;\n}\n.divider {\n  position: relative;\n  margin-top: 4px;\n  height: 1px;\n}\n.div-transparent:before {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 5%;\n  right: 5%;\n  width: 90%;\n  height: 1px;\n  background-image: linear-gradient(to right, transparent, var(--input-basic-border-color), transparent);\n}"]})],De);var We=i("WONP"),Ee=i("u47x"),Ge=function(){function e(n,t){s(this,e),this.toolApiService=n,this.cdr=t,this._=[1,2,2,2,2,2,22,2,2,2,2,2,2,2,2,321,312,321,321,312,312,312,3,213,21,312,3,213,213,21,32,13,213,21,321],this.edit_mode=!1,this.form=new u.e({alias:new u.d("",[u.n.required,u.n.pattern("[a-z0-9]+(?:[._-]{1,2}[a-z0-9]+)*")]),name:new u.d("",[u.n.required]),description:new u.d("")})}return r(e,[{key:"ngOnInit",value:function(){var e=this;1==this.edit_mode&&this.toolApiService.getTool(this.tool_id).subscribe(function(n){var t=n.alias,o=n.name,s=n.description;e.form.get("alias").setValue(t),e.form.get("alias").disable(),e.form.get("name").setValue(o),e.form.get("description").setValue(s),e.cdr.markForCheck()})}},{key:"createTool",value:function(){var e=this;Object(v.a)(x.a).pipe(Object(y.a)(function(n){return 1==e.edit_mode?e.toolApiService.editTool(e.tool_id,e.form.value):e.toolApiService.createTool(e.form.value)}),Object(F.b)(function(e){return e}),Object(m.a)(function(n){e.close.next()})).subscribe()}}]),e}();Ge.ctorParameters=function(){return[{type:I},{type:c.k}]},Ge.propDecorators={close:[{type:c.I,args:["close"]}],edit_mode:[{type:c.I,args:["edit_mode"]}],tool_id:[{type:c.I,args:["tool_id"]}]},Ge=Object(l.a)([Object(c.n)({selector:"app-tool-create",template:'<nb-layout withScroll="true">\n  <nb-layout-column>\n\n\n    <nb-card    class="dialog">\n      <nb-card-header fxLayoutAlign="space-between center">\n\n\n\n        <div fxFlex fxLayoutAlign="start center" fxLayout="row">\n\n          <button (click)="close.next(true)" shape="round" ghost status="basic" class="action" size="large" nbButton>\n            <nb-icon icon="arrow-back-outline">\n\n            </nb-icon>\n          </button>\n\n          <span class="subtitle text-hint lineV">\n            Create Tool\n          </span>\n\n        </div>\n\n        <div>\n\n          \x3c!-- <button   [disabled]="form.invalid" (click)="createTool()" filled outline shape="semi-round" status="primary" size="small" nbButton>Save</button> --\x3e\n        </div>\n\n        \x3c!-- <button (click)="close.next(true)" shape="round" ghost status="basic" class="action" size="large" nbButton>\n      <nb-icon icon="info">\n\n      </nb-icon>\n    </button> --\x3e\n\n\n      </nb-card-header>\n      <nb-card-body [formGroup]="form">\n\n\n     \n        \n        <div fxLayout="column" fxLayoutGap="1rem">\n\n\n          \x3c!-- --\x3e\n\n\n\n\n\n          \x3c!--  --\x3e\n          <div>\n\n            <div>\n              <p class="subtitle-2 text-hint">\n                Alias\n              </p>\n            </div>\n\n            <nb-form-field>\n              <nb-icon icon="at" nbPrefix></nb-icon>\n              <input cdkFocusInitial fieldSize="small" [status]="form.controls[\'alias\'].valid ? \'primary\' : \'basic\' "\n                formControlName="alias" fullWidth nbInput placeholder="Alias">\n\n            </nb-form-field>\n\n          </div>\n          <app-divider></app-divider>\n\n          <div s>\n            <div>\n              <p class="subtitle-2 text-hint">\n                Name\n              </p>\n            </div>\n\n\n            <nb-form-field>\n\n              <input fieldSize="small" [status]="form.controls[\'name\'].valid ? \'primary\' : \'basic\' "\n                formControlName="name" fullWidth nbInput placeholder="Name">\n            </nb-form-field>\n\n\n          </div>\n          <app-divider></app-divider>\n          <div>\n\n            <div>\n              <p class="subtitle-2 text-hint">\n                Description\n              </p>\n            </div>\n\n\n            <nb-form-field>\n\n              <textarea fieldSize="small" [status]="form.controls[\'description\'].valid ? \'primary\' : \'basic\' "\n                formControlName="description" style="resize: none;" fullWidth nbInput\n                placeholder="Description (Optional) "></textarea>\n            </nb-form-field>\n\n\n          </div>\n          <app-divider></app-divider>\n        </div>\n      </nb-card-body>\n\n\n      <nb-card-footer fxLayoutAlign="end" fxLayoutGap="1rem">\n        \x3c!-- <button hero status="basic" nbButton (click)="ref.close()">Go Back</button> --\x3e\n\n        <button fullWidth [disabled]="form.invalid" (click)="createTool()" filled status="success"\n          nbButton>Save</button>\n      </nb-card-footer>\n    </nb-card>\n\n  </nb-layout-column>\n</nb-layout>',styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\nnb-card {\n  margin: 0;\n}\nnb-card textarea {\n  resize: none;\n}\n.label-text {\n  border-left: 2px var(--text-hint-color) solid !important;\n  margin-bottom: 1rem;\n  padding-left: 4px;\n}\n.subtitle {\n  margin: 0;\n  padding-left: 4px;\n}\nnb-card-header {\n  padding: 0.4rem;\n  box-shadow: 2px 2px 3px rgba(0, 0, 0, 0.16), 2px 2px 3px rgba(0, 0, 0, 0.23);\n}\nnb-card-footer {\n  padding: 0;\n}\nnb-card {\n  border: 0;\n}\n.buildBtn {\n  border-radius: 0;\n}"]})],Ge);var Ne=i("vxfF"),$e=function e(){s(this,e)};$e=Object(l.a)([Object(c.N)({declarations:[ae,be,we.a,ee,ge,ve,ce,z,E,De,_,Ge,$,q,ne,H,oe],imports:[G.g,Ne.c,Oe.a,p.p,ue.a,d.c,he,p.n,pe.a,p.z.forRoot(),p.E.forRoot({name:"default"}),me.a,p.i.forChild(),p.e,u.f,fe,p.q,p.f,p.b,p.a,Be,p.o,p.l,p.c,u.m,p.i.forChild(),p.y,p.q,p.A,p.g,We.a,p.C,p.w,pe.a,Ee.a,b.c,me.a,Z.b,p.G,p.d,p.D,p.u,p.h,p.d,p.x],providers:[I,U.a,M,{provide:G.f,useClass:G.c}]})],$e)}}])}();