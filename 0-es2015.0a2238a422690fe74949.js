(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{"1NbL":function(e,t,n){"use strict";n.d(t,"a",function(){return M});var s=n("mrSG"),o=n("fXoL"),i=n("ofXK"),r=n("8LU1"),a=n("XNiG"),c=n("itXk"),l=n("GyhO"),h=n("HDdC"),d=n("IzEk"),p=n("zP0r"),u=n("Kj3r"),m=n("lJxs"),b=n("JX91"),w=n("1G5W"),y=n("nLfN");class g{}g.\u0275mod=o.Oc({type:g}),g.\u0275inj=o.Nc({factory:function(e){return new(e||g)}});const f=new Set;let x;class v{constructor(e){this._platform=e,this._matchMedia=this._platform.isBrowser&&window.matchMedia?window.matchMedia.bind(window):k}matchMedia(e){return this._platform.WEBKIT&&function(e){if(f.has(e))return;try{x||(x=document.createElement("style"),x.setAttribute("type","text/css"),document.head.appendChild(x)),x.sheet&&(x.sheet.insertRule(`@media ${e} {.fx-query-test{ }}`,0),f.add(e))}catch(t){console.error(t)}}(e),this._matchMedia(e)}}function k(e){return{matches:"all"===e||""===e,media:e,addListener:()=>{},removeListener:()=>{}}}v.\u0275fac=function(e){return new(e||v)(o.ad(y.a))},v.\u0275prov=Object(o.Mc)({factory:function(){return new v(Object(o.ad)(y.a))},token:v,providedIn:"root"}),v.ctorParameters=()=>[{type:y.a}];class j{constructor(e,t){this._mediaMatcher=e,this._zone=t,this._queries=new Map,this._destroySubject=new a.a}ngOnDestroy(){this._destroySubject.next(),this._destroySubject.complete()}isMatched(e){return O(Object(r.a)(e)).some(e=>this._registerQuery(e).mql.matches)}observe(e){const t=O(Object(r.a)(e)).map(e=>this._registerQuery(e).observable);let n=Object(c.a)(t);return n=Object(l.a)(n.pipe(Object(d.a)(1)),n.pipe(Object(p.a)(1),Object(u.a)(0))),n.pipe(Object(m.a)(e=>{const t={matches:!1,breakpoints:{}};return e.forEach(({matches:e,query:n})=>{t.matches=t.matches||e,t.breakpoints[n]=e}),t}))}_registerQuery(e){if(this._queries.has(e))return this._queries.get(e);const t=this._mediaMatcher.matchMedia(e),n={observable:new h.a(e=>{const n=t=>this._zone.run(()=>e.next(t));return t.addListener(n),()=>{t.removeListener(n)}}).pipe(Object(b.a)(t),Object(m.a)(({matches:t})=>({query:e,matches:t})),Object(w.a)(this._destroySubject)),mql:t};return this._queries.set(e,n),n}}function O(e){return e.map(e=>e.split(",")).reduce((e,t)=>e.concat(t)).map(e=>e.trim())}j.\u0275fac=function(e){return new(e||j)(o.ad(v),o.ad(o.S))},j.\u0275prov=Object(o.Mc)({factory:function(){return new j(Object(o.ad)(v),Object(o.ad)(o.S))},token:j,providedIn:"root"}),j.ctorParameters=()=>[{type:v},{type:o.S}];var L=n("AzdY"),I=n("lnme");let z=class{constructor(e,t){this.breakpointObserver=e,this.cdr=t,this.combo="ctrl+shift+o",this._disabled="true"===localStorage.getItem("overlay-disabled"),this._query="(min-width: 959px) and (min-height: 650px)",this._buildObservable()}get query(){return this._query}set query(e){this._query=e,this._buildObservable()}set disabled(e){this._disabled=Object(r.b)(e),this.cdr.markForCheck(),localStorage.setItem("overlay-disabled",e.toString())}get disabled(){return this._disabled}get keys(){return[]}ngOnInit(){}ngOnDestroy(){}onClick(e){e.metaKey&&e.shiftKey&&(this.disabled=!0)}toggle(){this.disabled=!this.disabled}_buildObservable(){const e=Array.isArray(this.query)?this.query:[this.query];this.visible$=this.breakpointObserver.observe(e).pipe(Object(m.a)(e=>!e.matches),Object(b.a)(!this.breakpointObserver.isMatched(this.query)))}};z.ctorParameters=()=>[{type:j},{type:o.k}],z.propDecorators={combo:[{type:o.I}],query:[{type:o.I}],disabled:[{type:o.I}]},z=Object(s.a)([Object(o.n)({exportAs:"ngxResizeOverlay",selector:"ngx-resize-overlay",template:'<ngx-overlay\n  class="resize-overlay"\n  [class.visible]="!disabled && (visible$ | async)"\n  [visible]="!disabled && (visible$ | async)"\n  [zIndex]="10000"\n  (click)="onClick($event)"\n>\n  <span class="resize-overlay-content">\n    <h1><i class="ngx-icon ngx-browser-size icon-fx-dbl-sized"></i></h1>\n    <h3>Your browser is too small</h3>\n    <ng-content></ng-content>\n    <br />\n    <button class="btn btn-bordered continue" (click)="toggle()">Continue Anyway</button>\n    <a class="browser-size-popover--container">\n      <ngx-icon fontIcon="question"></ngx-icon>\n\n      <div class="browser-size-popover">\n        Bypass this warning\n        <span class="combination">\n          <span *ngFor="let key of keys; let i = index">\n            <span class="key">{{ key }}</span> <span *ngIf="i < keys.length - 1"> + </span>\n          </span>\n        </span>\n      </div>\n    </a>\n  </span>\n</ngx-overlay>\n',changeDetection:o.j.OnPush,encapsulation:o.tb.None,styles:[".resize-overlay .ngx-overlay {\n  opacity: 1 !important;\n  background-color: rgba(0, 0, 0, 0);\n  transition: background-color 500ms;\n}\n.resize-overlay .ngx-overlay .resize-overlay-content {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  position: absolute;\n  transform: translate(-50%, -50%);\n  top: 50%;\n  left: 50%;\n  font-size: 14px;\n  line-height: 17px;\n  max-width: 250px;\n  color: #cdd2dd;\n}\n.resize-overlay .ngx-overlay .resize-overlay-content h3 {\n  font-size: 18px !important;\n  line-height: 28px;\n  color: white;\n}\n.resize-overlay .ngx-overlay .resize-overlay-content .ngx-icon.ngx-browser-size {\n  color: #ff4514;\n  font-size: 46px;\n  line-height: 46px;\n}\n.resize-overlay .ngx-overlay .resize-overlay-content .ngx-icon.ngx-question {\n  color: #cdd2dd;\n  font-size: 1.5rem;\n  line-height: 1.5rem;\n  margin-top: 1rem;\n}\n.resize-overlay .ngx-overlay .resize-overlay-content .browser-size-popover {\n  opacity: 0;\n  text-align: center;\n  margin-top: 1rem;\n  line-height: 1.5rem;\n  transition: opacity 500ms;\n  background: #afb7c8;\n  color: #060709;\n  box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.2), 0 1px 1px 0 rgba(0, 0, 0, 0.14), 0 2px 1px -1px rgba(0, 0, 0, 0.12);\n  border-radius: 0;\n  font-size: 13px;\n  padding: 7px;\n}\n.resize-overlay .ngx-overlay .resize-overlay-content .browser-size-popover .combination {\n  margin-left: 5px;\n}\n.resize-overlay .ngx-overlay .resize-overlay-content .browser-size-popover .combination .key {\n  background-color: #d1d5e1;\n  border-radius: 3px;\n  padding: 3px;\n  box-shadow: 0 1px 5px 0 rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);\n}\n.resize-overlay .ngx-overlay .resize-overlay-content .browser-size-popover--container:hover .browser-size-popover {\n  opacity: 1;\n}\n.resize-overlay .ngx-overlay .resize-overlay-content .continue {\n  margin-top: 20px;\n  color: white;\n  border-color: white;\n}\n.resize-overlay.visible .ngx-overlay {\n  background-color: rgba(0, 0, 0, 0.8);\n}"]})],z);var A=n("Xgno");let C=class{};C=Object(s.a)([Object(o.N)({declarations:[L.a,z],providers:[I.a,A.a,I.a],exports:[L.a,z],imports:[i.c,g],entryComponents:[L.a,z]})],C);var S=n("1zW5"),R=n("KPRU");let T=class{};T=Object(s.a)([Object(o.u)({exportAs:"drawerContainer",selector:"[drawerContainer]",host:{"[style.position]":'"relative"',"[style.overflow]":'"hidden"'}})],T);var _=n("u47x");let M=class{};M=Object(s.a)([Object(o.N)({declarations:[S.a,T],exports:[S.a,T],providers:[R.a,A.a,I.a],imports:[i.c,C,_.a],entryComponents:[S.a]})],M)},"1zW5":function(e,t,n){"use strict";n.d(t,"a",function(){return b});var s=n("mrSG"),o=n("fXoL"),i=n("8LU1"),r=n("R0Ic");const a=[Object(r.h)("left",Object(r.i)({transform:"translateX(0%)"})),Object(r.h)("bottom",Object(r.i)({transform:"translateY(0%)"})),Object(r.j)("void => left",[Object(r.i)({transform:"translateX(100%)"}),Object(r.e)("150ms ease-out")]),Object(r.j)("left => void",[Object(r.e)("150ms ease-out",Object(r.i)({transform:"translateX(100%)"}))]),Object(r.j)("void => bottom",[Object(r.i)({transform:"translateY(100%)"}),Object(r.e)("150ms ease-out")]),Object(r.j)("bottom => void",[Object(r.e)("150ms ease-out",Object(r.i)({transform:"translateY(100%)"}))])];var c,l=n("SDw7");!function(e){e.fixed="fixed",e.absolute="absolute"}(c||(c={}));var h=n("aceb"),d=n("pD6V"),p=n("quSY"),u=n("pLZG"),m=n("lJxs");let b=class{constructor(e,t,n){this.elementRef=e,this.focusTrapFactory=t,this.mediaObserver=n,this.cssClass="",this.isRoot=!0,this.close=new o.y,this.position=c.fixed,this.screenSizeChangeSubscription=p.a.EMPTY}get size(){return this._size}set size(e){this._size=Object(i.e)(e)}get zIndex(){return this._zIndex}set zIndex(e){this._zIndex=Object(i.e)(e)}get closeOnOutsideClick(){return this._closeOnOutsideClick}set closeOnOutsideClick(e){this._closeOnOutsideClick=Object(i.b)(e)}get cssClasses(){let e="ngx-drawer "+this.cssClass;return this.isLeft&&(e+=" left-drawer"),this.isBottom&&(e+=" bottom-drawer"),e}get isLeft(){return this.direction===l.a.Left}get isBottom(){return this.direction===l.a.Bottom}ngOnInit(){this.screenSizeChangeSubscription=this.mediaObserver.asObservable().pipe(Object(u.a)(e=>e.length>0),Object(m.a)(e=>e[0])).subscribe(e=>{"xs"==e.mqAlias||"sm"==e.mqAlias?this.widthSize="100%":("md"==e.mqAlias||"lg"==e.mqAlias||"xl"==e.mqAlias)&&(this.widthSize="50%"),console.log("changeALias",e.mqAlias,this.widthSize)}),this.position=this.isRoot?c.fixed:c.absolute,this.setDimensions(this.size),this.focusTrap=this.focusTrapFactory.create(this.elementRef.nativeElement),this.focusTrap.blurPreviouslyFocusedElement(),this.focusTrap.focusInitialElementWhenReady()}ngOnDestroy(){this.screenSizeChangeSubscription.unsubscribe(),this.close.emit(!0),this.focusTrap&&this.focusTrap.restoreFocus()}setDimensions(e){this.heightSize=""+(this.isBottom&&e?e:"100%"),this.widthSize=0===e?""+(this.isLeft&&e?e:"50%"):""+(this.isLeft&&e?e:"auto")}onEscapeKey(){this.close.emit(!0)}};b.ctorParameters=()=>[{type:o.v},{type:h.k},{type:d.g}],b.propDecorators={cssClass:[{type:o.I}],direction:[{type:o.I}],template:[{type:o.I}],context:[{type:o.I}],isRoot:[{type:o.I}],size:[{type:o.I}],zIndex:[{type:o.I}],closeOnOutsideClick:[{type:o.I}],close:[{type:o.U}],onEscapeKey:[{type:o.B,args:["keyup.esc"]}]},b=Object(s.a)([Object(o.n)({exportAs:"ngxDrawer",selector:"ngx-drawer",template:'\x3c!-- <nb-layout withScroll > --\x3e\n\x3c!-- <nb-layout-column> --\x3e\n<div cdkFocusRegionStart class="ngx-drawer-content">\n  <ng-template [ngTemplateOutlet]="template" [ngTemplateOutletContext]="{ context: context, close: close }">\n  </ng-template>\n</div>\n\n\x3c!-- </nb-layout-column> --\x3e\n\n\x3c!-- </nb-layout> --\x3e',animations:[Object(r.k)("drawerTransition",a)],host:{role:"dialog",tabindex:"-1","[class]":"cssClasses","[style.width]":"widthSize","[style.height]":"heightSize","[style.zIndex]":"zIndex","[style.position]":"position","[@drawerTransition]":"direction"},encapsulation:o.tb.None,changeDetection:o.j.OnPush,styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\n.ngx-drawer {\n  display: block;\n  overflow-y: auto;\n  overflow-x: hidden;\n  text-align: left;\n  z-index: 998;\n  background: #1c2029;\n  min-width: 50%;\n  width: 50%;\n}\n.ngx-drawer.left-drawer {\n  top: var(--header-height);\n  right: 0;\n  height: 100%;\n}\n.ngx-drawer.bottom-drawer {\n  left: 0;\n  bottom: 0;\n  width: 100%;\n  max-height: calc(100vh - 4rem);\n}\n.ngx-drawer .ngx-drawer-content {\n  height: calc(100% - 4rem);\n  overflow: auto;\n}"]})],b)},AzdY:function(e,t,n){"use strict";n.d(t,"a",function(){return a});var s=n("mrSG"),o=n("R0Ic"),i=n("fXoL"),r=n("8LU1");let a=class{constructor(e){this.cdr=e,this.click=new i.y,this._visible=!1,this._zIndex=990}get visible(){return this._visible}set visible(e){this._visible=Object(r.b)(e),this.cdr.markForCheck()}get zIndex(){return this._zIndex}set zIndex(e){this._zIndex=Object(r.e)(e),this.cdr.markForCheck()}get animationState(){return this.visible?"active":"inactive"}};a.ctorParameters=()=>[{type:i.k}],a.propDecorators={visible:[{type:i.I}],zIndex:[{type:i.I}],click:[{type:i.U}]},a=Object(s.a)([Object(i.n)({exportAs:"ngxOverlay",selector:"ngx-overlay",template:'<div cdkTrapFocus cdkTrapFocusAutoCapture (click)="click.emit(true)" [style.zIndex]="zIndex" [@overlayTransition]="animationState" class="ngx-overlay">\n  <ng-content></ng-content>\n</div>\n',animations:[Object(o.k)("overlayTransition",[Object(o.h)("active",Object(o.i)({opacity:.8,visibility:"visible"})),Object(o.h)("inactive",Object(o.i)({visibility:"hidden",opacity:0})),Object(o.j)("* => active",[Object(o.e)("100ms ease-in")]),Object(o.j)("* => inactive",[Object(o.e)("100ms ease-out")]),Object(o.j)("* => void",[Object(o.i)({opacity:0,visibility:"hidden","pointer-events":"none"}),Object(o.e)("100ms ease-out")])])],encapsulation:i.tb.None,changeDetection:i.j.OnPush,styles:[".ngx-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n  width: 100%;\n  overflow: hidden;\n  height: 100%;\n  background-color: #000;\n  opacity: 0;\n  visibility: hidden;\n  text-align: center;\n  line-height: 100vh;\n}"]})],a)},KPRU:function(e,t,n){"use strict";n.d(t,"a",function(){return l});var s=n("mrSG"),o=n("fXoL"),i=n("1zW5"),r=n("lnme"),a=n("SDw7");var c=n("Xgno");let l=class extends class{constructor(e){this.injectionService=e,this.defaults={},this.components=new Map}getByType(e=this.type){return this.components.get(e)}create(e){return this.createByType(this.type,e)}createByType(e,t){const n=t.parentContainer;t=this.assignDefaults(t);const s=this.injectComponent(e,t,n);return this.register(e,s),s}destroy(e){const t=this.components.get(e.componentType);if(t&&t.length){const n=t.indexOf(e);if(n>-1){t[n].destroy(),t.splice(n,1)}}}destroyAll(){this.destroyByType(this.type)}destroyByType(e){const t=this.components.get(e);if(t&&t.length){let e=t.length-1;for(;e>=0;)this.destroy(t[e--])}}injectComponent(e,t,n){return this.injectionService.appendComponent(e,t,n)}assignDefaults(e){const t=Object.assign({},this.defaults.inputs),n=Object.assign({},this.defaults.outputs);return e.inputs||e.outputs||(e={inputs:e}),t&&(e.inputs=Object.assign(Object.assign({},t),e.inputs)),n&&(e.outputs=Object.assign(Object.assign({},n),e.outputs)),e}register(e,t){this.components.has(e)||this.components.set(e,[]);this.components.get(e).push(t)}}{constructor(e,t,n){super(e),this.injectionService=e,this.overlayService=t,this.rendererFactory=n,this.type=i.a,this.defaults={inputs:{direction:a.a.Left}},this.zIndex=995,this.size=80,this.renderer=this.rendererFactory.createRenderer(null,null)}create(e){const t=super.create(e);return this.createSubscriptions(t,e.isRoot,e.parentContainer),t}destroy(e){e&&e.instance&&(e.instance.size=0),setTimeout(()=>{this.zIndex=this.zIndex-2,this.size=this.size+10,this.overlayService.removeTriggerComponent(e),super.destroy(e)},10)}assignDefaults(e){return(e=super.assignDefaults(e)).inputs.zIndex||(this.zIndex=this.overlayService.instance?this.overlayService.instance.zIndex+3:this.zIndex+2,e.inputs.zIndex=this.zIndex),this.size=this.size-10,e.inputs.size||(e.inputs.size=this.size),e}createSubscriptions(e,t=!0,n){let s,o;t&&this.overlayService.show({triggerComponent:e,zIndex:this.zIndex});const i=t=>{e===t&&(s.unsubscribe(),o&&o.unsubscribe(),this.parentListenerFunc&&1===this.components.get(this.type).length&&this.parentListenerFunc(),this.destroy(e))};if(console.log("___"),s=e.instance.close.subscribe(i.bind(this,e)),e.instance.closeOnOutsideClick)if(t)o=this.overlayService.click.subscribe(i);else{const e=this.components.get(this.type);this.parentListenerFunc=this.renderer.listen(n,"click",t=>{t.target===n&&i(e[e.length-1])})}}};l.ctorParameters=()=>[{type:c.a},{type:r.a},{type:o.cb}],l=Object(s.a)([Object(o.F)()],l)},SDw7:function(e,t,n){"use strict";var s;n.d(t,"a",function(){return s}),function(e){e.Left="left",e.Bottom="bottom"}(s||(s={}))},lnme:function(e,t,n){"use strict";n.d(t,"a",function(){return a});var s=n("mrSG"),o=n("fXoL"),i=n("Xgno"),r=n("AzdY");let a=class{constructor(e){this.injectionService=e,this.triggerComponents=[],this.click=new o.y}get instance(){if(this.component)return this.component.instance}show(e={}){if(!e.triggerComponent)throw new Error("ngx-ui OverlayService.show: triggerComponent missing ");return this.component||(this.component=this.injectComponent(),this.instance.click.subscribe(this.onClick.bind(this))),this.triggerComponents.push({component:e.triggerComponent,zIndex:e.zIndex}),this.component.instance.visible=!0,this.updateZIndex(),this.component}hide(){0===this.triggerComponents.length&&(this.component.instance.visible=!1)}destroy(){this.component&&(this.hide(),setTimeout(()=>{this.component&&0===this.triggerComponents.length&&(this.component.destroy(),this.component=void 0)},100))}injectComponent(){return this.injectionService.appendComponent(r.a)}onClick(){if(this.triggerComponents.length>0){const e=this.triggerComponents.length-1,t=this.triggerComponents[e];this.click.emit(t.component)}}removeTriggerComponent(e){const t=this.triggerComponents.findIndex(t=>t.component===e);-1!==t&&this.triggerComponents.splice(t,1),this.updateZIndex(),0===this.triggerComponents.length&&this.destroy()}updateZIndex(){if(0===this.triggerComponents.length)return;const e=this.triggerComponents.map(e=>e.zIndex),t=Math.max(...e)-1;this.instance.zIndex=t}};a.ctorParameters=()=>[{type:i.a}],a=Object(s.a)([Object(o.F)()],a)}}]);