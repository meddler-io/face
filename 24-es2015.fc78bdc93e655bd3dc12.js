(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{rtBl:function(e,n,t){"use strict";t.r(n),t.d(n,"ToolManagementModule",function(){return De});var o=t("mrSG"),s=t("fXoL"),i=t("ofXK"),r=t("tyNb"),l=t("3Pt+"),a=t("tk/3"),c=t("l5mm"),d=t("XNiG"),h=t("NXyV"),p=t("LRne"),u=t("EY2u"),m=t("coGc"),b=t("eIep"),w=t("vkgz"),f=t("lJxs"),g=t("FQpF"),x=t("nYR2"),y=t("7qw2");const v=y.a+"api/v2",k=y.c+"api/v2/";var A;!function(e){e[e.PAUSE=0]="PAUSE",e[e.RESUME=1]="RESUME",e[e.START=2]="START",e[e.STOP=3]="STOP"}(A||(A={}));let L=class{constructor(e){this.http=e}getDelay(e){return console.log("getDelay"),Object(c.a)(e)}getLogs(e,n,t,o){let s,i=0,r=-1,l=new d.a,x=0;return Object(h.a)(()=>(t.pipe().subscribe(t=>{let d=Object(p.a)(u.a).pipe(Object(m.a)(()=>(()=>{let e=Object(c.a)(x);return x=o,e})()),Object(b.a)(t=>{let o=new a.e({"X-Id":e,"X-Lines":n.toString(),"X-Seek":i+""});return this.http.get(k+"/tool/host",{headers:o,observe:"response",responseType:"text"}).pipe(Object(w.a)(e=>{let n=e.headers.get("X-File-Range"),t=e.headers.get("X-File-Size");if(null==n||null==t)return;let o=n.split("-")[1];i=parseInt(o),r=parseInt(t)}),Object(f.a)(e=>""+e.body))}));if(t==A.RESUME)s&&s.unsubscribe(),s=d.pipe(Object(g.a)(e=>d)).subscribe(e=>{l.next(e)});else if(t==A.PAUSE)s&&(s.unsubscribe(),s=void 0);else if(t==A.STOP)return console.log("stopped"),l.complete(),void s.unsubscribe()}),l))}createTool(e){return this.http.post(v+"/tool",e)}editTool(e,n){return this.http.put(`${v}/tool/${e}`,n)}runTool(e,n){return this.http.post(`${v}/build/run/${e}`,n)}getTool(e){return this.http.get(`${v}/tool/${e}`)}getTools(){return this.http.get(v+"/tool")}createBuild(e,n){return this.http.post(`${v}/build/${e}`,n)}editBuild(e,n,t){return this.http.put(`${v}/build/${n}/${e}`,t)}updateBuildConfig(e,n){return this.http.put(`${v}/build/config/${e}`,n)}getBuild(e,n){return this.http.get(`${v}/build/${e}/${n}`)}getBuildConfig(e){return this.http.get(`${v}/build/config/${e}`)}getBuilds(e){return this.http.get(`${v}/builds/${e}`)}getBuildExecoturs(e){return this.http.get(`${v}/build/executors/${e}`)}getBuildExecutorStatus(e){return this.http.get(`${v}/build/executors/status/${e}`)}getToolImages(e){return this.http.get(`${v}/deployment/images/${e}`)}getToolImageTags(e){return this.http.get(`${v}/deployment/images/tags/${e}`)}getBuildUploadUrl(e,n){return this.http.post(v+"/build/upload/init",{id:e,filename:n})}getBuildDownloadUrl(e){return this.http.post(v+"/build/download/init",e)}uploadWithUrl(e,n){let t;const o=new FormData;console.log("file_debug",e.name),console.log("file_debug",e.size),o.append("files",e);let s=new a.e,i=this.http.put(n,e,{reportProgress:!0,observe:"events",headers:s});const r=new d.a;return i.pipe(Object(x.a)(()=>console.log("complete..."))).subscribe(e=>{if(e.type===a.d.UploadProgress){const n=Math.round(100*e.loaded/e.total);r.next({status:!1,progress:n})}else e instanceof a.f&&(r.next({status:!0,progress:100,fileData:e.body}),r.complete())}),t=r.asObservable(),t}getDeployment(e){return this.http.post(v+"/deployment/service",{deployment_id:e})}runDeployment(e){return this.http.post(v+"/deployment/run",{job_id:e})}execJob(e,n){return this.http.post(`${v}/job/exec/${e}`,n)}stopDeployment(e){return this.http.delete(v+"/deployment/service",{params:{job_id:e}})}getJobStatus(e){return this.http.get(`${v}/job/status/${e}`)}getJobs(e){return this.http.get(`${v}/jobs/${e}`)}purgeDeployment(){return this.http.delete(v+"/deployment/purge")}getDeployments(e){return this.http.get(`${v}/deployment/services/${e}`)}createDeployment(e){return this.http.post(`${v}/deployment/service/${e}`,{})}};L.ctorParameters=()=>[{type:a.b}],L=Object(o.a)([Object(s.F)({providedIn:"root"})],L);let S=class{constructor(e,n,t){this.fb=e,this.toolApiService=n,this.cdr=t,this.LOADING=!1,this.build_id="6023ed566c2cdfd6f2edb435",this.form=new l.e({id:new l.d(""),entrypoint:this.fb.array([new l.d("/bin/entrypoint")]),cmd:this.fb.array([this.fb.control("/bin/cmd")]),args:this.fb.array([this.fb.control("hello"),this.fb.control("hello")]),substitute_var:new l.d(!0),variables:new l.b([new l.e({key:new l.d("key"),value:new l.d("value")})]),success_endpoint:new l.d("http://success_endpoint.com/usr/bin/mobsf"),failure_endpoint:new l.d(""),config:new l.e({process:new l.b([new l.e({key:new l.d("key"),value:new l.d("value")})]),reserved:new l.b([new l.e({key:new l.d("key"),value:new l.d("value")})]),_reserved:new l.e({message_queue_topic:new l.d("")}),system:new l.b([new l.e({key:new l.d("key"),value:new l.d("value")})]),_process:new l.e({input_api:new l.d(""),input_api_token:new l.d(""),output_api:new l.d(""),file_upload_api:new l.d("")}),_system:new l.e({base_path:new l.d(""),input_dir:new l.d(""),output_dir:new l.d(""),results_json:new l.d(""),results_schema:new l.d(""),log_to_file:new l.d(!0),stdout_file:new l.d(""),stderr_file:new l.d(""),enable_logging:new l.d(!0),max_output_filesize:new l.d(1e3),sample_inputfile:new l.d(""),sample_outputfile:new l.d("")})})})}getArgs(){return this.form.get("args")}deleteArg(e){this.getArgs().removeAt(e)}getVariables(){return this.form.get("variables")}getConfProcess(){return this.form.get("config").get("process")}getConfSystem(){return this.form.get("config").get("system")}getConfReserved(){return this.form.get("config").get("reserved")}deleteVariables(e){this.getVariables().removeAt(e)}deleteConfProcess(e){this.getConfProcess().removeAt(e)}deleteConfSystem(e){this.getConfSystem().removeAt(e)}deleteConfReserved(e){this.getConfReserved().removeAt(e)}ngOnInit(){this.loadConfig()}addArg(){this.getArgs().push(this.fb.control(""))}addVar(){this.getVariables().push(new l.e({key:new l.d(""),value:new l.d("")}))}addConfProcess(){this.getConfProcess().push(new l.e({key:new l.d(""),value:new l.d("")}))}addSystemProcess(){this.getConfSystem().push(new l.e({key:new l.d(""),value:new l.d("")}))}addReservedProcess(){this.getConfReserved().push(new l.e({key:new l.d(""),value:new l.d("")}))}formToJson(){let e=this.form.getRawValue(),n={};e.variables.forEach(e=>{n[e.key]=e.value});let t={process:{},reserved:{},system:{}};return e.config.process.forEach(e=>{t.process[e.key]=e.value}),e.config.reserved.forEach(e=>{t.reserved[e.key]=e.value}),e.config.system.forEach(e=>{t.system[e.key]=e.value}),delete e._process,delete e._reserved,delete e._system,e.config=t,e}save(){this.toolApiService.updateBuildConfig(this.build_id,this.formToJson()).subscribe()}loadConfig(){this.LOADING=!0,this.toolApiService.getBuildConfig(this.build_id).subscribe(e=>{if(e||(e={}),e.id&&this.form.setControl("id",this.fb.control(e.id)),e.cmd){let n=[];e.cmd.forEach(e=>{n.push(this.fb.control(e))}),this.form.setControl("cmd",this.fb.array(n))}if(e.entrypoint){let n=[];e.entrypoint.forEach(e=>{n.push(this.fb.control(e))}),this.form.setControl("entrypoint",this.fb.array(n))}if(e.args){let n=[];e.args.forEach(e=>{n.push(this.fb.control(e))}),this.form.setControl("args",this.fb.array(n))}if(e.substitute_var&&this.form.setControl("substitute_var",this.fb.control(e.substitute_var)),e.success_endpoint&&this.form.setControl("success_endpoint",this.fb.control(e.success_endpoint)),e.failure_endpoint&&this.form.setControl("failure_endpoint",this.fb.control(e.failure_endpoint)),e.config){let n=[],t=[],o=[];e.config.process&&Object.keys(e.config.process).forEach(t=>{n.push(this.fb.group({key:this.fb.control(t),value:this.fb.control(e.config.process[t])}))}),e.config.system&&Object.keys(e.config.system).forEach(n=>{t.push(this.fb.group({key:this.fb.control(n),value:this.fb.control(e.config.system[n])}))}),e.config.reserved&&Object.keys(e.config.reserved).forEach(n=>{o.push(this.fb.group({key:this.fb.control(n),value:this.fb.control(e.config.reserved[n])}))});let s=this.fb.group({process:this.fb.array(n),reserved:this.fb.array(o),system:this.fb.array(t)});this.form.setControl("config",s)}this.LOADING=!1,this.cdr.markForCheck()})}};S.ctorParameters=()=>[{type:l.c},{type:L},{type:s.k}],S.propDecorators={close:[{type:s.I,args:["close"]}],refrence_id:[{type:s.I,args:["refrence_id"]}],build_id:[{type:s.I,args:["build_id"]}]},S=Object(o.a)([Object(s.n)({selector:"app-build-config",template:'<ng-container *ngIf=" LOADING == false ; else loading">\n\n\n\n  <nb-card fxFill [formGroup]="form">\n\n\n    <nb-card-header fxLayoutAlign="space-between center">\n\n      <div fxLayoutAlign="start center" fxLayout="row">\n\n        <button (click)="close.next(true)" shape="round" ghost status="basic" class="action" size="large" nbButton>\n          <nb-icon icon="arrow-back-outline">\n\n          </nb-icon>\n        </button>\n\n        <span class="subtitle text-hint lineV">\n          Build Creator\n        </span>\n\n      </div>\n\n      <button (click)="close.next(true)" shape="round" ghost status="basic" class="action" size="large" nbButton>\n        <nb-icon icon="info">\n\n        </nb-icon>\n      </button>\n\n\n    </nb-card-header>\n\n    <nb-card-body>\n\n\n\n\n\n      <div fxLayoutAlign="space-between center" fxLayout="row" fxLayoutGap="1rem">\n        <p class="subtitle text-basic">\n          Build Configuration\n        </p>\n\n        <button shape="round" ghost nbButton>\n          <nb-icon icon="info"></nb-icon>\n        </button>\n      </div>\n      <app-divider></app-divider>\n\n      \x3c!-- Identifier --\x3e\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Identifier\n          </p>\n        </div>\n\n        <div fxLayout="row" fxLayoutGap="1rem">\n          <nb-form-field fxFlex fieldSize="small">\n            <input fullWidth cdkFocusInitial formControlName="id" nbInput placeholder="/bin/watchdog">\n          </nb-form-field>\n        </div>\n      </div>\n\n      \x3c!-- Entrypoint --\x3e\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Entrypoint\n          </p>\n        </div>\n\n\n        <ng-container formArrayName="entrypoint">\n\n          <ng-container *ngFor="let entrypoint of this.form.get(\'entrypoint\').controls ; let i=index ">\n\n            <div fxLayout="row" fxLayoutGap="1rem">\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth cdkFocusInitial [formControlName]="i" nbInput placeholder="/bin/watchdog">\n              </nb-form-field>\n            </div>\n\n          </ng-container>\n        </ng-container>\n\n      </div>\n\n      <app-divider></app-divider>\n\n      \x3c!-- Command --\x3e\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Command\n          </p>\n        </div>\n\n\n\n\n        <ng-container formArrayName="cmd">\n\n          <ng-container *ngFor="let _cmd of this.form.get(\'cmd\').controls ; let i=index ">\n\n\n            \x3c!-- <div [style.marginBottom]="\'0.5rem\'" fxLayout="row" fxLayoutGap="1rem"> --\x3e\n\n            <div fxFlex  fxLayoutGap="1rem">\n              <nb-form-field  fieldSize="small">\n                <input cdkFocusInitial fullWidth [formControlName]="i" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n            </div>\n\n\n\n\n            \x3c!-- </div> --\x3e\n\n\n          </ng-container>\n\n\n        </ng-container>\n\n\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Arguments --\x3e\n      <div fxLayout="column">\n\n        <div fxLayout="row">\n          <p fxFlex class="subtitle-2 text-hint">\n            Arguments\n          </p>\n\n          <button (click)="addArg()" ghost nbButton status="danger">\n            Add\n          </button>\n\n        </div>\n\n\n        <div fxFlex>\n\n          <ng-container formArrayName="args">\n\n            <ng-container *ngFor="let arg of this.form.get(\'args\').controls ; let i=index ">\n\n\n              <div [style.marginBottom]="\'0.5rem\'" fxLayout="row" fxLayoutGap="1rem">\n                <nb-form-field fxFlex fieldSize="small">\n                  <input fullWidth cdkFocusInitial [formControlName]="i" nbInput placeholder="/usr/bin/mobsf">\n\n\n                </nb-form-field>\n\n\n                <button ghost nbSuffix nbButton (click)="deleteArg(i)">\n                  <nb-icon icon="trash-outline">\n                  </nb-icon>\n                </button>\n\n              </div>\n\n\n            </ng-container>\n\n\n          </ng-container>\n        </div>\n\n        <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'args\').controls.length" fxFlex>\n          <p class="subtitle-2 text-hint">\n            No Arguments Defined\n          </p>\n        </div>\n\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Variables --\x3e\n      <div fxLayout="column">\n\n        <div fxLayout="row">\n          <p fxFlex class="subtitle-2 text-hint">\n            Variables\n          </p>\n\n\n\n          <button (click)="addVar()" ghost nbButton status="danger">\n            Add\n          </button>\n\n\n        </div>\n\n\n        <ng-container formArrayName="variables">\n\n          <ng-container *ngFor="let variable of this.form.get(\'variables\').controls ; let i=index ">\n\n            <div [style.marginBottom]="\'0.5rem\'" [formGroupName]="i" fxLayout="row" fxLayoutGap="1rem">\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="key" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n\n\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="value" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n              <button ghost nbButton (click)="deleteVariables(i)">\n                <nb-icon icon="trash-outline">\n                </nb-icon>\n              </button>\n\n\n\n\n            </div>\n\n\n          </ng-container>\n\n\n        </ng-container>\n\n\n        <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'variables\').controls.length" fxFlex>\n          <p class="subtitle-2 text-hint">\n            No Variables Defined\n          </p>\n        </div>\n\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Substitute Variables --\x3e\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Substitute Variables\n          </p>\n        </div>\n\n        <div fxLayout="row" fxLayoutGap="1rem">\n\n          <nb-checkbox formControlName="substitute_var">Substitute Variables </nb-checkbox>\n\n        </div>\n      </div>\n\n\n      <app-divider></app-divider>\n\n\n\n\n      \x3c!-- success_endpoint --\x3e\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Success Endpoint\n          </p>\n        </div>\n\n        <div fxLayout="row" fxLayoutGap="1rem">\n          <nb-form-field fxFlex fieldSize="small">\n            <input fullWidth cdkFocusInitial formControlName="success_endpoint" nbInput\n              placeholder="http://success_endpoint.com/usr/bin/mobsf">\n          </nb-form-field>\n        </div>\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- failure_endpoint --\x3e\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Failure Endpoint\n          </p>\n        </div>\n\n        <div fxLayout="row" fxLayoutGap="1rem">\n          <nb-form-field fxFlex fieldSize="small">\n            <input fullWidth cdkFocusInitial formControlName="failure_endpoint" nbInput\n              placeholder="http://failure_endpoint.com/usr/bin/mobsf">\n          </nb-form-field>\n        </div>\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Process Env. Variables --\x3e\n      <div fxLayout="column" formGroupName="config">\n\n        <div fxLayout="row">\n          <p fxFlex class="subtitle-2 text-hint">\n            Environment Variables\n          </p>\n\n\n\n          <button (click)="addConfProcess()" ghost nbButton status="danger">\n            Add\n          </button>\n\n\n        </div>\n\n\n        <ng-container formArrayName="process">\n\n          <ng-container *ngFor="let variable of this.form.get(\'config\').get(\'process\').controls ; let i=index ">\n\n            <div [style.marginBottom]="\'0.5rem\'" [formGroupName]="i" fxLayout="row" fxLayoutGap="1rem">\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="key" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n\n\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="value" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n              <button ghost nbButton (click)="deleteConfProcess(i)">\n                <nb-icon icon="trash-outline">\n                </nb-icon>\n              </button>\n\n\n\n\n            </div>\n\n\n          </ng-container>\n\n\n        </ng-container>\n\n\n        <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'config\').get(\'process\').controls .length"\n          fxFlex>\n          <p class="subtitle-2 text-hint">\n            No Environment Variables Defined\n          </p>\n        </div>\n\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Reserved Env. Variables --\x3e\n      <div fxLayout="column" formGroupName="config">\n\n        <div fxLayout="row">\n          <p fxFlex class="subtitle-2 text-hint">\n            Reserved Environment Variables\n          </p>\n\n\n\n          <button (click)="addReservedProcess()" ghost nbButton status="danger">\n            Add\n          </button>\n\n\n        </div>\n\n\n        <ng-container formArrayName="reserved">\n\n          <ng-container *ngFor="let variable of this.form.get(\'config\').get(\'reserved\').controls ; let i=index ">\n\n            <div [style.marginBottom]="\'0.5rem\'" [formGroupName]="i" fxLayout="row" fxLayoutGap="1rem">\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="key" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n\n\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="value" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n              <button ghost nbButton (click)="deleteConfReserved(i)">\n                <nb-icon icon="trash-outline">\n                </nb-icon>\n              </button>\n\n\n\n\n            </div>\n\n\n          </ng-container>\n\n\n        </ng-container>\n\n        <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'config\').get(\'reserved\').controls .length"\n          fxFlex>\n          <p class="subtitle-2 text-hint">\n            No Reserved Variables Defined\n          </p>\n        </div>\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Systen Env. Variables --\x3e\n      <div fxLayout="column" formGroupName="config">\n\n        <div fxLayout="row">\n          <p fxFlex class="subtitle-2 text-hint">\n            Systen Environment Variables\n          </p>\n\n\n\n          <button (click)="addSystemProcess()" ghost nbButton status="danger">\n            Add\n          </button>\n\n\n        </div>\n\n\n        <ng-container formArrayName="system">\n\n          <ng-container *ngFor="let variable of this.form.get(\'config\').get(\'system\').controls ; let i=index ">\n\n            <div [style.marginBottom]="\'0.5rem\'" [formGroupName]="i" fxLayout="row" fxLayoutGap="1rem">\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="key" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n\n\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="value" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n              <button ghost nbButton (click)="deleteConfSystem(i)">\n                <nb-icon icon="trash-outline">\n                </nb-icon>\n              </button>\n\n\n\n\n            </div>\n\n\n          </ng-container>\n\n\n        </ng-container>\n\n        <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'config\').get(\'system\').controls .length"\n          fxFlex>\n          <p class="subtitle-2 text-hint">\n            No System Variables Defined\n          </p>\n        </div>\n      </div>\n\n      <app-divider></app-divider>\n\n    </nb-card-body>\n\n\n    <nb-card-footer (click)="save()">\n\n      <button class="buildBtn" fxLayoutAlign="space-between center" size="giant" status="success" filled fullWidth\n        nbButton>\n\n        <span>\n          Save\n\n        </span>\n        <nb-icon icon="play-circle"></nb-icon>\n\n      </button>\n    </nb-card-footer>\n\n  </nb-card>\n\n\n\n\n\n</ng-container>\n\n<ng-template #loading>\n  <div fxLayoutAlign="center center">\n    <ngx-progress-spinner></ngx-progress-spinner>\n  </div>\n\n</ng-template>\n',styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\nnb-card {\n  max-height: calc(100vh - 7rem);\n  margin: 0;\n}\nnb-card .container {\n  margin-top: 1rem;\n}\nnb-card textarea {\n  resize: none;\n}\n.label-text {\n  border-left: 2px var(--text-hint-color) solid !important;\n  margin-bottom: 1rem;\n  padding-left: 4px;\n}\n.subtitle {\n  margin: 0;\n  padding-left: 4px;\n}\nnb-card-header {\n  padding: 0.4rem;\n  box-shadow: 2px 2px 3px rgba(0, 0, 0, 0.16), 2px 2px 3px rgba(0, 0, 0, 0.23);\n}\nnb-card-footer {\n  padding: 0;\n}\nnb-card {\n  border: 0;\n}\n.buildBtn {\n  border-radius: 0;\n}"]})],S);var R=t("2Vo4"),C=t("5+tZ"),I=t("pLZG");let T=class{constructor(e,n){this.toolApiService=e,this.cdr=n,this.edit_mode=!1,this.build_id=void 0,this.meta_tags=new Set,this.bundke_upload_progress=new R.a({progress:20,uploading:!1}),this.buildTypes=[{name:"Docker File",id:"dockerfile",active:!0,children:[{name:"Dockerfile",id:"dockerfile",active:!0}]},{name:"Docker Image",id:"repository",active:!0,children:[{name:"Docker Hub",id:"registry_public",active:!0},{name:"Private Repository",id:"registry_private",active:!1}]},{name:"Docker Bundle",id:"repository",children:[{name:"Git Repository",id:"bundle_git",active:!0},{name:"Bundle Url",id:"bundle_url",active:!1},{name:"Upload Bundle",id:"bundle_upload",active:!0}]}],this.gitRepositories=[{name:"GitHub",id:"github"},{name:"GitLab",id:"gitlab"},{name:"Bitbucket",id:"bitbucket"},{name:"Other",id:"other"}],this.bundleType=[{name:"Zip",id:"zip"},{name:"Tar",id:"tar"}],this.config_form=new l.e({dockerfile:new l.e({authentication:new l.d("none",[]),data:new l.e({dockerfile:new l.d("Dockerfile",[l.n.required])}),auth_mode:new l.e({none:new l.e({}),credentials:new l.e({username:new l.d("",[l.n.required]),password:new l.d("",[l.n.required])}),token:new l.e({auth_token:new l.d("",[l.n.required])})})}),registry_public:new l.e({authentication:new l.d("credentials",[]),data:new l.e({image_name:new l.d("",[l.n.required]),image_tag:new l.d("",[l.n.required])}),auth_mode:new l.e({none:new l.e({}),credentials:new l.e({username:new l.d("",[l.n.required]),password:new l.d("",[l.n.required])}),token:new l.e({auth_token:new l.d("",[l.n.required])})})}),registry_private:new l.e({authentication:new l.d("credentials",[]),data:new l.e({image_name:new l.d("",[l.n.required]),image_tag:new l.d("",[l.n.required]),registry_url:new l.d("")}),auth_mode:new l.e({none:new l.e({}),credentials:new l.e({username:new l.d("",[l.n.required]),password:new l.d("",[l.n.required])}),token:new l.e({auth_token:new l.d("",[l.n.required])})})}),bundle_git:new l.e({authentication:new l.d("credentials",[]),data:new l.e({repository:new l.d("github",[l.n.required]),repository_url:new l.d("",[l.n.required,l.n.pattern("(git)?(://)(.*)(.git)(/)?")]),repository_context:new l.d("",[])}),auth_mode:new l.e({none:new l.e({}),credentials:new l.e({username:new l.d("",[l.n.required]),password:new l.d("",[l.n.required])}),token:new l.e({auth_token:new l.d("",[l.n.required])}),ssh:new l.e({ssh_key:new l.d("",[l.n.required])})})}),bundle_url:new l.e({authentication:new l.d("none",[]),data:new l.e({type:new l.d("tar"),url:new l.d("",[l.n.required])}),auth_mode:new l.e({none:new l.e({})})}),bundle_upload:new l.e({authentication:new l.d("none",[]),meta:new l.e({progress:new l.d(54)}),data:new l.e({type:new l.d("zip"),url:new l.d("",[l.n.required]),bucket:new l.d("",[l.n.required]),filename:new l.d("",[l.n.required]),identifier:new l.d("",[l.n.required]),version:new l.d("",[l.n.required])}),auth_mode:new l.e({none:new l.e({})})})}),this.form=new l.e({tool:new l.e({name:new l.d({value:"tool_name",disabled:!0},[l.n.required]),alias:new l.d({value:"tool_name",disabled:!0},[l.n.required])}),tool_name:new l.d({value:"tool_name",disabled:!0},[l.n.required]),tool_tag:new l.d({value:"tool_tag",disabled:!0},[l.n.required]),build_type:new l.d("bundle_git"),desc:new l.d("")})}onTagRemove(e){this.meta_tags.delete(e.text)}onTagAdd({value:e,input:n}){e&&this.meta_tags.add(e),n.nativeElement.value=""}ngOnInit(){this.init()}init(){this.edit_mode&&this.toolApiService.getBuild(this.refrence_id,this.build_id).subscribe(e=>{let n=e.build,t=(e.meta||{tags:[]}).tags||[];this.meta_tags=new Set(t);let o=n.type,s=e.auth,i=e.tool,r=s.mode;s=s.auth;let l=n.config;console.log("build",n),console.log("build_type",o),console.log("auth",s),console.log("auth_mode",r),console.log("config",l);let a=this.config_form.get(o);if(a){let e=a.get("data"),n=a.get("auth_mode"),t=a.get("authentication");t&&t.setValue(r),n&&(n=n.get(r),Object.keys(s).forEach(e=>{console.log("config key",e,n.get(e)),n.get(e).setValue(s[e])}),console.log("authentication_form",n)),e&&Object.keys(l).forEach(n=>{console.log("config key",n,e.get(n)),e.get(n).setValue(l[n])})}o&&this.form.get("build_type").setValue(o),i&&(i.name&&this.form.get("tool").get("name").setValue(i.name),i.alias&&this.form.get("tool").get("alias").setValue(i.alias))})}download(e){console.log("download",e),this.toolApiService.getBuildDownloadUrl(e).pipe(Object(f.a)(e=>e.url),Object(w.a)(e=>{var n=document.createElement("a");n.href=e,n.target="_blank",n.click()})).subscribe()}upload(e,n){let t={};this.toolApiService.getBuildUploadUrl("test_id",e.name).pipe(Object(f.a)(e=>(t=e,e.url))).pipe(Object(f.a)(n=>this.toolApiService.uploadWithUrl(e,n)),Object(C.b)(e=>e),Object(w.a)(e=>{this.bundke_upload_progress.next({uploading:!0,progress:e.progress})}),Object(I.a)(e=>e.status)).subscribe(e=>{this.bundke_upload_progress.next({uploading:!1,progress:0});let o=n.controls;Object.keys(t).forEach(e=>{o[e].setValue(t[e])}),console.log("controls",o),this.cdr.markForCheck()})}saveChanges(){this.edit_mode?this.editBuild():this.createBuild()}createBuild(){let e=this.form.get("build_type").value,n=this.config_form.get(e),t=n.get("authentication").value,o={auth:{auth:n.get("auth_mode").get(t).value,mode:t},build:{config:n.get("data").value,type:e},meta:{tags:Array.from(this.meta_tags.values())},refrence_id:this.refrence_id};this.toolApiService.createBuild(e,o).subscribe(e=>{console.log(e)}),console.log("config",o)}editBuild(){let e=this.form.get("build_type").value,n=this.config_form.get(e),t=n.get("authentication").value,o={auth:{auth:n.get("auth_mode").get(t).value,mode:t},build:{config:n.get("data").value,type:e},meta:{tags:Array.from(this.meta_tags.values())},refrence_id:this.refrence_id};this.toolApiService.editBuild(this.build_id,e,o).subscribe(e=>{}),console.log("config",o)}};T.ctorParameters=()=>[{type:L},{type:s.k}],T.propDecorators={edit_mode:[{type:s.I,args:["edit_mode"]}],build_id:[{type:s.I,args:["build_id"]}],close:[{type:s.I,args:["close"]}],refrence_id:[{type:s.I,args:["refrence_id"]}]},T=Object(o.a)([Object(s.n)({selector:"app-build-create",template:'\x3c!-- File:  Dockerfile --\x3e\n<ng-template #dockerfile [formGroup]="config_form">\n\n  <ng-container formGroupName="dockerfile">\n\n    <div formGroupName="data" fxLayout="column">\n\n      <div>\n        <p class="subtitle-2 text-hint">\n          Dockerfile\n        </p>\n      </div>\n\n      <div fxLayout="row" fxLayoutGap="1rem">\n\n        <nb-form-field fxFlex>\n          <textarea formControlName="dockerfile" fullWidth nbInput placeholder=" Dockerfile">\n\n          </textarea>\n\n        </nb-form-field>\n\n\n      </div>\n\n\n\n    </div>\n\n    <app-divider></app-divider>\n\n\n  </ng-container>\n\n</ng-template>\n\n\x3c!-- Image:  Docker Hub --\x3e\n<ng-template #registry_public [formGroup]="config_form">\n\n  <ng-container formGroupName="registry_public">\n\n    <div formGroupName="data" fxLayout="column">\n\n      <div>\n        <p class="subtitle-2 text-hint">\n          Docker Image\n        </p>\n      </div>\n\n      <div fxLayout="row" fxLayoutGap="1rem">\n\n        <nb-form-field>\n          <input formControlName="image_name" fullWidth nbInput placeholder="Image Name">\n\n        </nb-form-field>\n\n        <nb-form-field>\n          <input formControlName="image_tag" fullWidth nbInput placeholder="Tag Name">\n        </nb-form-field>\n      </div>\n\n\n\n    </div>\n\n    <app-divider></app-divider>\n\n    <div fxLayout="column">\n\n      <div>\n        <p class="subtitle-2 text-hint">\n          Credentials\n        </p>\n      </div>\n      <div>\n\n        <nb-select size="medium" status="primary" formControlName="authentication" filled placeholder="Authentication">\n\n          <nb-option value="none">\n            No Auth\n          </nb-option>\n          <nb-option value="credentials">\n            Credentials\n          </nb-option>\n\n\n        </nb-select>\n      </div>\n\n    </div>\n\n    <app-divider></app-divider>\n\n    <ng-container formGroupName="auth_mode">\n\n      <ng-container formGroupName="credentials"\n        *ngIf="config_form.value.registry_public.authentication == \'credentials\' ">\n\n        \x3c!-- <div class="subtitle text-hint container label-text">\n          Username\n        </div> --\x3e\n\n        <div fxLayout="row" class="container">\n          <nb-form-field>\n            <nb-icon icon="at-outline" nbPrefix></nb-icon>\n            <input formControlName="username" fullWidth nbInput placeholder="Username">\n          </nb-form-field>\n        </div>\n\n        <div fxLayout="row" class="container">\n\n          <nb-form-field>\n            <nb-icon icon="hash-outline" nbPrefix></nb-icon>\n\n            <input formControlName="password" fullWidth nbInput placeholder="Password">\n          </nb-form-field>\n        </div>\n\n      </ng-container>\n\n      <ng-container formGroupName="token" *ngIf="config_form.value.registry_public.authentication == \'token\' ">\n\n        <div fxLayout="row" class="container">\n          <nb-form-field fxFlex>\n            <textarea formControlName="auth_token" fullWidth nbInput placeholder="Auth token"></textarea>\n          </nb-form-field>\n\n        </div>\n\n      </ng-container>\n\n    </ng-container>\n\n  </ng-container>\n\n</ng-template>\n\n\n\x3c!-- Image: Private Repository --\x3e\n<ng-template #registry_private [formGroup]="config_form">\n\n  <ng-container formGroupName="registry_private">\n\n    <div formGroupName="data" fxLayout="column">\n\n\n\n      <div>\n        <p class="subtitle-2 text-hint">\n          Private Docker Registry\n        </p>\n      </div>\n\n      <div fxLayout="row" fxLayoutGap="1rem">\n\n        <nb-form-field>\n          <input formControlName="registry_url" fullWidth nbInput placeholder="Registry Url">\n\n        </nb-form-field>\n\n\n      </div>\n      <div fxLayout="row" fxLayoutGap="1rem">\n\n        <nb-form-field>\n          <input formControlName="image_name" fullWidth nbInput placeholder="Image Name">\n\n        </nb-form-field>\n\n        <nb-form-field>\n          <input formControlName="image_tag" fullWidth nbInput placeholder="Tag Name">\n        </nb-form-field>\n      </div>\n\n\n\n    </div>\n\n    <app-divider></app-divider>\n\n    <div fxLayout="column">\n\n      <div>\n        <p class="subtitle-2 text-hint">\n          Credentials\n        </p>\n      </div>\n      <div>\n\n        <nb-select size="medium" status="primary" formControlName="authentication" filled placeholder="Authentication">\n\n          <nb-option value="none">\n            No Auth\n          </nb-option>\n          <nb-option value="credentials">\n            Credentials\n          </nb-option>\n\n\n        </nb-select>\n      </div>\n\n    </div>\n\n    <app-divider></app-divider>\n\n    <ng-container formGroupName="auth_mode">\n\n      <ng-container formGroupName="credentials"\n        *ngIf="config_form.value.registry_private.authentication == \'credentials\' ">\n\n        \x3c!-- <div class="subtitle text-hint container label-text">\n          Username\n        </div> --\x3e\n\n        <div fxLayout="row" class="container">\n          <nb-form-field>\n            <nb-icon icon="at-outline" nbPrefix></nb-icon>\n            <input formControlName="username" fullWidth nbInput placeholder="Username">\n          </nb-form-field>\n        </div>\n\n        <div fxLayout="row" class="container">\n\n          <nb-form-field>\n            <nb-icon icon="hash-outline" nbPrefix></nb-icon>\n\n            <input formControlName="password" fullWidth nbInput placeholder="Password">\n          </nb-form-field>\n        </div>\n\n      </ng-container>\n\n      <ng-container formGroupName="token" *ngIf="config_form.value.registry_private.authentication == \'token\' ">\n\n        <div fxLayout="row" class="container">\n          <nb-form-field fxFlex>\n            <textarea formControlName="auth_token" fullWidth nbInput placeholder="Auth token"></textarea>\n          </nb-form-field>\n\n        </div>\n\n      </ng-container>\n\n    </ng-container>\n\n  </ng-container>\n\n</ng-template>\n\n\n\x3c!-- Bundle: Git Repository --\x3e\n<ng-template #bundle_git [formGroup]="config_form">\n\n\n  <ng-container formGroupName="bundle_git">\n\n    <div fxFlex fxLayoutGap="1rem" fxLayout="column">\n\n\n      <ng-container formGroupName="data">\n\n        <div fxLayoutAlign="start center" fxLayout="row" fxLayoutGap="1rem">\n\n\n          <div fxFlex>\n            <p class="subtitle-2 text-hint">\n              Repository\n            </p>\n          </div>\n\n          <nb-select size="small" status="primary" formControlName="repository" outline placeholder="Repository">\n\n            <nb-option *ngFor="let repo of gitRepositories" [value]="repo.id">\n              {{repo?.name}}\n            </nb-option>\n\n\n          </nb-select>\n        </div>\n\n        <div fxLayout="row">\n\n          <nb-form-field fxFlex>\n            <span nbPrefix>\n              Url\n            </span>\n\n            <input formControlName="repository_url" fullWidth nbInput placeholder="Repository URL">\n\n          </nb-form-field>\n\n\n        </div>\n\n\n        <div fxLayout="row">\n\n          <nb-form-field fxFlex>\n            <span nbPrefix>\n              file://\n            </span>\n\n            <input fieldSize="small" formControlName="repository_context" fullWidth nbInput\n              placeholder="Repository Context">\n\n          </nb-form-field>\n\n\n        </div>\n\n      </ng-container>\n\n      <div fxLayoutAlign="end center" fxLayout="row">\n\n        <nb-select size="tiny" status="danger" filled formControlName="authentication" placeholder="Authentication">\n\n          <nb-option value="none">\n            No Auth\n          </nb-option>\n          <nb-option value="credentials">\n            Credentials\n          </nb-option>\n          <nb-option value="token">\n            Auth Token\n          </nb-option>\n          <nb-option value="ssh">\n            SSH Key\n          </nb-option>\n        </nb-select>\n      </div>\n\n      <div fxLayout="row" fxLayoutGap="1rem">\n\n        <ng-container formGroupName="auth_mode">\n\n          <ng-container formGroupName="credentials"\n            *ngIf="config_form.value.bundle_git.authentication == \'credentials\' ">\n\n            \x3c!-- <div class="subtitle text-hint container label-text">\n          Username\n        </div> --\x3e\n\n\n\n            <div fxFlex>\n\n              <nb-form-field>\n                <nb-icon icon="at-outline" nbPrefix></nb-icon>\n                <input fieldSize="small" formControlName="username" nbInput placeholder="Username">\n              </nb-form-field>\n            </div>\n\n            <div fxFlex>\n\n              <nb-form-field>\n                <nb-icon icon="hash-outline" nbPrefix></nb-icon>\n\n                <input fieldSize="small" formControlName="password" nbInput placeholder="Password">\n              </nb-form-field>\n\n            </div>\n\n\n          </ng-container>\n\n          <ng-container formGroupName="token" *ngIf="config_form.value.bundle_git.authentication == \'token\' ">\n\n            <div fxFlex>\n              <nb-form-field fxFlex>\n                <textarea fieldSize="small" formControlName="auth_token" fullWidth nbInput\n                  placeholder="Auth token"></textarea>\n              </nb-form-field>\n\n            </div>\n\n          </ng-container>\n\n          <ng-container formGroupName="ssh" *ngIf="config_form.value.bundle_git.authentication == \'ssh\' ">\n\n            <div fxFlex>\n              <nb-form-field fxFlex>\n                <textarea fieldSize="small" formControlName="ssh_key" fullWidth nbInput\n                  placeholder="SSH Key"></textarea>\n              </nb-form-field>\n\n            </div>\n\n          </ng-container>\n\n        </ng-container>\n      </div>\n\n    </div>\n\n\n\n\n  </ng-container>\n\n\n</ng-template>\n\n\n\x3c!-- Bundle: Url  --\x3e\n<ng-template #bundle_url [formGroup]="config_form">\n  <ng-container formGroupName="bundle_url">\n\n\n\n\n    <div fxFlex formGroupName="data" fxLayout="column" fxLayoutGap="1rem">\n\n\n      <div fxLayout="row">\n\n\n        <nb-select size="small" status="primary" formControlName="type" filled placeholder="Repository">\n\n          <nb-option *ngFor="let bundle of bundleType" [value]="bundle.id">\n            {{bundle?.name}}\n          </nb-option>\n\n\n        </nb-select>\n\n      </div>\n\n      <div fxLayout="row">\n\n\n        <nb-form-field fxFlex>\n\n          <span nbPrefix>Url</span>\n\n          <input fieldSize="small" formControlName="url" fullWidth nbInput\n            placeholder="git://github.com/meddler-io/first-tool.git">\n\n        </nb-form-field>\n\n\n      </div>\n\n\n    </div>\n\n\n\n\n  </ng-container>\n\n\n</ng-template>\n\n\x3c!-- Bundle: Upload  --\x3e\n<ng-template #bundle_upload [formGroup]="config_form">\n\n  <ng-container formGroupName="bundle_upload">\n\n\n    <ng-container formGroupName="data">\n\n\n      <div fxLayout="column" fxLayoutGap="1rem">\n\n        <div fxLayout="row">\n\n          <nb-select size="small" status="primary" formControlName="type" filled placeholder="Repository">\n\n            <nb-option *ngFor="let bundle of bundleType" [value]="bundle.id">\n              {{bundle?.name}}\n            </nb-option>\n\n\n          </nb-select>\n\n\n        </div>\n\n\n\n\n        <div fxLayout="row" fxLayoutGap="1rem">\n          <input type="file" #file style="display: none"\n            (change)="upload( $event.target.files[0] ,  config_form.get(  \'bundle_upload\').get(\'data\') )">\n\n\n          <button *ngIf=" config_form.get(\'bundle_upload\').get(\'data\').invalid " (click)="file.click()" nbButton\n            size="small">\n            Upload\n\n          </button>\n\n          <button status="primary" [disabled]=" config_form.get(\'bundle_upload\').get(\'data\').invalid "\n            (click)="download( config_form.get(\'bundle_upload\').get(\'data\').value )" nbButton size="small">\n            Download\n\n          </button>\n\n\n          <button (click)=" config_form.get(\'bundle_upload\').get(\'data\').get(\'url\').setValue(\'\') " nbButton\n            size="small">\n            Reset\n\n          </button>\n\n        </div>\n\n        <div fxLayout="row">\n\n          <ng-container *ngIf="bundke_upload_progress | async as bundke_upload_progress">\n\n            <div fxFlex fxLayout="row">\n\n              <nb-progress-bar *ngIf="bundke_upload_progress?.uploading" size="tiny" fxFlex\n                [value]="bundke_upload_progress?.progress" status="success" [displayValue]="true">\n              </nb-progress-bar>\n            </div>\n          </ng-container>\n        </div>\n\n      </div>\n\n\n    </ng-container>\n\n\n  </ng-container>\n\n\n</ng-template>\n\n\n\n<ng-container [formGroup]="form">\n\n\n\n  <nb-card fxFill>\n\n    <nb-card-header fxLayoutAlign="space-between center">\n\n      <div fxLayoutAlign="start center" fxLayout="row">\n\n        <button (click)="close.next(true)" shape="round" ghost status="basic" class="action" size="large" nbButton>\n          <nb-icon icon="arrow-back-outline">\n\n          </nb-icon>\n        </button>\n\n        <span class="subtitle text-hint lineV">\n          Build Creator\n        </span>\n\n      </div>\n\n      <button (click)="close.next(true)" shape="round" ghost status="basic" class="action" size="large" nbButton>\n        <nb-icon icon="info">\n\n        </nb-icon>\n      </button>\n\n\n    </nb-card-header>\n\n\n    <nb-card-body>\n\n\n      <div fxLayoutAlign="space-between center" fxLayout="row" fxLayoutGap="1rem">\n        <p class="subtitle text-basic">\n          Build Info\n        </p>\n\n        <button shape="round" ghost nbButton>\n          <nb-icon icon="info"></nb-icon>\n        </button>\n      </div>\n      <app-divider></app-divider>\n\n\n      <div fxLayoutGap="1rem" fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Name\n          </p>\n        </div>\n\n        <div formGroupName="tool" fxLayout="row" fxLayoutGap="1rem">\n\n          <nb-form-field>\n\n            <input cdkFocusInitial formControlName="name" nbInput placeholder="Tool Name">\n\n          </nb-form-field>\n          <nb-form-field fieldSize="small">\n            <input formControlName="alias" nbInput placeholder="Tool tag">\n          </nb-form-field>\n        </div>\n      </div>\n\n      <app-divider></app-divider>\n\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Description\n          </p>\n        </div>\n\n        <div fxLayout="row">\n\n          <nb-form-field fxFlex>\n            <textarea formControlName="desc" fullWidth nbInput placeholder="Description"></textarea>\n          </nb-form-field>\n\n        </div>\n\n\n        <app-divider></app-divider>\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Tags\n          </p>\n        </div>\n        <div fxLayout="row">\n\n          <nb-tag-list fxFlex (tagRemove)="onTagRemove($event)">\n            <nb-tag   size="small" *ngFor="let tag of meta_tags" [text]="tag" removable></nb-tag>\n            <input type="text" nbTagInput (tagAdd)="onTagAdd($event)" fullWidth>\n            \n          </nb-tag-list>\n\n        </div>\n\n      <app-divider></app-divider>\n\n      </div>\n\n      <app-divider></app-divider>\n\n\n\n\n      <div fxLayoutAlign="space-between center" fxLayout="row" fxLayoutGap="1rem">\n        <p fxFlex class="subtitle text-basic">\n          Tools Source\n        </p>\n\n\n        <nb-select size="small" #buildTypeSelect hero [status]="  form?.value?.build_type ? \'primary\' : \'danger\' "\n          formControlName="build_type" placeholder="Select Build Type">\n          <nb-option-group *ngFor="let group of buildTypes" [title]="group.name">\n            <nb-option [disabled]="!option?.active" *ngFor="let option of group.children " [value]="option.id">\n              {{option?.name}}\n            </nb-option>\n          </nb-option-group>\n        </nb-select>\n\n\n\n      </div>\n\n      <app-divider></app-divider>\n\n\n\n\n\n      \x3c!-- <div class="subtitle text-hint container label-text">\n        Information\n      </div> --\x3e\n\n\n      <div fxLayoutAlign="space-between center" fxLayout="row" fxLayoutGap="1rem">\n\n        <ng-container [ngSwitch]="form.value.build_type">\n\n          <ng-container *ngSwitchCase="\'dockerfile\'">\n            <ng-template *ngTemplateOutlet="dockerfile"> </ng-template>\n          </ng-container>\n\n          <ng-container *ngSwitchCase="\'registry_public\'">\n            <ng-template *ngTemplateOutlet="registry_public"> </ng-template>\n          </ng-container>\n\n          <ng-container *ngSwitchCase="\'registry_private\'">\n            <ng-template *ngTemplateOutlet="registry_private"> </ng-template>\n          </ng-container>\n\n\n          <ng-container *ngSwitchCase="\'bundle_git\'">\n            <ng-template *ngTemplateOutlet="bundle_git"> </ng-template>\n          </ng-container>\n\n\n          <ng-container *ngSwitchCase="\'bundle_url\'">\n            <ng-template *ngTemplateOutlet="bundle_url"> </ng-template>\n          </ng-container>\n\n\n          <ng-container *ngSwitchCase="\'bundle_upload\'">\n            <ng-template *ngTemplateOutlet="bundle_upload"> </ng-template>\n          </ng-container>\n\n\n\n\n        </ng-container>\n\n\n      </div>\n\n    </nb-card-body>\n\n\n\n\n\n    <nb-card-footer (click)="saveChanges()">\n\n      <button [disabled]="\n\n      config_form?.get( form.get(\'build_type\').value )?.get(\'data\')?.invalid \n      ||\n      config_form?.get( form.get(\'build_type\').value )?.get(\'auth_mode\')?.get(  config_form?.get( form.get(\'build_type\').value )?.get(\'authentication\')?.value ).invalid\n\n      \n      " class="buildBtn" fxLayoutAlign="space-between center" size="giant" status="success" filled fullWidth nbButton>\n\n        <span>\n\n\n\n          Build\n        </span>\n        <nb-icon icon="play-circle"></nb-icon>\n\n      </button>\n    </nb-card-footer>\n\n  </nb-card>\n\n</ng-container>\n',changeDetection:s.j.OnPush,styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\nnb-card {\n  max-height: calc(100vh - 7rem);\n  margin: 0;\n}\nnb-card .container {\n  margin-top: 1rem;\n}\nnb-card textarea {\n  resize: none;\n}\n.label-text {\n  border-left: 2px var(--text-hint-color) solid !important;\n  margin-bottom: 1rem;\n  padding-left: 4px;\n}\n.subtitle {\n  margin: 0;\n  padding-left: 4px;\n}\nnb-card-header {\n  padding: 0.4rem;\n  box-shadow: 2px 2px 3px rgba(0, 0, 0, 0.16), 2px 2px 3px rgba(0, 0, 0, 0.23);\n}\nnb-card-footer {\n  padding: 0;\n}\nnb-card {\n  border: 0;\n}\n.buildBtn {\n  border-radius: 0;\n}"]})],T);var _=t("SDw7"),j=t("KPRU"),F=t("ZfaG");let P=class{constructor(){this.toolId=new R.a("dfault")}get ToolId(){return this.toolId.asObservable()}SetToolId(e){console.log("SetToolId"),this.toolId.next(e)}};P.ctorParameters=()=>[],P=Object(o.a)([Object(s.F)({providedIn:"root"})],P);var M=t("quSY");let z=class{constructor(e,n,t,o,s){this.toolApiService=e,this.drawerMngr=n,this.document=t,this.sharedDataService=o,this.activatedRoute=s,this.refrence_id="refrence_id",this.sharedServiceSubscription$=M.a.EMPTY,this.tabs=[]}ngOnDestroy(){this.sharedServiceSubscription$.unsubscribe()}ngOnInit(){this.sharedServiceSubscription$=this.sharedDataService.ToolId.pipe(Object(w.a)(e=>{this.refrence_id=e})).subscribe(()=>{this.loadData()})}loadData(){this.builds$=this.toolApiService.getBuilds(this.refrence_id).pipe(Object(w.a)(e=>{e.length<1&&this.openDrawer(this.buildCreateTemplate)}))}openDrawer(e,n,t=_.a.Left,o="50",s=!0,i=!0,r){n||(n={}),console.log("context",n);this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:t,template:e,size:o,context:n,closeOnOutsideClick:s,parentContainer:r,isRoot:i,zIndex:1e3,cssClass:"backdrop_color"}).onDestroy(()=>{this.document.body.classList.remove("cdk-global-scrollblock")})}openLogs(e,n,t=_.a.Left,o="50%",s=!0,i=!0,r){this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:t,template:e,size:o,closeOnOutsideClick:s,parentContainer:r,isRoot:i,zIndex:1e3,cssClass:"backdrop_color",context:{id:n}}).onDestroy(()=>{this.document.body.classList.remove("cdk-global-scrollblock")})}runTask(e){const n={TraceId:e,fprocess:"echo hello world"};this.toolApiService.runTool(e,n).subscribe(n=>{console.log(n),this.openLogs(this.logTemplate,e)})}};z.ctorParameters=()=>[{type:L},{type:j.a},{type:Document,decorators:[{type:s.D,args:[i.d]}]},{type:P},{type:r.a}],z.propDecorators={buildCreateTemplate:[{type:s.qb,args:["buildCreateTemplate",{static:!1}]}],logTemplate:[{type:s.qb,args:["logsTemplate",{static:!1}]}]},z=Object(o.a)([Object(s.n)({selector:"app-build-list",template:'<ng-container *ngIf=" builds$ | async as builds ; else loading">\n\n\n  \x3c!-- <nb-layout-header *ngIf="false" @init subHeader>\n\n\n\n    <div fxFlex fxLayout="row" fxLayoutAlign="space-between center">\n\n      <div fxLayout="row" fxLayoutAlign="start center">\n\n        <button shape="round" [routerLink]="[\'/tools\' ]" ghost status="basic" class="action" size="large" nbButton>\n          <nb-icon icon="arrow-back-outline">\n\n          </nb-icon>\n        </button>\n\n        <div class="h6 text-hint">\n\n          Builds\n\n        </div>\n      </div>\n\n\n\n      <div [style.marginRight]=" \'0.5rem\' " fxFlex fxLayout="row" fxLayoutAlign="end center">\n\n        <button (click)="openDrawer(buildCreateTemplate)" class="newBtn" shape="round" nbButton>\n\n          <div class="icon"></div>\n\n          <span>\n            Create Build\n\n          </span>\n        </button>\n\n\n      </div>\n\n    </div>\n\n  </nb-layout-header> --\x3e\n\n\n\n  <nb-accordion @init>\n    <nb-accordion-item [expanded]="index == 0" *ngFor="let build of builds  ; index as index">\n      <nb-accordion-item-header fxLayoutAlign="space-between">\n\n        <span>\n          {{ build?.name || \'Build Name\' }}\n\n        </span>\n\n        <span class="text-hint">\n          {{ \'@\' +  ( build?.tool?.alias || \'Alias\' ) }}\n        </span>\n      </nb-accordion-item-header>\n      <nb-accordion-item-body>\n\n        <nb-card>\n          <nb-card-body>\n            <div class="text-hint">\n              {{ build?.description || \'Build Description\' }}\n\n            </div>\n\n            <div class="text-hint">\n              {{ build?.doc || date }}\n\n            </div>\n\n          </nb-card-body>\n          <nb-card-footer fxLayoutGap="1rem" fxLayoutAlign="end center">\n\n            <button (click)="openDrawer(buildconfigTemplate , context =  { \'build_id\':  build?._id } )" status="basic"\n              ghost size="small" nbButton>\n\n              <nb-icon icon="file-text-outline"></nb-icon>\n              Config\n            </button>\n\n            <button (click)="openLogs(logsTemplate, build?._id)" status="basic" ghost size="small" nbButton>\n\n              <nb-icon icon="file-text-outline"></nb-icon>\n              Logs\n            </button>\n\n            <button (click)="openDrawer(logsTemplate)" status="basic" ghost size="small" nbButton>\n\n              <nb-icon icon="settings-2-outline"></nb-icon>\n              Monitor\n            </button>\n\n\n            <button status="basic" ghost size="small" nbButton>\n\n              <nb-icon icon="diagonal-arrow-left-down-outline"></nb-icon>\n              Fork\n            </button>\n\n\n\n          </nb-card-footer>\n\n          <nb-card-footer fxLayoutGap="1rem" fxLayoutAlign="end center">\n\n\n            <nb-select [style.marginRight]="\'1rem\'" [selected]="0" *ngIf="build?.executors?.length > 0"\n              placeholder="Success" size="small" status="danger" filled>\n              <nb-option status="success" *ngFor="let topic of build?.executors ; index as index" [value]="index">\n                {{topic?._id}}\n\n              </nb-option>\n\n            </nb-select>\n\n            <button\n              (click)="openDrawer(buildEditTemplate  , context =  { \'build_id\':  build?._id , \'edit_mode\': true } )"\n              status="basic" size="small" nbButton>Edit</button>\n\n            <button (click)="runTask( build?._id ) " status="primary" size="small" nbButton>Build</button>\n\n            <button (click)="runTask( build?._id ) " status="danger" size="small" nbButton>Run</button>\n          </nb-card-footer>\n        </nb-card>\n\n\n      </nb-accordion-item-body>\n    </nb-accordion-item>\n\n  </nb-accordion>\n\n\n</ng-container>\n\n\n<ng-template #loading>\n  <div fxLayoutAlign="center center">\n    <ngx-progress-spinner></ngx-progress-spinner>\n  </div>\n\n</ng-template>\n\n<ng-template #logsTemplate let-close="close" let-context="context">\n\n  <app-log-stream [close]="close" [log_id]="context?.id"></app-log-stream>\n\n\n</ng-template>\n\n<ng-template let-close="close" let-context="context" #buildEditTemplate>\n\n  <app-build-create [edit_mode]="context.edit_mode" [close]="close" [build_id]="context.build_id"\n    [refrence_id]="refrence_id"></app-build-create>\n\n</ng-template>\n\n<ng-template let-close="close" #buildCreateTemplate>\n\n  <app-build-create [close]="close" [refrence_id]="refrence_id"></app-build-create>\n\n</ng-template>\n\n\n\n\n<ng-template let-close="close" let-context="context" #buildconfigTemplate>\n\n  <app-build-config [close]="close" [build_id]="context?.build_id"></app-build-config>\n\n</ng-template>\n',changeDetection:s.j.OnPush,animations:[...F.a],styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\n:host ::ng-deep nb-route-tabset {\n  overflow-x: auto;\n  overflow-y: hidden;\n  padding-bottom: 0.2rem !important;\n  /* IE and Edge */\n  /* Firefox */\n}\n:host ::ng-deep nb-route-tabset ::-webkit-scrollbar {\n  display: none;\n}\n:host ::ng-deep nb-route-tabset .tab {\n  margin-right: 0.5rem;\n}\nnb-accordion {\n  margin: 0 !important;\n}\nnb-accordion-item {\n  margin-top: 0.4rem;\n}\nnb-accordion-item nb-accordion-item-header:hover {\n  background: var(--color-basic-700);\n  color: #fff;\n}\nnb-card {\n  margin-bottom: 0;\n  border: 0;\n}\nnb-accordion {\n  margin: 1rem;\n}\n.h6 {\n  margin-left: 1rem;\n}\nnb-accordion-item-header.accordion-item-header-expanded {\n  border-left: 2px var(--text-basic-color) solid !important;\n}\nbutton.newBtn {\n  padding: 0.3rem !important;\n  padding-left: 1rem !important;\n  padding-right: 1rem !important;\n  text-transform: capitalize !important;\n  box-shadow: 0 1px 2px 0 rgba(60, 64, 67, 0.302), 0 1px 3px 1px rgba(60, 64, 67, 0.149) !important;\n  align-items: center !important;\n  background-color: #fff !important;\n  border: 1px solid transparent;\n  border-radius: 24px;\n  color: #3c4043 !important;\n}\nbutton.newBtn span {\n  margin-right: 1rem;\n  margin-top: 0.5rem;\n  margin-bottom: 0.5rem;\n  font-weight: 600;\n}\nbutton.newBtn .icon {\n  margin-right: 1rem;\n  background-image: url(\"data:image/svg+xml;charset=UTF-8,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2236%22 height=%2236%22 viewBox=%220 0 36 36%22%3E%3Cpath fill=%22%2334A853%22 d=%22M16 16v14h4V20z%22/%3E%3Cpath fill=%22%234285F4%22 d=%22M30 16H20l-4 4h14z%22/%3E%3Cpath fill=%22%23FBBC05%22 d=%22M6 16v4h10l4-4z%22/%3E%3Cpath fill=%22%23EA4335%22 d=%22M20 16V6h-4v14z%22/%3E%3Cpath fill=%22none%22 d=%22M0 0h36v36H0z%22/%3E%3C/svg%3E\");\n  width: 2rem !important;\n  height: 2rem !important;\n}\nbutton.newBtn:hover {\n  box-shadow: 0 3px 5px 0 rgba(60, 64, 67, 0.302), 0 3px 5px 1px rgba(60, 64, 67, 0.149) !important;\n  background-color: #fff !important;\n}\n.icon {\n  background-image: url(\"data:image/svg+xml;charset=UTF-8,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2236%22 height=%2236%22 viewBox=%220 0 36 36%22%3E%3Cpath fill=%22%2334A853%22 d=%22M16 16v14h4V20z%22/%3E%3Cpath fill=%22%234285F4%22 d=%22M30 16H20l-4 4h14z%22/%3E%3Cpath fill=%22%23FBBC05%22 d=%22M6 16v4h10l4-4z%22/%3E%3Cpath fill=%22%23EA4335%22 d=%22M20 16V6h-4v14z%22/%3E%3Cpath fill=%22none%22 d=%22M0 0h36v36H0z%22/%3E%3C/svg%3E\");\n}\n.head {\n  height: 4rem;\n  background: var(--background-alternative-color-2);\n  box-shadow: 2px 2px 3px rgba(255, 255, 255, 0.16), 2px 2px 3px rgba(255, 255, 255, 0.23);\n  color: #fff;\n}\n.content {\n  height: calc(100% - 4rem);\n  overflow: auto;\n}\n.action {\n  margin-left: 5px;\n}\n.action:hover nb-icon {\n  color: var(--color-alternate-500);\n}\nnb-tab {\n  padding: 0px;\n}\nnb-card {\n  max-height: calc(100vh - 7rem);\n  margin: 0;\n}\nnb-card .container {\n  margin-top: 1rem;\n}\nnb-card textarea {\n  resize: none;\n}\nnb-card nb-card-header {\n  padding: 0.4rem;\n}"]})],z);let B=class{constructor(e,n,t,o,s,i){this.toolApiService=e,this.cdr=n,this.drawerMngr=t,this.document=o,this.activatedRoute=s,this.sharedDataService=i,this.images=[],this.sharedServiceSubscription$=M.a.EMPTY}ngOnDestroy(){this.sharedServiceSubscription$.unsubscribe()}ngOnInit(){this.sharedServiceSubscription$=this.sharedDataService.ToolId.pipe(Object(w.a)(e=>{this.tool_id=e})).subscribe(()=>{this.loadData()})}loadData(){this.toolApiService.getToolImageTags(this.tool_id).subscribe(e=>{this.images=e,this.cdr.markForCheck()})}openDrawer(e,n,t=_.a.Left,o="50%",s=!0,i=!0,r){n||(n={}),console.log("context",n);this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:t,template:e,context:n,closeOnOutsideClick:s,parentContainer:r,isRoot:i,zIndex:1e3,cssClass:"backdrop_color"}).onDestroy(()=>{this.document.body.classList.remove("cdk-global-scrollblock")})}deploy(e){this.toolApiService.createDeployment(e).subscribe(e=>{console.log(e)})}};B.ctorParameters=()=>[{type:L},{type:s.k},{type:j.a},{type:Document,decorators:[{type:s.D,args:[i.d]}]},{type:r.a},{type:P}],B.propDecorators={tool_id:[{type:s.I,args:["tool_id"]}]},B=Object(o.a)([Object(s.n)({selector:"app-built-image-list",template:'<nb-accordion>\n  <nb-accordion-item [expanded]="index == 0" *ngFor="let build of images  ; index as index">\n    <nb-accordion-item-header fxLayoutAlign="space-between">\n\n      <span>\n        {{ build?.name || \'Build Name\' }}\n\n      </span>\n\n      <span class="text-hint">\n        {{ \'@\' +  ( build?.tool?.alias || \'Alias\' ) }}\n      </span>\n    </nb-accordion-item-header>\n    <nb-accordion-item-body>\n\n      <nb-card>\n        <nb-card-body>\n          <div class="text-hint">\n            {{ build?.description || \'Build Description\' }}\n\n          </div>\n\n          <div class="text-hint">\n            {{ build?.doc || date }}\n\n          </div>\n\n        </nb-card-body>\n        <nb-card-footer fxLayoutGap="1rem" fxLayoutAlign="end center">\n\n          <button (click)="openDrawer(buildconfigTemplate , context =  { \'build_id\':  build?._id } )" status="basic"\n            ghost size="small" nbButton>\n\n            <nb-icon icon="file-text-outline"></nb-icon>\n            Config\n          </button>\n\n          <button (click)="openDrawer(logsTemplate, context = {\n            \'id\': build?._id\n\n          }  )" status="basic" ghost size="small" nbButton>\n\n            <nb-icon icon="file-text-outline"></nb-icon>\n            Logs\n          </button>\n\n\n\n\n\n\n        </nb-card-footer>\n\n        <nb-card-footer fxLayoutGap="1rem" fxLayoutAlign="end center">\n\n\n          <nb-select [style.marginRight]="\'1rem\'" [selected]="0" *ngIf="build?.executors?.length > 0"\n            placeholder="Success" size="small" status="danger" filled>\n            <nb-option status="success" *ngFor="let topic of build?.executors ; index as index" [value]="index">\n              {{topic?._id}}\n\n            </nb-option>\n\n          </nb-select>\n\n          <button (click)="openDrawer(buildEditTemplate  , context =  { \'build_id\':  build?._id , \'edit_mode\': true } )"\n            status="basic" size="small" nbButton>Edit</button>\n\n          <button (click)="runTask( build?._id ) " status="primary" size="small" nbButton>Build</button>\n\n          <button (click)="deploy( build?._id ) " status="danger" size="small" nbButton>Deploy</button>\n        </nb-card-footer>\n      </nb-card>\n\n\n    </nb-accordion-item-body>\n  </nb-accordion-item>\n\n</nb-accordion>\n\n<ng-template #logsTemplate let-close="close" let-context="context">\n\n  <app-log-stream [close]="close" [deep_link]="true" [log_id]="context?.id"></app-log-stream>\n\n\n</ng-template>\n\n\n\n<ng-container #loading *ngIf="!images || images.length == 0">\n  <div fxLayoutAlign="center center">\n    <ngx-progress-spinner></ngx-progress-spinner>\n  </div>\n\n</ng-container>\n',styles:[""]})],B);let O=class{constructor(e,n,t,o,s,i){this.toolApiService=e,this.drawerMngr=n,this.document=t,this.activatedRoute=o,this.cdr=s,this.sharedDataService=i,this.sharedServiceSubscription$=M.a.EMPTY}ngOnDestroy(){this.sharedServiceSubscription$.unsubscribe()}ngOnInit(){this.sharedServiceSubscription$=this.sharedDataService.ToolId.pipe(Object(w.a)(e=>{this.tool_id=e})).subscribe(()=>{this.loadData()})}loadData(){console.log("ngOnInit"),this.toolApiService.getDeployments(this.tool_id).pipe(Object(f.a)(e=>{let n=[];return e.forEach((e,t)=>{let o=e,s={id:o,details:this.toolApiService.getDeployment(o)};n.push(s)}),n})).subscribe(e=>{this.deployments=e,this.cdr.markForCheck()})}deploy(){this.toolApiService.createDeployment("123").subscribe()}stopJob(e){this.toolApiService.stopDeployment(e).subscribe()}purge(){this.toolApiService.purgeDeployment().subscribe()}runJob(e){console.log("runJob",e)}execJob(e){this.toolApiService.execJob(e,{}).subscribe()}openDrawer(e,n,t=_.a.Left,o="50",s=!0,i=!0,r){n||(n={}),console.log("context",n);this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:t,template:e,size:o,context:n,closeOnOutsideClick:s,parentContainer:r,isRoot:i,zIndex:1e3,cssClass:"backdrop_color"}).onDestroy(()=>{this.document.body.classList.remove("cdk-global-scrollblock")})}};O.ctorParameters=()=>[{type:L},{type:j.a},{type:Document,decorators:[{type:s.D,args:[i.d]}]},{type:r.a},{type:s.k},{type:P}],O.propDecorators={tool_id:[{type:s.I,args:["tool_id"]}]},O=Object(o.a)([Object(s.n)({selector:"app-deployment-ui",template:'<div fxLayout="column">\n  <ng-container *ngFor="let deploy of deployments  ; index as index">\n\n    <nb-card *ngIf="deploy.details | async as details">\n      <nb-card-header>\n        \x3c!-- Name --\x3e\n        <div class="row">\n          <div fxFlex class="text-hint">\n\n            @{{ details?.Name  }}\n\n          </div>\n          <div fxFlex class="subtitle-2">\n            {{details?.Status}}\n\n\n            \x3c!-- @{{ details?.BuildDetails | json  }} --\x3e\n\n\n          </div>\n        </div>\n\n      </nb-card-header>\n\n      <nb-card-body>\n\n\n        \x3c!-- Namespace --\x3e\n        <div class="row">\n          <div fxFlex class="subtitle">\n            Namespace\n\n          </div>\n          <div fxFlex class="subtitle-2">\n            {{ details?.Namespace  }}\n\n          </div>\n        </div>\n\n\n\n        \x3c!-- Status --\x3e\n        <div class="row">\n          <div fxFlex class="subtitle">\n            Status\n\n          </div>\n          <div fxFlex class="subtitle-2">\n            {{ details?.Status  }}\n\n          </div>\n        </div>\n\n\n        \x3c!-- Submitted On --\x3e\n        <div class="row">\n          <div fxFlex class="subtitle">\n            SubmitTime\n\n          </div>\n          <div fxFlex class="subtitle-2">\n            {{ details?.SubmitTime / 1000000  | date:"dd-MM-YY , HH:mm:ss" }}\n\n          </div>\n        </div>\n\n\n\n\n\n      </nb-card-body>\n\n\n      <nb-card-footer fxLayoutGap="1rem" fxLayoutAlign="start">\n\n\n        <button (click)="purge(  )" status="primary" ghost size="small" nbButton>\n\n          <nb-icon icon="settings-2-outline"></nb-icon>\n          Purge\n        </button>\n\n\n        <button (click)="execJob( deploy?.id )" status="primary" ghost size="small" nbButton>\n\n          <nb-icon icon="settings-2-outline"></nb-icon>\n          Exec\n        </button>\n\n        <button (click)="openDrawer(jobConfigTemplate , context =  { config: details?.JobConfig , id : deploy?.id }  ) "\n          status="success" ghost size="small" nbButton>\n\n          <nb-icon icon="settings-2-outline"></nb-icon>\n          Run\n        </button>\n\n\n        <button (click)="stopJob( deploy?.id )" status="basic" ghost size="small" nbButton>\n\n          <nb-icon icon="settings-2-outline"></nb-icon>\n          Stop\n        </button>\n\n        <button (click)="openDrawer(logsTemplate)" status="danger" ghost size="small" nbButton>\n\n          <nb-icon icon="settings-2-outline"></nb-icon>\n          Logs\n        </button>\n\n\n        <button status="basic" ghost size="small" nbButton>\n\n          <nb-icon icon="diagonal-arrow-left-down-outline"></nb-icon>\n\n          {{details?.Status}}\n        </button>\n\n\n\n      </nb-card-footer>\n    </nb-card>\n  </ng-container>\n\n</div>\n\n\n<ng-template #logsTemplate let-close="close" let-context="context">\n\n  <app-log-stream [close]="close" [deep_link]="true" [log_id]="context?.id"></app-log-stream>\n\n</ng-template>\n\n\n<ng-template let-close="close" let-context="context" #jobConfigTemplate>\n\n  <app-job-config [config]="context?.config" [id]="context?.id"></app-job-config>\n\n</ng-template>\n\n\n<ng-container #loading *ngIf="!deployments || deployments.length == 0">\n  <div fxLayoutAlign="center center">\n    <ngx-progress-spinner></ngx-progress-spinner>\n  </div>\n\n</ng-container>\n',styles:["nb-card-footer {\n  padding: 0.3rem;\n  overflow-x: scroll;\n  overflow-y: hidden;\n}"]})],O);var D,W=t("G1Gu"),E=t("3E0/"),G=t("/d8p"),N=t("1G5W");!function(e){e.IMAGE_BUILDER="image_builder",e.JOB="job"}(D||(D={}));let $=class{constructor(e,n){this.toolApiService=e,this.cdr=n,this.logSource=D.IMAGE_BUILDER,this.LOG_STREAM_STATUS$=A,this.testLogs="",this.deep_link=!1,this.log_id="npop3",this.topic=void 0,this.topics_=[],this.build_list=[],this.tailing=!0,this.streaming=!0,this.pollJobStatusSubscription$=M.a.EMPTY,this.scrollSubscruption=M.a.EMPTY}ngOnDestroy(){console.log("unsubscribe"),this.topic.subscription.unsubscribe(),this.topic.pauseStreamer$.next(A.STOP),this.pollJobStatusSubscription$.unsubscribe()}toggleTail(e){1==e?this.resumeKeepAtBottom():this.pauseKeepAtBottom()}toggleStreamingLogs(e,n){e?this.pause(n):this.resume(e)}getSource(e){switch(console.log("logsource",this.logSource),this.logSource){case D.IMAGE_BUILDER:return this.toolApiService.getBuildExecutorStatus(e);case D.JOB:return this.toolApiService.getJobStatus(e);default:return this.toolApiService.getBuildExecutorStatus(e)}}pollJobStatus(e){let n=new d.a;this.pollJobStatusSubscription$.unsubscribe(),this.pollJobStatusSubscription$=this.getSource(e).pipe(Object(w.a)(e=>{0==e.poll_again&&n.next(""),this.STATUS=e.exec_status,console.log("tap_1",e)}),Object(E.a)(1e3),Object(G.a)(),Object(N.a)(n)).subscribe(e=>{})}ngOnInit(){1==this.deep_link?this.deepLinkLoadLog():this.getExecutors(this.log_id)}deepLinkLoadLog(){console.log("deep_link"),this.topic={log_id:this.log_id,exec_status:"SUCCESS",title:"val['_id']",desc:"Dummy Description",loaded:!1,initiated:!1,collapsed:!0,loading:new d.a,content:[],content$:new d.a,pauseStreamer$:new R.a(A.RESUME),subscription:M.a.EMPTY},this.streamLogs(0,!0),this.pollJobStatus(this.topic.log_id)}resumeKeepAtBottom(){this.scrollSubscruption.unsubscribe(),this.scrollSubscruption=Object(c.a)(300).subscribe(e=>{this.scrollbarRef.scrollTo({bottom:0,duration:150})})}pauseKeepAtBottom(){this.scrollSubscruption.unsubscribe(),this.scrollbarRef.scrollTo({bottom:0,duration:0})}streamLogs(e,n){this.topic&&this.topic.loaded||(console.log(this.topic),this.topic.loading.next(!0),this.topic.subscription=this.toolApiService.getLogs(this.topic.log_id,200,this.topic.pauseStreamer$,y.d).pipe(Object(w.a)(e=>{this.topic.initiated=!0})).subscribe(e=>{this.topic.loaded=!0,this.topic.loading.next(!1),null!=e&&null!=e&&0!=e.length&&(this.topic.content.push(e),console.log("log loaded"),this.cdr.markForCheck())},e=>{console.log("error",e)},()=>{console.log("completed"),this.topic.pauseStreamer$.next(A.STOP),this.cdr.markForCheck()}))}getStatus(){}collapsedChange(e,n,t=!1){n||this.streamLogs(e,t)}onSelectionChange(e){this.topic&&(console.log("onSelectioChange",e),this.topic.subscription.unsubscribe(),this.topic.pauseStreamer$.next(A.STOP),this.topic.content$.complete()),this.topic={log_id:this.build_list[e].log_id,exec_status:this.build_list[e].exec_status,title:"val['_id']",desc:"Dummy Description",loaded:!1,initiated:!1,collapsed:!0,loading:new d.a,content:[],content$:new d.a,pauseStreamer$:new R.a(A.RESUME),subscription:M.a.EMPTY},this.streamLogs(e,!1),this.pollJobStatus(this.topic.log_id),console.log("this.topic",this.topic)}getExecutors(e){this.toolApiService.getBuildExecoturs(e).subscribe(e=>{e.forEach((e,n)=>{this.build_list.push({log_id:e._id,title:e._id,exec_status:e.exec_status,desc:"Dummy Description",loaded:!1,initiated:!1,collapsed:!0}),this.cdr.markForCheck(),0==n&&this.onSelectionChange(n)})})}pause(e){this.topic.pauseStreamer$.next(A.PAUSE),this.cdr.markForCheck()}resume(e){this.topic.pauseStreamer$.next(A.RESUME),this.cdr.markForCheck()}};$.ctorParameters=()=>[{type:L},{type:s.k}],$.propDecorators={logSource:[{type:s.I,args:["logsource"]}],close:[{type:s.I,args:["close"]}],deep_link:[{type:s.I,args:["deep_link"]}],log_id:[{type:s.I,args:["log_id"]}],scrollbarRef:[{type:s.qb,args:[W.a,{static:!1}]}]},$=Object(o.a)([Object(s.n)({selector:"app-log-stream",template:'<nb-card fxFill >\n\n\n  <nb-card-header fxLayoutAlign="space-between center">\n\n    <div fxLayout="row" fxLayoutAlign="start center">\n      <button (click)="close.emit(true)" ghost status="basic" class="action" size="giant" nbButton>\n        <nb-icon class="text-alternate" icon="arrow-back-outline">\n        </nb-icon>\n      </button>\n\n      <div fxFlex>\n\n\n        <div fxLayout="column">\n          <div fxFlex class="subtitle text-alternate">\n            Logs  {{logsource | json}} {{STATUS}} \n          </div>\n          <div class="overflowFix">\n\n\n            <nb-select [style.marginRight]="\'1rem\'" (selectedChange)="onSelectionChange($event)" [selected]="0"\n              *ngIf="build_list.length > 0" placeholder="Success" size="tiny" status="danger" filled>\n              <nb-option *ngFor="let topic of build_list ; index as index" [value]="index">{{topic?.log_id}}\n              </nb-option>\n\n            </nb-select>\n          </div>\n        </div>\n      </div>\n\n\n\n    </div>\n\n\n  </nb-card-header>\n\n  <nb-card-body fxLayoutAlign="center center" fxLayout="column" class="content log-container">\n\n\n\n\n\n\n\n\n\n\n    <ng-template #logTemplate let-topic="topic">\n\n      <ng-container>\n\n        <div fxFill fxLayout="column" class="log-container">\n\n\n          <div fxFlexAlign="center" *ngIf=" topic?.content == undefined ||  topic?.content?.length < 1"\n            fxLayoutAlign="center center">\n            <ngx-progress-spinner></ngx-progress-spinner>\n          </div>\n\n\n\n\n\n\n          <ng-scrollbar [style.pointerEvents]=" tailing ? \'none\' : \'all\' " track="vertical" [scrollAuditTime]="20">\n\n            <div fxFlex>\n\n\n              <div class="code">\n\n                <div *ngFor="let content of topic?.content">\n                  <code fxFlex>\n                    <pre [innerText]="content">   </pre>\n                  </code>\n                </div>\n              </div>\n\n\n\n\n            </div>\n\n\n          </ng-scrollbar>\n\n\n\n\n\n        </div>\n\n\n      </ng-container>\n\n\n    </ng-template>\n\n\n\n    <ng-container *ngIf="topic">\n      <ng-container *ngTemplateOutlet="logTemplate; context: { \'topic\': topic } ">\n      </ng-container>\n    </ng-container>\n\n\n\n\n\n\n  </nb-card-body>\n\n\n  <nb-card-footer fxLayoutAlign="start center" (click)="save()">\n\n\n    <div class="overlay-button">\n\n      <ng-template #actionBtns let-status="pauseStatus">\n\n        <div class="row" fxFlex fxLayoutAlign="center center" fxLayoutGap="1rem">\n\n\n          <nb-button-group size="small" shape="round" multiple>\n\n            <button hero status="danger" (click)="toggleStreamingLogs($event)" nbButtonToggle size="small">\n              <nb-icon icon="pause-circle">\n              </nb-icon>\n\n              {{  ( status == LOG_STREAM_STATUS$.PAUSE   )  ? \'Resume\' : \'Pause\'  }}\n\n            </button>\n\n\n\n            <button [(pressed)]="tailing" (pressedChange)="toggleTail($event)" nbButtonToggle size="small">\n              <nb-icon icon="arrowhead-down-outline"></nb-icon>\n              Follow\n            </button>\n          </nb-button-group>\n        </div>\n      </ng-template>\n\n      <ng-container *ngTemplateOutlet="actionBtns; context:{pauseStatus: topic?.pauseStreamer$ | async }">\n      </ng-container>\n    </div>\n\n  </nb-card-footer>\n\n</nb-card>\n',changeDetection:s.j.OnPush,styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\nnb-card {\n  max-height: calc(100vh - 7rem);\n  margin: 0;\n}\nnb-card .container {\n  margin-top: 1rem;\n}\nnb-card textarea {\n  resize: none;\n}\nnb-card-header {\n  padding: 0.4rem;\n  background: var(--background-alternative-color-2);\n  box-shadow: 2px 2px 3px rgba(255, 255, 255, 0.16), 2px 2px 3px rgba(255, 255, 255, 0.23);\n  border: 0em;\n  color: #fff;\n}\nnb-card-footer {\n  padding: 0.3rem;\n  background: var(--background-alternative-color-2);\n  border: 0em;\n}\n.subtitle {\n  color: #a4b1cd !important;\n  font-weight: 600;\n  line-height: 1rem;\n  font-size: 1rem;\n}\nnb-card {\n  border: 0;\n}\nnb-card-body {\n  border: 0;\n  padding: 0rem;\n}\n.buildBtn {\n  border-radius: 0;\n}\n.log-container {\n  background: var(--background-alternative-color-1);\n  color: var(--text-alternate-color);\n}\n.log-container .ng-trigger-accordionItemBody {\n  margin-left: 1rem;\n  margin-right: 1rem;\n  margin-top: 0.5rem;\n  margin-bottom: 0.5rem;\n}\n.log-container pre {\n  margin: 0;\n}\n.overlay-button {\n  position: -webkit-sticky;\n  position: sticky;\n  bottom: 1rem;\n  right: 1rem;\n}\n:host ::ng-deep nb-accordion nb-accordion-item nb-accordion-item-header:hover {\n  background: var(--background-alternative-color-1);\n  color: var(--text-alternate-color);\n}\n:host ::ng-deep nb-accordion nb-accordion-item nb-accordion-item-header.accordion-item-header-expanded {\n  background: var(--background-alternative-color-2);\n  color: var(--text-alternate-color);\n}\n:host ::ng-deep nb-accordion nb-accordion-item nb-accordion-item-body.marginBody {\n  overflow: scroll;\n  background: var(--background-alternative-color-1);\n  color: var(--text-alternate-color);\n}\n:host ::ng-deep nb-accordion nb-accordion-item nb-accordion-item-body.marginBody .ng-trigger-accordionItemBody {\n  margin-left: 1rem;\n  margin-right: 1rem;\n  margin-top: 0.5rem;\n  margin-bottom: 0.5rem;\n}\n:host ::ng-deep nb-accordion nb-accordion-item nb-accordion-item-body.marginBody pre {\n  margin: 0;\n}\n.head {\n  height: 4rem;\n  background: var(--background-alternative-color-2);\n  box-shadow: 2px 2px 3px rgba(255, 255, 255, 0.16), 2px 2px 3px rgba(255, 255, 255, 0.23);\n  color: #fff;\n}\n.content {\n  height: calc(100% - 4rem);\n}\n.action {\n  margin-left: 5px;\n}\n.action:hover nb-icon {\n  color: var(--color-alternate-500);\n}\n.code {\n  padding: 1rem;\n}\n.overflowFix {\n  overflow: auto;\n}"]})],$);let q=class{constructor(e,n,t,o,s){this.toolApiService=e,this.sharedDataService=n,this.cdr=t,this.document=o,this.drawerMngr=s}ngOnInit(){this.jobs=this.sharedDataService.ToolId.pipe(Object(f.a)(e=>this.toolApiService.getJobs(e)),Object(C.b)(e=>e))}openDrawer(e,n,t=_.a.Left,o="50%",s=!0,i=!0,r){n||(n={}),n.logsource=D.JOB,console.log("context",n);this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:t,template:e,context:n,closeOnOutsideClick:s,parentContainer:r,isRoot:i,zIndex:1e3,cssClass:"backdrop_color"}).onDestroy(()=>{this.document.body.classList.remove("cdk-global-scrollblock")})}};q.ctorParameters=()=>[{type:L},{type:P},{type:s.k},{type:Document,decorators:[{type:s.D,args:[i.d]}]},{type:j.a}],q=Object(o.a)([Object(s.n)({selector:"app-job-list",template:'<nb-accordion>\n  <nb-accordion-item *ngFor="let job of jobs | async ;  let i=index  ">\n\n    <nb-accordion-item-header fxLayoutAlign="space-between">\n\n      <span>\n\n        Job {{i + 1}}\n        {{ job | json }}\n\n      </span>\n\n      <span class="text-hint">\n        {{ \'@\' +  ( job?.exec_status || \'Unknown\' ) }}\n      </span>\n    </nb-accordion-item-header>\n    <nb-accordion-item-body>\n\n\n      <button [routerLink]="[ \'/jobs\' , \'job\' , job?._id ]" status="basic" filled size="small" nbButton>\n\n        <nb-icon icon="file-text-outline"></nb-icon>\n        Details\n      </button>\n\n      <button (click)="openDrawer(logsTemplate, context = {\n        \'id\': job?._id\n\n      }  )" status="basic" filled size="small" nbButton>\n\n        <nb-icon icon="file-text-outline"></nb-icon>\n        Logs\n      </button>\n\n    </nb-accordion-item-body>\n  </nb-accordion-item>\n</nb-accordion>\n\n\n<ng-template #logsTemplate let-close="close" let-context="context">\n\n\n  <app-log-stream [logsource]="context?.logsource" [close]="close" [deep_link]="true" [log_id]="context?.id">\n  </app-log-stream>\n\n\n</ng-template>\n',styles:[""]})],q);let V=class{constructor(e,n,t,o,s){this.toolApiService=e,this.drawerMngr=n,this.document=t,this.activatedRoute=o,this.sharedDataService=s,this.tabs=[],this.refrence_id="refrence_id"}ngOnInit(){this.activatedRoute.params.pipe(Object(f.a)(e=>e.id)).pipe(Object(I.a)(e=>e)).pipe(Object(w.a)(e=>{this.refrence_id=e,this.sharedDataService.SetToolId(e),this.tabs=[{title:"Deployments",route:[{outlets:{view:"deployments"}}],responsive:!0},{title:"Images",route:[{outlets:{view:"images"}}],responsive:!0},{title:"Builds",route:[{outlets:{view:"builds"}}],responsive:!0},{title:"Jobs",route:[{outlets:{view:"jobs"}}],responsive:!0}]})).subscribe(e=>{this.builds$=this.toolApiService.getBuilds(e).pipe(Object(w.a)(e=>{e.length<1&&this.openDrawer(this.buildCreateTemplate)}))})}openDrawer(e,n,t=_.a.Left,o="50",s=!0,i=!0,r){n||(n={}),console.log("context",n);this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:t,template:e,size:o,context:n,closeOnOutsideClick:s,parentContainer:r,isRoot:i,zIndex:1e3,cssClass:"backdrop_color"}).onDestroy(()=>{this.document.body.classList.remove("cdk-global-scrollblock")})}openLogs(e,n,t=_.a.Left,o="50%",s=!0,i=!0,r){this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:t,template:e,size:o,closeOnOutsideClick:s,parentContainer:r,isRoot:i,zIndex:1e3,cssClass:"backdrop_color",context:{id:n}}).onDestroy(()=>{this.document.body.classList.remove("cdk-global-scrollblock")})}};V.ctorParameters=()=>[{type:L},{type:j.a},{type:Document,decorators:[{type:s.D,args:[i.d]}]},{type:r.a},{type:P}],V.propDecorators={buildCreateTemplate:[{type:s.qb,args:["buildCreateTemplate",{static:!1}]}],logTemplate:[{type:s.qb,args:["logsTemplate",{static:!1}]}]},V=Object(o.a)([Object(s.n)({selector:"app-tool-explore",template:'<nb-card fxFill>\n\n  <nb-card-header>\n\n    <div fxLayout="row">\n\n      <button shape="round" [routerLink]="[\'/tools\' ]" ghost status="basic" class="action" size="large" nbButton>\n        <nb-icon icon="arrow-back-outline">\n        </nb-icon>\n      </button>\n      <nb-route-tabset fxFlex [tabs]="tabs"></nb-route-tabset>\n\n\n    </div>\n\n\n  </nb-card-header>\n\n\n  <nb-card-body>\n\n\n    <router-outlet name="view">\n\n    </router-outlet>\n  </nb-card-body>\n\n</nb-card>\n',styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\n.head {\n  height: 4rem;\n  background: var(--background-alternative-color-2);\n  box-shadow: 2px 2px 3px rgba(255, 255, 255, 0.16), 2px 2px 3px rgba(255, 255, 255, 0.23);\n  color: #fff;\n}\n.content {\n  height: calc(100% - 4rem);\n  overflow: auto;\n}\n.action {\n  margin-left: 5px;\n}\n.action:hover nb-icon {\n  color: var(--color-alternate-500);\n}\nnb-tab {\n  padding: 0px;\n}\nnb-card {\n  max-height: calc(100vh - 7rem);\n  margin: 0;\n}\nnb-card .container {\n  margin-top: 1rem;\n}\nnb-card textarea {\n  resize: none;\n}\nnb-card nb-card-header {\n  padding: 0.4rem;\n}"]})],V);var U;!function(e){e.HOST="host",e.DOMAIN="domain",e.ANDROID="android",e.IOS="ios",e.WEB="web",e.REPOSITORY="repository",e.DOCKER="docker"}(U||(U={}));const J="host",H="host_configure",Y="domain",K="domain_configure",X="web",Q="web_create",Z="web_configure";let ee=class{constructor(){}get getToolMenu(){return[{name:"Tools",icon:"eva-arrow-left",type:U.HOST,link:["/tool","host","import"],id:J,path:["/tool/host"],children:[{name:"Create Tool",icon:"external-link-outline",link:["/tool","host","import"],id:J},{name:"Configure",icon:"external-link-outline",link:["/tool","host","configure"],id:H}]},{name:"Data Sources",type:U.DOMAIN,link:["/tool","domain","add"],path:["/tool/domain"],id:Y,children:[{name:"Create",icon:"plus-circle-outline",link:["/tool","domain","add"],id:Y},{name:"Manage",icon:"external-link-outline",link:["/tool","domain","configure"],id:K}]},{name:"Plugin Store",type:U.WEB,link:["/tool","web","add"],id:X,path:["/tool/web"],children:[{name:"Create",icon:"plus-circle-outline",link:["/tool","web","add"],id:X},{name:"Import",icon:"external-link-outline",link:["/tool","web","import"],id:Q},{name:"Configure",icon:"external-link-outline",link:["/tool","web","configure"],id:Z}]}]}};ee.ctorParameters=()=>[],ee=Object(o.a)([Object(s.F)({providedIn:"root"})],ee);var ne=t("aceb");let te=class{constructor(e,n,t,o,s){this.toolStoreService=e,this.dialogService=n,this.toolApiService=t,this.drawerMngr=o,this.document=s,this.tabs=[{title:"Logs",route:[{}]},{title:"Result",route:[{}]},{title:"Deployments",route:[]}],this.testLogs="",this.readOnly=!1,this.mode="markdown",this.options={mode:this.mode},this.toolMenu=this.toolStoreService.getToolMenu,this.tools$=this.toolApiService.getTools()}ngOnInit(){}open(e){this.dialogService.open(e,{dialogClass:"test",closeOnBackdropClick:!1,context:"this is some additional data passed to dialog"})}openDrawer(e,n,t=_.a.Left,o="50%",s=!0,i=!0,r){n||(n={}),console.log("context",n);this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:t,template:e,context:n,closeOnOutsideClick:s,parentContainer:r,isRoot:i,zIndex:1e3,cssClass:"backdrop_color"}).onDestroy(()=>{this.document.body.classList.remove("cdk-global-scrollblock")})}};te.ctorParameters=()=>[{type:ee},{type:ne.j},{type:L},{type:j.a},{type:Document,decorators:[{type:s.D,args:[i.d]}]}],te=Object(o.a)([Object(s.n)({selector:"app-tool-home",template:'<nb-layout withScroll center>\n\n\n  <nb-layout-header fixed>\n    <div fxFlex fxLayoutAlign="space-between center">\n      <div class="imageContainer" fxLayoutAlign="center center">\n        <img src="/assets/logo.png">\n      </div>\n\n\n      <div>\n\n\n\n\n\n      </div>\n\n\n    </div>\n\n\n\n  </nb-layout-header>\n\n\n\n  <nb-sidebar *ngIf="false" right fxLayout="column">\n\n\n\n    <nb-list>\n\n      <nb-list-item class="create" @init fxLayoutAlign="center">\n\n\n        <div fxFlex fxLayout="row">\n\n          <button (click)="openDrawer(dialog)" fullWidth class="newBtn" shape="round" nbButton>\n\n            <div class="icon" icon="plus"></div>\n\n            <span>\n              Create Tool\n\n            </span>\n          </button>\n\n        </div>\n      </nb-list-item>\n\n\n      <nb-list-item @init *ngFor="let toolMenuItem of toolMenu; index as index">\n        <app-navbar-list-item [activestate]="activeState" [item]="toolMenuItem" [routerlink]="toolMenuItem.type"\n          fxLayout="column" [title]="toolMenuItem.name" fxFlex>\n\n        </app-navbar-list-item>\n      </nb-list-item>\n\n\n    </nb-list>\n\n\n\n  </nb-sidebar>\n\n\n\n\n\n\n  <nb-layout-column>\n    <router-outlet>\n    </router-outlet>\n    \x3c!-- <app-tool-screen></app-tool-screen> --\x3e\n\n  </nb-layout-column>\n\n  \x3c!-- <nb-layout-column>\n\n    <app-tool-screen></app-tool-screen>\n\n  </nb-layout-column> --\x3e\n\n</nb-layout>\n\n\n\n\n<ng-template #dialog let-close="close" let-data let-ref="dialogRef">\n  <app-tool-create [close]="close"></app-tool-create>\n</ng-template>\n',changeDetection:s.j.OnPush,animations:[...F.a],styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\n.subtitle {\n  color: #a4b1cd !important;\n  font-weight: 600;\n  line-height: 1rem;\n  font-size: 1rem;\n}\n.avatar {\n  width: 2rem;\n  height: 2rem;\n}\nimg {\n  height: 3rem;\n}\n:host ::ng-deep nb-sidebar {\n  margin-right: 0 !important;\n  margin-left: 0 !important;\n}\n:host ::ng-deep nb-sidebar nb-list-item {\n  padding: 0px !important;\n  border: 0 !important;\n}\n:host ::ng-deep nb-sidebar .item {\n  border: 0;\n}\n:host ::ng-deep nb-sidebar .scrollable {\n  padding: 0px !important;\n}\n:host ::ng-deep nb-sidebar nb-tab {\n  padding: 1.25rem;\n}\nnb-list-item {\n  margin-left: 3px !important;\n  margin-right: 3px !important;\n  margin-top: 0px !important;\n  padding: 0.8rem !important;\n  font-weight: 350 !important;\n}\n:host ::ng-deep nb-layout-header nav {\n  padding: 0rem !important;\n}\n:host ::ng-deep .accordion-item-header-expanded {\n  background: #fff !important;\n  color: #292828 !important;\n  font-weight: 550 !important;\n}\n:host ::ng-deep nb-accordion-item-body .item-body {\n  padding: 0px !important;\n}\n.selected-route {\n  background: #fff !important;\n  color: #000 !important;\n  font-weight: 600 !important;\n}\nnb-sidebar-footer {\n  margin: 0.4rem !important;\n}\nnb-sidebar-header {\n  background: #171a21 !important;\n}\n.colored {\n  color: #3366ff;\n}\n.logo {\n  width: 190px;\n  height: auto;\n}\nnb-layout-column {\n  overflow: hidden;\n}\n.roundBtn {\n  width: 4rem;\n  height: 4rem;\n  line-height: 115px;\n  text-align: center;\n  border: 0px solid red;\n  background-image: url(\"/assets/logo_mini.png\");\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: contain;\n}\npre {\n  font: 500 12px/1.5 Monaco, Consolas, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", \"Courier New\", Courier, monospace;\n  white-space: pre;\n  padding: 0px 0px 0px 31px;\n}\nbutton.newBtn {\n  padding: 0.3rem !important;\n  padding-left: 1rem !important;\n  padding-right: 1rem !important;\n  text-transform: capitalize !important;\n  box-shadow: 0 1px 2px 0 rgba(60, 64, 67, 0.302), 0 1px 3px 1px rgba(60, 64, 67, 0.149) !important;\n  align-items: center !important;\n  background-color: #fff !important;\n  border: 1px solid transparent;\n  border-radius: 24px;\n  color: #3c4043 !important;\n}\nbutton.newBtn span {\n  margin-right: 1rem;\n  margin-top: 0.5rem;\n  margin-bottom: 0.5rem;\n  font-weight: 600;\n}\nbutton.newBtn .icon {\n  margin-right: 1rem;\n  background-image: url(\"data:image/svg+xml;charset=UTF-8,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2236%22 height=%2236%22 viewBox=%220 0 36 36%22%3E%3Cpath fill=%22%2334A853%22 d=%22M16 16v14h4V20z%22/%3E%3Cpath fill=%22%234285F4%22 d=%22M30 16H20l-4 4h14z%22/%3E%3Cpath fill=%22%23FBBC05%22 d=%22M6 16v4h10l4-4z%22/%3E%3Cpath fill=%22%23EA4335%22 d=%22M20 16V6h-4v14z%22/%3E%3Cpath fill=%22none%22 d=%22M0 0h36v36H0z%22/%3E%3C/svg%3E\");\n  width: 2rem !important;\n  height: 2rem !important;\n}\nbutton.newBtn:hover {\n  box-shadow: 0 3px 5px 0 rgba(60, 64, 67, 0.302), 0 3px 5px 1px rgba(60, 64, 67, 0.149) !important;\n  background-color: #fff !important;\n}\n.dialog nb-card {\n  width: 50rem !important;\n  box-shadow: 0 4px 8px 0 rgba(60, 64, 67, 0.302), 0 4px 8px 1px rgba(60, 64, 67, 0.149) !important;\n}\n.create {\n  margin: 1rem !important;\n}"]})],te);var oe=t("JX91");let se=class{constructor(e,n,t){this.toolApiService=e,this.drawerMngr=n,this.document=t,this.tools$=this.toolApiService.getTools()}ngOnInit(){this.groups=[{name:"Group 1",children:["Option 11","Option 12","Option 13"]},{name:"Group 2",children:["Option 21","Option 22","Option 23"]},{name:"Group 3",children:["Option 31","Option 32","Option 33"]}],this.filteredGroups$=Object(p.a)(this.groups),this.inputFormControl=new l.d,this.filteredGroups$=this.inputFormControl.valueChanges.pipe(Object(oe.a)(""),Object(f.a)(e=>this.filter(e)))}filterChildren(e,n){return e.filter(e=>e.toLowerCase().includes(n))}filter(e){const n=e.toLowerCase();return this.groups.map(e=>({name:e.name,children:this.filterChildren(e.children,n)})).filter(e=>e.children.length)}trackByFn(e,n){return n.name}openDrawer(e,n,t=_.a.Left,o="50%",s=!0,i=!0,r){n||(n={});this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:t,template:e,size:o,context:n,closeOnOutsideClick:s,parentContainer:r,isRoot:i,zIndex:1e3,cssClass:"backdrop_color"}).onDestroy(()=>{this.document.body.classList.remove("cdk-global-scrollblock")})}};se.ctorParameters=()=>[{type:L},{type:j.a},{type:Document,decorators:[{type:s.D,args:[i.d]}]}],se=Object(o.a)([Object(s.n)({selector:"app-tool-list",template:'<ng-container *ngIf=" tools$ | async as tools ; else loading">\n\n\n\n  <nb-card *ngIf="false">\n    <nb-card-header>\n\n\n      <div fxLayout="row" fxLayoutAlign="start center">\n\n        <button shape="round" [routerLink]="[\'/tools\' , \'\']" ghost status="basic" class="action" size="large" nbButton>\n          <nb-icon icon="arrow-back-outline">\n\n          </nb-icon>\n        </button>\n\n        <div class="h6 text-hint">\n          Tools\n\n        </div>\n\n\n\n\n\n      </div>\n    </nb-card-header>\n    <nb-list>\n      <nb-list-item fxLayout="row" fxLayoutAlign="space-between" *ngFor="let tool of tools">\n\n        <div>\n\n          <div class="title text-hint">\n            {{ tool?.name || \'Tool Name\' }}\n          </div>\n          <div class="desc text-hint">\n            {{ tool?.description || \'Tool Description\' }}\n          </div>\n        </div>\n\n\n        <div>\n\n\n\n\n\n          <button (click)="openDrawer(toolEditTemplate  , context =  { \'tool_id\':  tool?._id , \'edit_mode\': true } )"\n            status="basic" ghost size="small" nbButton>\n\n            <nb-icon icon="settings-2-outline"></nb-icon>\n            Edits\n          </button>\n\n\n          <button status="basic" ghost size="small" nbButton>\n\n            <nb-icon icon="diagonal-arrow-left-down-outline"></nb-icon>\n            Fork\n          </button>\n\n\n          <button [routerLink]="[ \'builds\' , tool?._id ]  " status="success" size="small" nbButton>Explore</button>\n        </div>\n\n\n\n      </nb-list-item>\n    </nb-list>\n  </nb-card>\n\n\n\n  <nb-layout-header subHeader>\n\n    <div fxLayout="row" fxFlex fxLayoutAlign="start center">\n\n      <button shape="round" [routerLink]="[\'/\'  ]" ghost status="basic" class="action" size="large" nbButton>\n        <nb-icon icon="arrow-back-outline">\n\n        </nb-icon>\n      </button>\n\n      <div fxFlex class="h6 text-hint">\n        Tools\n\n      </div>\n\n      <button (click)="openDrawer(toolEditTemplate)" class="newBtn" shape="round" nbButton>\n\n        <div class="icon" icon="plus"></div>\n\n        <span>\n          Create Tool\n\n        </span>\n      </button>\n    </div>\n\n  </nb-layout-header>\n\n\n\n\n  <nb-accordion>\n    <nb-accordion-item [expanded]="index == 0" *ngFor="let tool of tools   ; index as index ">\n      <nb-accordion-item-header fxLayoutAlign="space-between">\n\n\n        <span>\n          {{ tool?.name || \'Tool Name\' }}\n\n        </span>\n\n        <span class="text-hint">\n          {{ \'@\' +  ( tool?.alias || \'Alias\' ) }}\n        </span>\n      </nb-accordion-item-header>\n      <nb-accordion-item-body>\n\n        <nb-card>\n          <nb-card-body>\n            <div>\n\n              <div class="text-hint">\n                {{ tool?.description || \'Tool Description\' }}\n              </div>\n\n            </div>\n          </nb-card-body>\n          <nb-card-footer fxLayoutGap="1rem" fxLayoutAlign="end center">\n\n            <div fxLayoutGap="0.5rem" fxLayoutAlign="end center">\n\n\n              <nb-button-group multiple status="primary" size="small" appearance="filled">\n\n                <button\n                  (click)="openDrawer(toolEditTemplate  , context =  { \'tool_id\':  tool?._id , \'edit_mode\': true } )"\n                  nbButton>\n\n                  <nb-icon icon="settings-2-outline"></nb-icon>\n                  Edit\n                </button>\n                <button (click)="openDrawer(logsTemplate)" nbButton>\n\n                  <nb-icon icon="flip-2-outline"></nb-icon>\n                  Deployments\n                </button>\n\n\n                <button [routerLink]="[  \'/tools\'  , \'builds\', tool?._id ]  " nbButton>\n                  <nb-icon icon="expand-outline"></nb-icon>\n\n                  Explore\n                </button>\n\n              </nb-button-group>\n\n\n\n\n\n            </div>\n\n          </nb-card-footer>\n\n        </nb-card>\n\n      </nb-accordion-item-body>\n    </nb-accordion-item>\n\n  </nb-accordion>\n\n</ng-container>\n\n\n<ng-template #loading>\n  <div fxLayoutAlign="center center">\n    <ngx-progress-spinner></ngx-progress-spinner>\n  </div>\n\n</ng-template>\n\n\n\n<ng-template #toolEditTemplate let-close="close" let-context="context" let-ref="dialogRef">\n\n  <app-tool-create [edit_mode]="context.edit_mode" [close]="close" [tool_id]="context.tool_id"></app-tool-create>\n</ng-template>\n',changeDetection:s.j.OnPush,animations:[...F.a],styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\nnb-accordion-item {\n  margin-top: 0.4rem;\n  margin-bottom: 0.4rem;\n}\nnb-accordion-item nb-accordion-item-header .text-hint {\n  color: #000 !important;\n}\nnb-accordion-item nb-accordion-item-header:hover {\n  background: linear-gradient(to right, #457fca, #5b86e5);\n  color: #fff;\n}\nnb-accordion-item nb-accordion-item-header:hover .text-hint {\n  color: #fff !important;\n}\nnb-accordion-item nb-accordion-item-header .text-hint {\n  color: var(--text-basic-color) !important;\n}\nnb-accordion-item nb-accordion-item-header.accordion-item-header-expanded {\n  border-left: 2px var(--text-basic-color) solid !important;\n}\nnb-accordion-item nb-accordion-item-header.accordion-item-header-expanded .text-hint {\n  color: var(--text-alternate-color) !important;\n}\nnb-layout-header {\n  padding: 0rem !important;\n  margin: 0rem !important;\n}\ninput {\n  height: 100%;\n}\nnb-card {\n  margin-bottom: 0;\n  border: 0;\n}\nnb-accordion {\n  margin-top: 1rem;\n}\nbutton.newBtn {\n  padding: 0.3rem !important;\n  padding-left: 1rem !important;\n  padding-right: 1rem !important;\n  text-transform: capitalize !important;\n  box-shadow: 0 1px 2px 0 rgba(60, 64, 67, 0.302), 0 1px 3px 1px rgba(60, 64, 67, 0.149) !important;\n  align-items: center !important;\n  background-color: #fff !important;\n  border: 1px solid transparent;\n  border-radius: 24px;\n  color: #3c4043 !important;\n}\nbutton.newBtn span {\n  margin-right: 1rem;\n  margin-top: 0.5rem;\n  margin-bottom: 0.5rem;\n  font-weight: 600;\n}\nbutton.newBtn .icon {\n  margin-right: 1rem;\n  background-image: url(\"data:image/svg+xml;charset=UTF-8,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2236%22 height=%2236%22 viewBox=%220 0 36 36%22%3E%3Cpath fill=%22%2334A853%22 d=%22M16 16v14h4V20z%22/%3E%3Cpath fill=%22%234285F4%22 d=%22M30 16H20l-4 4h14z%22/%3E%3Cpath fill=%22%23FBBC05%22 d=%22M6 16v4h10l4-4z%22/%3E%3Cpath fill=%22%23EA4335%22 d=%22M20 16V6h-4v14z%22/%3E%3Cpath fill=%22none%22 d=%22M0 0h36v36H0z%22/%3E%3C/svg%3E\");\n  width: 2rem !important;\n  height: 2rem !important;\n}\nbutton.newBtn:hover {\n  box-shadow: 0 3px 5px 0 rgba(60, 64, 67, 0.302), 0 3px 5px 1px rgba(60, 64, 67, 0.149) !important;\n  background-color: #fff !important;\n}\n.h6 {\n  margin-left: 1rem;\n}\n.action {\n  margin-left: 5px;\n}\n.action:hover nb-icon {\n  color: var(--color-primary-500);\n}\nnb-list {\n  margin-top: 0.4rem;\n  margin-bottom: 0.4rem;\n}\nnb-list nb-list-item .text-hint {\n  color: #000 !important;\n}\nnb-list nb-list-item .text-hint {\n  color: var(--text-basic-color) !important;\n}\nnb-list nb-list-item.accordion-item-header-expanded {\n  border-left: 2px var(--text-basic-color) solid !important;\n}\nnb-list nb-list-item.accordion-item-header-expanded .text-hint {\n  color: var(--text-alternate-color) !important;\n}\nnb-card-header {\n  padding: 0rem !important;\n  margin: 0rem !important;\n}"]})],se);const ie=[{path:"",component:te,children:[{path:"test",component:S},{path:"",component:se},{path:"builds/:id",component:V,children:[{path:"",redirectTo:"builds",outlet:"view"},{path:"deployments",component:O,outlet:"view"},{path:"images",component:B,outlet:"view"},{path:"builds",component:z,outlet:"view"},{path:"jobs",component:q,outlet:"view"},{path:"**",redirectTo:"builds",outlet:"view"}]},{path:"builds/all/:id",component:z},{path:"details/:id",component:T},{path:"**",redirectTo:"/tools"}]}];let re=class{};re=Object(o.a)([Object(s.N)({imports:[r.j.forChild(ie)],exports:[r.j]})],re);var le=t("YUcS"),ae=t("EcHK"),ce=t("tR1z");let de=class{constructor(){}ngOnInit(){}};de.ctorParameters=()=>[],de=Object(o.a)([Object(s.n)({selector:"app-headbar",template:'<nb-layout-header fixed>\n\n  <div fxFlex fxLayoutAlign="center center">\n    <div fxFlex fxLayoutAlign="start center">\n      <button routerLink="/" nbButton ghost status="danger" size="small">\n        <img class="logo" src="/assets/logo.png">\n      </button>\n    </div>\n  </div>\n\n</nb-layout-header>\n',styles:[""]})],de);let he=class{};he=Object(o.a)([Object(s.N)({declarations:[],imports:[i.c]})],he);var pe=t("BN9v");let ue=class{constructor(){this.loop=[1,1,1,1,11,1,1,1,2,312,3,213,12,312]}ngOnInit(){}};ue.ctorParameters=()=>[],ue=Object(o.a)([Object(s.n)({selector:"app-tool-build-variants",template:'<app-build-create>\n  \n</app-build-create>\n\n<nb-list fxFlex>\n\n  <nb-list-item  *ngFor="let _ of loop">\n\n    <nb-card status="success" fxFlex>\n      <nb-card-header fxLayoutAlign="space-between center">\n\n        <div fxLayoutGap="1rem" fxLayoutAlign="start center">\n\n          <nb-icon icon="checkmark-circle-2"></nb-icon>\n\n          <span class="subtitle-2 text-alternate">\n            Hello World\n          </span>\n\n\n\n        </div>\n\n        <button status="control" hero nbButton size="tiny">\n          Save\n        </button>\n      </nb-card-header>\n      <nb-card-body>\n\n        <div class="cardcontainer" fxLayout="column">\n\n\n          <div fxFlex fxLayoutAlign="start center" fxLayoutGap="1rem">\n            <nb-icon icon="flip-2"></nb-icon>\n\n            <span>\n              <a class="text-basic">\n                Helllo\n              </a>\n            </span>\n            <span>\n              Word\n            </span>\n          </div>\n\n          <div fxFlex fxLayoutAlign="start center" fxLayoutGap="1rem">\n            <nb-icon icon="flip-2"></nb-icon>\n\n            <span>\n              <a>\n                Helllo\n              </a>\n            </span>\n            <span>\n              Word\n            </span>\n          </div>\n\n\n          <div fxFlex fxLayoutAlign="start center" fxLayoutGap="1rem">\n            <nb-icon icon="flip-2"></nb-icon>\n\n            <span>\n              <a>\n                Helllo\n              </a>\n            </span>\n            <span>\n              Word\n            </span>\n          </div>\n\n\n          <div fxFlex fxLayoutAlign="start center" fxLayoutGap="1rem">\n            <nb-icon icon="flip-2"></nb-icon>\n\n            <span>\n              <a>\n                Helllo\n              </a>\n            </span>\n            <span>\n              Word\n            </span>\n          </div>\n\n\n          <div fxFlex fxLayoutAlign="start center" fxLayoutGap="1rem">\n            <nb-icon icon="flip-2"></nb-icon>\n\n            <span>\n              <a>\n                Helllo\n              </a>\n            </span>\n            <span>\n              Word\n            </span>\n          </div>\n\n        </div>\n\n      </nb-card-body>\n    </nb-card>\n\n  </nb-list-item>\n\n</nb-list>\n',changeDetection:s.j.OnPush,styles:[".cardcontainer {\n  border-radius: 3px;\n  background: white;\n  box-shadow: rgba(9, 30, 66, 0.31) 0px 0px 1px;\n  padding: 1rem;\n  box-sizing: border-box;\n  position: relative;\n}\n\nnb-card-body {\n  background: rgba(244, 245, 247, 0.212);\n  box-sizing: border-box;\n  padding: 8px;\n  border-radius: 0px 0px 5px 5px;\n}"]})],ue);let me=class{constructor(){this.direction="horizontal"}ngOnInit(){}};me.ctorParameters=()=>[],me=Object(o.a)([Object(s.n)({selector:"app-tool-screen",template:" <app-tool-list></app-tool-list>\n",changeDetection:s.j.OnPush,styles:["nb-layout-column:first-child {\n  flex: 1 !important;\n}\n\nnb-layout-column:last-child {\n  flex: 1 !important;\n}"]})],me);var be=t("HDdC"),we=t("Kj3r");const fe=["gutterEls"];function ge(e,n){if(1&e){const e=s.Xc();s.Wc(0,"div",2,3),s.ed("mousedown",function(n){s.td(e);const t=s.gd().index;return s.gd().startDragging(n,2*t+1,t+1)})("touchstart",function(n){s.td(e);const t=s.gd().index;return s.gd().startDragging(n,2*t+1,t+1)})("mouseup",function(n){s.td(e);const t=s.gd().index;return s.gd().clickGutter(n,t+1)})("touchend",function(n){s.td(e);const t=s.gd().index;return s.gd().clickGutter(n,t+1)}),s.Rc(2,"div",4),s.Vc()}if(2&e){const e=s.gd().index,n=s.gd();s.xd("flex-basis",n.gutterSize,"px")("order",2*e+1)}}function xe(e,n){if(1&e&&s.zd(0,ge,3,4,"div",1),2&e){const e=n.last;s.md("ngIf",!1===e)}}function ye(e){return void 0!==e.changedTouches&&e.changedTouches.length>0?{x:e.changedTouches[0].clientX,y:e.changedTouches[0].clientY}:void 0!==e.clientX&&void 0!==e.clientY?{x:e.clientX,y:e.clientY}:null}function ve(e,n){const t=e.nativeElement.getBoundingClientRect();return"horizontal"===n?t.width:t.height}function ke(e){return"boolean"==typeof e?e:"false"!==e}function Ae(e,n){return null==e?n:(e=Number(e),!isNaN(e)&&e>=0?e:n)}function Le(e,n){if("percent"===e){const e=n.reduce((e,n)=>null!==n?e+n:e,0);return n.every(e=>null!==e)&&e>99.9&&e<100.1}if("pixel"===e)return 1===n.filter(e=>null===e).length}function Se(e){return null===e.size?null:!0===e.component.lockSize?e.size:null===e.component.minSize?null:e.component.minSize>e.size?e.size:e.component.minSize}function Re(e){return null===e.size?null:!0===e.component.lockSize?e.size:null===e.component.maxSize?null:e.component.maxSize<e.size?e.size:e.component.maxSize}function Ce(e,n,t,o){return n.reduce((n,t)=>{const s=function(e,n,t,o){if(0===t)return{areaSnapshot:n,pixelAbsorb:0,percentAfterAbsorption:n.sizePercentAtStart,pixelRemain:0};if(0===n.sizePixelAtStart&&t<0)return{areaSnapshot:n,pixelAbsorb:0,percentAfterAbsorption:0,pixelRemain:t};if("percent"===e)return function(e,n,t){const o=(e.sizePixelAtStart+n)/t*100;if(n>0){if(null!==e.area.maxSize&&o>e.area.maxSize){const o=e.area.maxSize/100*t;return{areaSnapshot:e,pixelAbsorb:o,percentAfterAbsorption:e.area.maxSize,pixelRemain:e.sizePixelAtStart+n-o}}return{areaSnapshot:e,pixelAbsorb:n,percentAfterAbsorption:o>100?100:o,pixelRemain:0}}if(n<0){if(null!==e.area.minSize&&o<e.area.minSize){const o=e.area.minSize/100*t;return{areaSnapshot:e,pixelAbsorb:o,percentAfterAbsorption:e.area.minSize,pixelRemain:e.sizePixelAtStart+n-o}}return o<0?{areaSnapshot:e,pixelAbsorb:-e.sizePixelAtStart,percentAfterAbsorption:0,pixelRemain:n+e.sizePixelAtStart}:{areaSnapshot:e,pixelAbsorb:n,percentAfterAbsorption:o,pixelRemain:0}}}(n,t,o);if("pixel"===e)return function(e,n,t){const o=e.sizePixelAtStart+n;if(n>0)return null!==e.area.maxSize&&o>e.area.maxSize?{areaSnapshot:e,pixelAbsorb:e.area.maxSize-e.sizePixelAtStart,percentAfterAbsorption:-1,pixelRemain:o-e.area.maxSize}:{areaSnapshot:e,pixelAbsorb:n,percentAfterAbsorption:-1,pixelRemain:0};if(n<0)return null!==e.area.minSize&&o<e.area.minSize?{areaSnapshot:e,pixelAbsorb:e.area.minSize+n-o,percentAfterAbsorption:-1,pixelRemain:o-e.area.minSize}:o<0?{areaSnapshot:e,pixelAbsorb:-e.sizePixelAtStart,percentAfterAbsorption:-1,pixelRemain:n+e.sizePixelAtStart}:{areaSnapshot:e,pixelAbsorb:n,percentAfterAbsorption:-1,pixelRemain:0}}(n,t)}(e,t,n.remain,o);return n.list.push(s),n.remain=s.pixelRemain,n},{remain:t,list:[]})}function Ie(e,n){"percent"===e?n.areaSnapshot.area.size=n.percentAfterAbsorption:"pixel"===e&&null!==n.areaSnapshot.area.size&&(n.areaSnapshot.area.size=n.areaSnapshot.sizePixelAtStart+n.pixelAbsorb)}class Te{constructor(e,n,t,o){this.ngZone=e,this.elRef=n,this.cdRef=t,this.renderer=o,this._direction="horizontal",this._unit="percent",this._gutterSize=11,this._gutterStep=1,this._restrictMove=!1,this._useTransition=!1,this._disabled=!1,this._dir="ltr",this._gutterDblClickDuration=0,this.dragStart=new s.y(!1),this.dragEnd=new s.y(!1),this.gutterClick=new s.y(!1),this.gutterDblClick=new s.y(!1),this.dragProgressSubject=new d.a,this.dragProgress$=this.dragProgressSubject.asObservable(),this.isDragging=!1,this.isWaitingClear=!1,this.dragListeners=[],this.snapshot=null,this.startPoint=null,this.endPoint=null,this.displayedAreas=[],this.hidedAreas=[],this._clickTimeout=null,this.direction=this._direction}set direction(e){this._direction="vertical"===e?"vertical":"horizontal",this.renderer.addClass(this.elRef.nativeElement,"as-"+this._direction),this.renderer.removeClass(this.elRef.nativeElement,"as-"+("vertical"===this._direction?"horizontal":"vertical")),this.build(!1,!1)}get direction(){return this._direction}set unit(e){this._unit="pixel"===e?"pixel":"percent",this.renderer.addClass(this.elRef.nativeElement,"as-"+this._unit),this.renderer.removeClass(this.elRef.nativeElement,"as-"+("pixel"===this._unit?"percent":"pixel")),this.build(!1,!0)}get unit(){return this._unit}set gutterSize(e){this._gutterSize=Ae(e,11),this.build(!1,!1)}get gutterSize(){return this._gutterSize}set gutterStep(e){this._gutterStep=Ae(e,1)}get gutterStep(){return this._gutterStep}set restrictMove(e){this._restrictMove=ke(e)}get restrictMove(){return this._restrictMove}set useTransition(e){this._useTransition=ke(e),this._useTransition?this.renderer.addClass(this.elRef.nativeElement,"as-transition"):this.renderer.removeClass(this.elRef.nativeElement,"as-transition")}get useTransition(){return this._useTransition}set disabled(e){this._disabled=ke(e),this._disabled?this.renderer.addClass(this.elRef.nativeElement,"as-disabled"):this.renderer.removeClass(this.elRef.nativeElement,"as-disabled")}get disabled(){return this._disabled}set dir(e){this._dir="rtl"===e?"rtl":"ltr",this.renderer.setAttribute(this.elRef.nativeElement,"dir",this._dir)}get dir(){return this._dir}set gutterDblClickDuration(e){this._gutterDblClickDuration=Ae(e,0)}get gutterDblClickDuration(){return this._gutterDblClickDuration}get transitionEnd(){return new be.a(e=>this.transitionEndSubscriber=e).pipe(Object(we.a)(20))}ngAfterViewInit(){this.ngZone.runOutsideAngular(()=>{setTimeout(()=>this.renderer.addClass(this.elRef.nativeElement,"as-init"))})}getNbGutters(){return 0===this.displayedAreas.length?0:this.displayedAreas.length-1}addArea(e){const n={component:e,order:0,size:0,minSize:null,maxSize:null};!0===e.visible?(this.displayedAreas.push(n),this.build(!0,!0)):this.hidedAreas.push(n)}removeArea(e){if(this.displayedAreas.some(n=>n.component===e)){const n=this.displayedAreas.find(n=>n.component===e);this.displayedAreas.splice(this.displayedAreas.indexOf(n),1),this.build(!0,!0)}else if(this.hidedAreas.some(n=>n.component===e)){const n=this.hidedAreas.find(n=>n.component===e);this.hidedAreas.splice(this.hidedAreas.indexOf(n),1)}}updateArea(e,n,t){!0===e.visible&&this.build(n,t)}showArea(e){const n=this.hidedAreas.find(n=>n.component===e);if(void 0===n)return;const t=this.hidedAreas.splice(this.hidedAreas.indexOf(n),1);this.displayedAreas.push(...t),this.build(!0,!0)}hideArea(e){const n=this.displayedAreas.find(n=>n.component===e);if(void 0===n)return;const t=this.displayedAreas.splice(this.displayedAreas.indexOf(n),1);t.forEach(e=>{e.order=0,e.size=0}),this.hidedAreas.push(...t),this.build(!0,!0)}getVisibleAreaSizes(){return this.displayedAreas.map(e=>null===e.size?"*":e.size)}setVisibleAreaSizes(e){if(e.length!==this.displayedAreas.length)return!1;const n=e.map(e=>Ae(e,null));return!1!==Le(this.unit,n)&&(this.displayedAreas.forEach((e,t)=>e.component._size=n[t]),this.build(!1,!0),!0)}build(e,n){if(this.stopDragging(),!0===e&&(this.displayedAreas.every(e=>null!==e.component.order)&&this.displayedAreas.sort((e,n)=>e.component.order-n.component.order),this.displayedAreas.forEach((e,n)=>{e.order=2*n,e.component.setStyleOrder(e.order)})),!0===n){const e=Le(this.unit,this.displayedAreas.map(e=>e.component.size));switch(this.unit){case"percent":{const n=100/this.displayedAreas.length;this.displayedAreas.forEach(t=>{t.size=e?t.component.size:n,t.minSize=Se(t),t.maxSize=Re(t)});break}case"pixel":if(e)this.displayedAreas.forEach(e=>{e.size=e.component.size,e.minSize=Se(e),e.maxSize=Re(e)});else{const e=this.displayedAreas.filter(e=>null===e.component.size);if(0===e.length&&this.displayedAreas.length>0)this.displayedAreas.forEach((e,n)=>{e.size=0===n?null:e.component.size,e.minSize=0===n?null:Se(e),e.maxSize=0===n?null:Re(e)});else if(e.length>1){let e=!1;this.displayedAreas.forEach(n=>{null===n.component.size?!1===e?(n.size=null,n.minSize=null,n.maxSize=null,e=!0):(n.size=100,n.minSize=null,n.maxSize=null):(n.size=n.component.size,n.minSize=Se(n),n.maxSize=Re(n))})}}}}this.refreshStyleSizes(),this.cdRef.markForCheck()}refreshStyleSizes(){if("percent"===this.unit)if(1===this.displayedAreas.length)this.displayedAreas[0].component.setStyleFlex(0,0,"100%",!1,!1);else{const e=this.getNbGutters()*this.gutterSize;this.displayedAreas.forEach(n=>{n.component.setStyleFlex(0,0,`calc( ${n.size}% - ${n.size/100*e}px )`,null!==n.minSize&&n.minSize===n.size,null!==n.maxSize&&n.maxSize===n.size)})}else"pixel"===this.unit&&this.displayedAreas.forEach(e=>{null===e.size?1===this.displayedAreas.length?e.component.setStyleFlex(1,1,"100%",!1,!1):e.component.setStyleFlex(1,1,"auto",!1,!1):1===this.displayedAreas.length?e.component.setStyleFlex(0,0,"100%",!1,!1):e.component.setStyleFlex(0,0,e.size+"px",null!==e.minSize&&e.minSize===e.size,null!==e.maxSize&&e.maxSize===e.size)})}clickGutter(e,n){const t=ye(e);this.startPoint&&this.startPoint.x===t.x&&this.startPoint.y===t.y&&(null!==this._clickTimeout?(window.clearTimeout(this._clickTimeout),this._clickTimeout=null,this.notify("dblclick",n),this.stopDragging()):this._clickTimeout=window.setTimeout(()=>{this._clickTimeout=null,this.notify("click",n),this.stopDragging()},this.gutterDblClickDuration))}startDragging(e,n,t){e.preventDefault(),e.stopPropagation(),this.startPoint=ye(e),null!==this.startPoint&&!0!==this.disabled&&!0!==this.isWaitingClear&&(this.snapshot={gutterNum:t,lastSteppedOffset:0,allAreasSizePixel:ve(this.elRef,this.direction)-this.getNbGutters()*this.gutterSize,allInvolvedAreasSizePercent:100,areasBeforeGutter:[],areasAfterGutter:[]},this.displayedAreas.forEach(e=>{const t={area:e,sizePixelAtStart:ve(e.component.elRef,this.direction),sizePercentAtStart:"percent"===this.unit?e.size:-1};e.order<n?!0===this.restrictMove?this.snapshot.areasBeforeGutter=[t]:this.snapshot.areasBeforeGutter.unshift(t):e.order>n&&(!0===this.restrictMove?0===this.snapshot.areasAfterGutter.length&&(this.snapshot.areasAfterGutter=[t]):this.snapshot.areasAfterGutter.push(t))}),this.snapshot.allInvolvedAreasSizePercent=[...this.snapshot.areasBeforeGutter,...this.snapshot.areasAfterGutter].reduce((e,n)=>e+n.sizePercentAtStart,0),0!==this.snapshot.areasBeforeGutter.length&&0!==this.snapshot.areasAfterGutter.length&&(this.dragListeners.push(this.renderer.listen("document","mouseup",this.stopDragging.bind(this))),this.dragListeners.push(this.renderer.listen("document","touchend",this.stopDragging.bind(this))),this.dragListeners.push(this.renderer.listen("document","touchcancel",this.stopDragging.bind(this))),this.ngZone.runOutsideAngular(()=>{this.dragListeners.push(this.renderer.listen("document","mousemove",this.dragEvent.bind(this))),this.dragListeners.push(this.renderer.listen("document","touchmove",this.dragEvent.bind(this)))}),this.displayedAreas.forEach(e=>e.component.lockEvents()),this.isDragging=!0,this.renderer.addClass(this.elRef.nativeElement,"as-dragging"),this.renderer.addClass(this.gutterEls.toArray()[this.snapshot.gutterNum-1].nativeElement,"as-dragged"),this.notify("start",this.snapshot.gutterNum)))}dragEvent(e){if(e.preventDefault(),e.stopPropagation(),null!==this._clickTimeout&&(window.clearTimeout(this._clickTimeout),this._clickTimeout=null),!1===this.isDragging)return;if(this.endPoint=ye(e),null===this.endPoint)return;let n="horizontal"===this.direction?this.startPoint.x-this.endPoint.x:this.startPoint.y-this.endPoint.y;"rtl"===this.dir&&(n=-n);const t=Math.round(n/this.gutterStep)*this.gutterStep;if(t===this.snapshot.lastSteppedOffset)return;this.snapshot.lastSteppedOffset=t;let o=Ce(this.unit,this.snapshot.areasBeforeGutter,-t,this.snapshot.allAreasSizePixel),s=Ce(this.unit,this.snapshot.areasAfterGutter,t,this.snapshot.allAreasSizePixel);if(0!==o.remain&&0!==s.remain?Math.abs(o.remain)===Math.abs(s.remain)||(Math.abs(o.remain)>Math.abs(s.remain)?s=Ce(this.unit,this.snapshot.areasAfterGutter,t+o.remain,this.snapshot.allAreasSizePixel):o=Ce(this.unit,this.snapshot.areasBeforeGutter,-(t-s.remain),this.snapshot.allAreasSizePixel)):0!==o.remain?s=Ce(this.unit,this.snapshot.areasAfterGutter,t+o.remain,this.snapshot.allAreasSizePixel):0!==s.remain&&(o=Ce(this.unit,this.snapshot.areasBeforeGutter,-(t-s.remain),this.snapshot.allAreasSizePixel)),"percent"===this.unit){const e=[...o.list,...s.list],n=e.find(e=>0!==e.percentAfterAbsorption&&e.percentAfterAbsorption!==e.areaSnapshot.area.minSize&&e.percentAfterAbsorption!==e.areaSnapshot.area.maxSize);n&&(n.percentAfterAbsorption=this.snapshot.allInvolvedAreasSizePercent-e.filter(e=>e!==n).reduce((e,n)=>e+n.percentAfterAbsorption,0))}o.list.forEach(e=>Ie(this.unit,e)),s.list.forEach(e=>Ie(this.unit,e)),this.refreshStyleSizes(),this.notify("progress",this.snapshot.gutterNum)}stopDragging(e){if(e&&(e.preventDefault(),e.stopPropagation()),!1!==this.isDragging){for(this.displayedAreas.forEach(e=>e.component.unlockEvents());this.dragListeners.length>0;){const e=this.dragListeners.pop();e&&e()}this.isDragging=!1,!this.endPoint||this.startPoint.x===this.endPoint.x&&this.startPoint.y===this.endPoint.y||this.notify("end",this.snapshot.gutterNum),this.renderer.removeClass(this.elRef.nativeElement,"as-dragging"),this.renderer.removeClass(this.gutterEls.toArray()[this.snapshot.gutterNum-1].nativeElement,"as-dragged"),this.snapshot=null,this.isWaitingClear=!0,this.ngZone.runOutsideAngular(()=>{setTimeout(()=>{this.startPoint=null,this.endPoint=null,this.isWaitingClear=!1})})}}notify(e,n){const t=this.getVisibleAreaSizes();"start"===e?this.dragStart.emit({gutterNum:n,sizes:t}):"end"===e?this.dragEnd.emit({gutterNum:n,sizes:t}):"click"===e?this.gutterClick.emit({gutterNum:n,sizes:t}):"dblclick"===e?this.gutterDblClick.emit({gutterNum:n,sizes:t}):"transitionEnd"===e?this.transitionEndSubscriber&&this.ngZone.run(()=>this.transitionEndSubscriber.next(t)):"progress"===e&&this.dragProgressSubject.next({gutterNum:n,sizes:t})}ngOnDestroy(){this.stopDragging()}}Te.\u0275fac=function(e){return new(e||Te)(s.Qc(s.S),s.Qc(s.v),s.Qc(s.k),s.Qc(s.bb))},Te.\u0275cmp=s.Kc({type:Te,selectors:[["as-split"]],viewQuery:function(e,n){if(1&e&&s.Ed(fe,1),2&e){let e;s.pd(e=s.fd())&&(n.gutterEls=e)}},inputs:{direction:"direction",unit:"unit",gutterSize:"gutterSize",gutterStep:"gutterStep",restrictMove:"restrictMove",useTransition:"useTransition",disabled:"disabled",dir:"dir",gutterDblClickDuration:"gutterDblClickDuration"},outputs:{dragStart:"dragStart",dragEnd:"dragEnd",gutterClick:"gutterClick",gutterDblClick:"gutterDblClick",transitionEnd:"transitionEnd"},exportAs:["asSplit"],ngContentSelectors:["*"],decls:2,vars:1,consts:[["ngFor","",3,"ngForOf"],["class","as-split-gutter",3,"flex-basis","order","mousedown","touchstart","mouseup","touchend",4,"ngIf"],[1,"as-split-gutter",3,"mousedown","touchstart","mouseup","touchend"],["gutterEls",""],[1,"as-split-gutter-icon"]],template:function(e,n){1&e&&(s.ld(),s.kd(0),s.zd(1,xe,1,1,"ng-template",0)),2&e&&(s.Ec(1),s.md("ngForOf",n.displayedAreas))},directives:[i.m,i.n],styles:['[_nghost-%COMP%]{display:flex;flex-wrap:nowrap;justify-content:flex-start;align-items:stretch;overflow:hidden;width:100%;height:100%}[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]{flex-grow:0;flex-shrink:0;background-color:#eee;display:flex;align-items:center;justify-content:center}[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%] > .as-split-gutter-icon[_ngcontent-%COMP%]{width:100%;height:100%;background-position:center center;background-repeat:no-repeat}[_nghost-%COMP%]    >.as-split-area{flex-grow:0;flex-shrink:0;overflow-x:hidden;overflow-y:auto}[_nghost-%COMP%]    >.as-split-area.as-hidden{flex:0 1 0px!important;overflow-x:hidden;overflow-y:hidden}.as-horizontal[_nghost-%COMP%]{flex-direction:row}.as-horizontal[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]{flex-direction:row;cursor:col-resize;height:100%}.as-horizontal[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%] > .as-split-gutter-icon[_ngcontent-%COMP%]{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAeCAYAAADkftS9AAAAIklEQVQoU2M4c+bMfxAGAgYYmwGrIIiDjrELjpo5aiZeMwF+yNnOs5KSvgAAAABJRU5ErkJggg==)}.as-horizontal[_nghost-%COMP%]    >.as-split-area{height:100%}.as-vertical[_nghost-%COMP%]{flex-direction:column}.as-vertical[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]{flex-direction:column;cursor:row-resize;width:100%}.as-vertical[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]   .as-split-gutter-icon[_ngcontent-%COMP%]{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAFCAMAAABl/6zIAAAABlBMVEUAAADMzMzIT8AyAAAAAXRSTlMAQObYZgAAABRJREFUeAFjYGRkwIMJSeMHlBkOABP7AEGzSuPKAAAAAElFTkSuQmCC)}.as-vertical[_nghost-%COMP%]    >.as-split-area{width:100%}.as-vertical[_nghost-%COMP%]    >.as-split-area.as-hidden{max-width:0}.as-disabled[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]{cursor:default}.as-disabled[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]   .as-split-gutter-icon[_ngcontent-%COMP%]{background-image:url("")}.as-transition.as-init[_nghost-%COMP%]:not(.as-dragging)    >.as-split-area, .as-transition.as-init[_nghost-%COMP%]:not(.as-dragging) > .as-split-gutter[_ngcontent-%COMP%]{transition:flex-basis .3s}'],changeDetection:0}),Te.ctorParameters=()=>[{type:s.S},{type:s.v},{type:s.k},{type:s.bb}],Te.propDecorators={direction:[{type:s.I}],unit:[{type:s.I}],gutterSize:[{type:s.I}],gutterStep:[{type:s.I}],restrictMove:[{type:s.I}],useTransition:[{type:s.I}],disabled:[{type:s.I}],dir:[{type:s.I}],gutterDblClickDuration:[{type:s.I}],dragStart:[{type:s.U}],dragEnd:[{type:s.U}],gutterClick:[{type:s.U}],gutterDblClick:[{type:s.U}],transitionEnd:[{type:s.U}],gutterEls:[{type:s.rb,args:["gutterEls"]}]};class _e{constructor(e,n,t,o){this.ngZone=e,this.elRef=n,this.renderer=t,this.split=o,this._order=null,this._size=null,this._minSize=null,this._maxSize=null,this._lockSize=!1,this._visible=!0,this.lockListeners=[],this.renderer.addClass(this.elRef.nativeElement,"as-split-area")}set order(e){this._order=Ae(e,null),this.split.updateArea(this,!0,!1)}get order(){return this._order}set size(e){this._size=Ae(e,null),this.split.updateArea(this,!1,!0)}get size(){return this._size}set minSize(e){this._minSize=Ae(e,null),this.split.updateArea(this,!1,!0)}get minSize(){return this._minSize}set maxSize(e){this._maxSize=Ae(e,null),this.split.updateArea(this,!1,!0)}get maxSize(){return this._maxSize}set lockSize(e){this._lockSize=ke(e),this.split.updateArea(this,!1,!0)}get lockSize(){return this._lockSize}set visible(e){this._visible=ke(e),this._visible?(this.split.showArea(this),this.renderer.removeClass(this.elRef.nativeElement,"as-hidden")):(this.split.hideArea(this),this.renderer.addClass(this.elRef.nativeElement,"as-hidden"))}get visible(){return this._visible}ngOnInit(){this.split.addArea(this),this.ngZone.runOutsideAngular(()=>{this.transitionListener=this.renderer.listen(this.elRef.nativeElement,"transitionend",e=>{"flex-basis"===e.propertyName&&this.split.notify("transitionEnd",-1)})})}setStyleOrder(e){this.renderer.setStyle(this.elRef.nativeElement,"order",e)}setStyleFlex(e,n,t,o,s){this.renderer.setStyle(this.elRef.nativeElement,"flex-grow",e),this.renderer.setStyle(this.elRef.nativeElement,"flex-shrink",n),this.renderer.setStyle(this.elRef.nativeElement,"flex-basis",t),!0===o?this.renderer.addClass(this.elRef.nativeElement,"as-min"):this.renderer.removeClass(this.elRef.nativeElement,"as-min"),!0===s?this.renderer.addClass(this.elRef.nativeElement,"as-max"):this.renderer.removeClass(this.elRef.nativeElement,"as-max")}lockEvents(){this.ngZone.runOutsideAngular(()=>{this.lockListeners.push(this.renderer.listen(this.elRef.nativeElement,"selectstart",e=>!1)),this.lockListeners.push(this.renderer.listen(this.elRef.nativeElement,"dragstart",e=>!1))})}unlockEvents(){for(;this.lockListeners.length>0;){const e=this.lockListeners.pop();e&&e()}}ngOnDestroy(){this.unlockEvents(),this.transitionListener&&this.transitionListener(),this.split.removeArea(this)}}_e.\u0275fac=function(e){return new(e||_e)(s.Qc(s.S),s.Qc(s.v),s.Qc(s.bb),s.Qc(Te))},_e.\u0275dir=s.Lc({type:_e,selectors:[["as-split-area"],["","as-split-area",""]],inputs:{order:"order",size:"size",minSize:"minSize",maxSize:"maxSize",lockSize:"lockSize",visible:"visible"},exportAs:["asSplitArea"]}),_e.ctorParameters=()=>[{type:s.S},{type:s.v},{type:s.bb},{type:Te}],_e.propDecorators={order:[{type:s.I}],size:[{type:s.I}],minSize:[{type:s.I}],maxSize:[{type:s.I}],lockSize:[{type:s.I}],visible:[{type:s.I}]};class je{static forRoot(){return{ngModule:je,providers:[]}}static forChild(){return{ngModule:je,providers:[]}}}je.\u0275mod=s.Oc({type:je}),je.\u0275inj=s.Nc({factory:function(e){return new(e||je)},imports:[[i.c]]}),("undefined"==typeof ngJitMode||ngJitMode)&&s.wd(je,{declarations:function(){return[Te,_e]},imports:function(){return[i.c]},exports:function(){return[Te,_e]}});var Fe=t("1NbL");let Pe=class{constructor(){}ngOnInit(){}};Pe.ctorParameters=()=>[],Pe=Object(o.a)([Object(s.n)({selector:"app-divider",template:'<div class="wrapper">\n  <div class="divider div-transparent"></div>\n</div>\n',styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\n.wrapper {\n  padding-bottom: 4px;\n}\n.divider {\n  position: relative;\n  margin-top: 4px;\n  height: 1px;\n}\n.div-transparent:before {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 5%;\n  right: 5%;\n  width: 90%;\n  height: 1px;\n  background-image: linear-gradient(to right, transparent, var(--input-basic-border-color), transparent);\n}"]})],Pe);var Me=t("WONP"),ze=t("u47x");let Be=class{constructor(e,n){this.toolApiService=e,this.cdr=n,this.edit_mode=!1,this.form=new l.e({alias:new l.d("",[l.n.required,l.n.pattern("[a-z0-9]+(?:[._-]{1,2}[a-z0-9]+)*")]),name:new l.d("",[l.n.required]),description:new l.d("")})}ngOnInit(){1==this.edit_mode&&this.toolApiService.getTool(this.tool_id).subscribe(e=>{let n=e.alias,t=e.name,o=e.description;this.form.get("alias").setValue(n),this.form.get("alias").disable(),this.form.get("name").setValue(t),this.form.get("description").setValue(o),this.cdr.markForCheck()})}createTool(){Object(p.a)(u.a).pipe(Object(f.a)(e=>1==this.edit_mode?this.toolApiService.editTool(this.tool_id,this.form.value):this.toolApiService.createTool(this.form.value)),Object(C.b)(e=>e),Object(w.a)(e=>{this.close.next()})).subscribe()}};Be.ctorParameters=()=>[{type:L},{type:s.k}],Be.propDecorators={close:[{type:s.I,args:["close"]}],edit_mode:[{type:s.I,args:["edit_mode"]}],tool_id:[{type:s.I,args:["tool_id"]}]},Be=Object(o.a)([Object(s.n)({selector:"app-tool-create",template:'<nb-card fxFill class="dialog">\n  <nb-card-header fxLayoutAlign="space-between center">\n\n    <div fxLayoutAlign="start center" fxLayout="row">\n\n      <button (click)="close.next(true)" shape="round" ghost status="basic" class="action" size="large" nbButton>\n        <nb-icon icon="arrow-back-outline">\n\n        </nb-icon>\n      </button>\n\n      <span class="subtitle text-hint lineV">\n        Create Tool\n      </span>\n\n    </div>\n\n    <button (click)="close.next(true)" shape="round" ghost status="basic" class="action" size="large" nbButton>\n      <nb-icon icon="info">\n\n      </nb-icon>\n    </button>\n\n\n  </nb-card-header>\n  <nb-card-body [formGroup]="form">\n    <div fxLayout="column" fxLayoutGap="1rem">\n\n\n      \x3c!-- --\x3e\n\n\n\n\n\n      \x3c!--  --\x3e\n      <div>\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Alias\n          </p>\n        </div>\n\n        <nb-form-field>\n          <nb-icon icon="at" nbPrefix></nb-icon>\n          <input cdkFocusInitial fieldSize="small" [status]="form.controls[\'alias\'].valid ? \'primary\' : \'basic\' "\n            formControlName="alias" fullWidth nbInput placeholder="Alias">\n\n        </nb-form-field>\n\n      </div>\n      <app-divider></app-divider>\n\n      <div s>\n        <div>\n          <p class="subtitle-2 text-hint">\n            Name\n          </p>\n        </div>\n\n\n        <nb-form-field>\n\n          <input fieldSize="small" [status]="form.controls[\'name\'].valid ? \'primary\' : \'basic\' " formControlName="name"\n            fullWidth nbInput placeholder="Name">\n        </nb-form-field>\n\n\n      </div>\n      <app-divider></app-divider>\n      <div>\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Description\n          </p>\n        </div>\n\n\n        <nb-form-field>\n\n          <textarea fieldSize="small" [status]="form.controls[\'description\'].valid ? \'primary\' : \'basic\' "\n            formControlName="description" style="resize: none;" fullWidth nbInput\n            placeholder="Description (Optional) "></textarea>\n        </nb-form-field>\n\n\n      </div>\n      <app-divider></app-divider>\n    </div>\n  </nb-card-body>\n\n\n  <nb-card-footer fxLayoutAlign="end" fxLayoutGap="1rem">\n    \x3c!-- <button hero status="basic" nbButton (click)="ref.close()">Go Back</button> --\x3e\n\n    <button fullWidth [disabled]="form.invalid" (click)="createTool()" filled status="success" nbButton>Save</button>\n  </nb-card-footer>\n</nb-card>\n',styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\nnb-card {\n  max-height: calc(100vh - 7rem);\n  margin: 0;\n}\nnb-card .container {\n  margin-top: 1rem;\n}\nnb-card textarea {\n  resize: none;\n}\n.label-text {\n  border-left: 2px var(--text-hint-color) solid !important;\n  margin-bottom: 1rem;\n  padding-left: 4px;\n}\n.subtitle {\n  margin: 0;\n  padding-left: 4px;\n}\nnb-card-header {\n  padding: 0.4rem;\n  box-shadow: 2px 2px 3px rgba(0, 0, 0, 0.16), 2px 2px 3px rgba(0, 0, 0, 0.23);\n}\nnb-card-footer {\n  padding: 0;\n}\nnb-card {\n  border: 0;\n}\n.buildBtn {\n  border-radius: 0;\n}"]})],Be);let Oe=class{constructor(e,n,t,o,s){this.fb=e,this.toolApiService=n,this.cdr=t,this.drawerMngr=o,this.document=s,this.LOADING=!1,this.build_id="6023ed566c2cdfd6f2edb435",this.form=new l.e({id:new l.d(""),entrypoint:this.fb.array([new l.d({value:"",disabled:!0})]),cmd:this.fb.array([this.fb.control("/bin/cmd")]),args:this.fb.array([this.fb.control("hello"),this.fb.control("hello")]),substitute_var:new l.d(!0),variables:new l.b([]),success_endpoint:new l.d("http://success_endpoint.com/usr/bin/mobsf"),failure_endpoint:new l.d(""),config:new l.e({process:new l.b([]),reserved:new l.b([]),_reserved:new l.e({}),system:new l.b([]),_process:new l.e({input_api:new l.d(""),input_api_token:new l.d(""),output_api:new l.d(""),file_upload_api:new l.d("")}),_system:new l.e({base_path:new l.d(""),input_dir:new l.d(""),output_dir:new l.d(""),results_json:new l.d(""),results_schema:new l.d(""),log_to_file:new l.d(!0),stdout_file:new l.d(""),stderr_file:new l.d(""),enable_logging:new l.d(!0),max_output_filesize:new l.d(1e3),sample_inputfile:new l.d(""),sample_outputfile:new l.d("")})})})}getArgs(){return this.form.get("args")}deleteArg(e){this.getArgs().removeAt(e)}getVariables(){return this.form.get("variables")}getConfProcess(){return this.form.get("config").get("process")}getConfSystem(){return this.form.get("config").get("system")}getConfReserved(){return this.form.get("config").get("reserved")}deleteVariables(e){this.getVariables().removeAt(e)}deleteConfProcess(e){this.getConfProcess().removeAt(e)}deleteConfSystem(e){this.getConfSystem().removeAt(e)}deleteConfReserved(e){this.getConfReserved().removeAt(e)}ngOnInit(){this.loadConfig()}addArg(){this.getArgs().push(this.fb.control(""))}addVar(){this.getVariables().push(new l.e({key:new l.d(""),value:new l.d("")}))}addConfProcess(){this.getConfProcess().push(new l.e({key:new l.d(""),value:new l.d("")}))}addSystemProcess(){this.getConfSystem().push(new l.e({key:new l.d(""),value:new l.d("")}))}addReservedProcess(){this.getConfReserved().push(new l.e({key:new l.d(""),value:new l.d("")}))}formToJson(){let e=this.form.getRawValue(),n={};e.variables.forEach(e=>{n[e.key]=e.value}),e.variables=n;let t={process:{},reserved:{},system:{}};return e.config.process.forEach(e=>{t.process[e.key]=e.value}),e.config.reserved.forEach(e=>{t.reserved[e.key]=e.value}),e.config.system.forEach(e=>{t.system[e.key]=e.value}),delete e._process,delete e._reserved,delete e._system,e.config=t,e}save(){this.toolApiService.updateBuildConfig(this.build_id,this.formToJson()).subscribe(e=>{})}loadConfig(){this.LOADING=!0,Object(p.a)(this.config).subscribe(e=>{if(console.log("config",e),e||(e={}),e.id&&this.form.setControl("id",this.fb.control(e.id)),e.cmd){let n=[];e.cmd.forEach(e=>{n.push(this.fb.control(e))}),this.form.setControl("cmd",this.fb.array(n))}if(e.entrypoint){let n=this.fb.array([]);e.entrypoint.forEach(e=>{n.push(this.fb.control({value:e,disabled:!0}))}),this.form.setControl("entrypoint",n)}if(e.entrypoint){let n=[];e.args.forEach(e=>{n.push(this.fb.control(e))}),this.form.setControl("args",this.fb.array(n))}if(e.substitute_var&&this.form.setControl("substitute_var",this.fb.control(e.substitute_var)),e.success_endpoint&&this.form.setControl("success_endpoint",this.fb.control(e.success_endpoint)),e.failure_endpoint&&this.form.setControl("failure_endpoint",this.fb.control(e.failure_endpoint)),e.config){let n=[],t=[],o=[];e.config.process&&Object.keys(e.config.process).forEach(t=>{n.push(this.fb.group({key:this.fb.control(t),value:this.fb.control(e.config.process[t])}))}),e.config.system&&Object.keys(e.config.system).forEach(n=>{t.push(this.fb.group({key:this.fb.control(n),value:this.fb.control(e.config.system[n])}))}),e.config.reserved&&Object.keys(e.config.reserved).forEach(n=>{o.push(this.fb.group({key:this.fb.control({value:n,disabled:!0}),value:this.fb.control({value:e.config.reserved[n],disabled:!0})}))});let s=this.fb.group({process:this.fb.array(n),reserved:this.fb.array(o),system:this.fb.array(t)});this.form.setControl("config",s)}this.LOADING=!1,this.cdr.markForCheck()})}run(){this.toolApiService.execJob(this.id,this.formToJson()).subscribe(e=>{let n=e._id;this.openLogs(this.logsTemplate,n)})}openLogs(e,n,t=_.a.Left,o="50%",s=!0,i=!0,r){this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:t,template:e,size:o,closeOnOutsideClick:s,parentContainer:r,isRoot:i,zIndex:1e3,cssClass:"backdrop_color",context:{id:n}}).onDestroy(()=>{this.document.body.classList.remove("cdk-global-scrollblock")})}};Oe.ctorParameters=()=>[{type:l.c},{type:L},{type:s.k},{type:j.a},{type:Document,decorators:[{type:s.D,args:[i.d]}]}],Oe.propDecorators={logsTemplate:[{type:s.qb,args:["logsTemplate",{static:!1}]}],id:[{type:s.I,args:["id"]}],config:[{type:s.I,args:["config"]}],close:[{type:s.I,args:["close"]}],refrence_id:[{type:s.I,args:["refrence_id"]}],build_id:[{type:s.I,args:["build_id"]}]},Oe=Object(o.a)([Object(s.n)({selector:"app-job-config",template:'<ng-container *ngIf=" LOADING == false ; else loading">\n\n\n\n  <nb-card fxFill [formGroup]="form">\n\n\n    <nb-card-header fxLayoutAlign="space-between center">\n\n      <div fxLayoutAlign="start center" fxLayout="row">\n\n        <button (click)="close.next(true)" shape="round" ghost status="basic" class="action" size="large" nbButton>\n          <nb-icon icon="arrow-back-outline">\n\n          </nb-icon>\n        </button>\n\n        <span class="subtitle text-hint lineV">\n          Job Executor\n        </span>\n\n      </div>\n\n      <button (click)="close.next(true)" shape="round" ghost status="basic" class="action" size="large" nbButton>\n        <nb-icon icon="info">\n\n        </nb-icon>\n      </button>\n\n\n    </nb-card-header>\n\n    <nb-card-body>\n\n\n\n\n\n      <div fxLayoutAlign="space-between center" fxLayout="row" fxLayoutGap="1rem">\n        <p class="subtitle text-basic">\n          Job Configuration\n        </p>\n\n        <button shape="round" ghost nbButton>\n          <nb-icon icon="info"></nb-icon>\n        </button>\n      </div>\n      <app-divider></app-divider>\n\n\n\n      \x3c!-- Entrypoint --\x3e\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Entrypoint\n          </p>\n        </div>\n\n\n        <ng-container formArrayName="entrypoint">\n\n          <ng-container *ngFor="let entrypoint of this.form.get(\'entrypoint\').controls ; let i=index ">\n\n            <div fxLayout="row" fxLayoutGap="1rem">\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth [formControlName]="i" nbInput placeholder="/bin/watchdog">\n              </nb-form-field>\n            </div>\n\n          </ng-container>\n        </ng-container>\n\n      </div>\n\n      <app-divider></app-divider>\n\n      \x3c!-- Command --\x3e\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Command\n          </p>\n        </div>\n\n        <div fxFlex>\n\n\n          <ng-container formArrayName="cmd">\n\n            <ng-container *ngFor="let _cmd of this.form.get(\'cmd\').controls ; let i=index ">\n\n\n              <div [style.marginBottom]="\'0.5rem\'" fxLayout="row" fxLayoutGap="1rem">\n\n                <div fxLayout="row" fxLayoutGap="1rem">\n                  <nb-form-field fxFlex fieldSize="small">\n                    <input fullWidth cdkFocusInitial [formControlName]="i" nbInput placeholder="/usr/bin/mobsf">\n                  </nb-form-field>\n                </div>\n\n\n\n\n              </div>\n\n\n            </ng-container>\n\n\n          </ng-container>\n\n        </div>\n\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Arguments --\x3e\n      <div fxLayout="column">\n\n        <div fxLayout="row">\n          <p fxFlex class="subtitle-2 text-hint">\n            Arguments\n          </p>\n\n          <button (click)="addArg()" ghost nbButton status="danger">\n            Add\n          </button>\n\n        </div>\n\n\n        <div fxFlex>\n\n          <ng-container formArrayName="args">\n\n            <ng-container *ngFor="let arg of this.form.get(\'args\').controls ; let i=index ">\n\n\n              <div [style.marginBottom]="\'0.5rem\'" fxLayout="row" fxLayoutGap="1rem">\n                <nb-form-field fxFlex fieldSize="small">\n\n\n                  <input fullWidth [formControlName]="i" nbInput placeholder="/usr/bin/mobsf">\n\n\n                </nb-form-field>\n\n\n                <button ghost nbSuffix nbButton (click)="deleteArg(i)">\n                  <nb-icon icon="trash-outline">\n                  </nb-icon>\n                </button>\n\n              </div>\n\n\n            </ng-container>\n\n\n          </ng-container>\n        </div>\n\n        <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'args\').controls.length" fxFlex>\n          <p class="subtitle-2 text-hint">\n            No Arguments Defined\n          </p>\n        </div>\n\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Variables --\x3e\n      <div fxLayout="column">\n\n        <div fxLayout="row">\n          <p fxFlex class="subtitle-2 text-hint">\n            Variables\n          </p>\n\n\n\n          <button (click)="addVar()" ghost nbButton status="danger">\n            Add\n          </button>\n\n\n        </div>\n\n\n        <ng-container formArrayName="variables">\n\n          <ng-container *ngFor="let variable of this.form.get(\'variables\').controls ; let i=index ">\n\n            <div [style.marginBottom]="\'0.5rem\'" [formGroupName]="i" fxLayout="row" fxLayoutGap="1rem">\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <span nbPrefix>$</span>\n\n                <input fullWidth formControlName="key" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n\n\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="value" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n              <button ghost nbButton (click)="deleteVariables(i)">\n                <nb-icon icon="trash-outline">\n                </nb-icon>\n              </button>\n\n\n\n\n            </div>\n\n\n          </ng-container>\n\n\n        </ng-container>\n\n\n        <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'variables\').controls.length" fxFlex>\n          <p class="subtitle-2 text-hint">\n            No Variables Defined\n          </p>\n        </div>\n\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Substitute Variables --\x3e\n      <div fxLayout="column">\n\n\n\n\n        <div fxLayout="row">\n          <p fxFlex class="subtitle-2 text-hint">\n            Substitute Variables\n\n          </p>\n\n\n\n\n          <nb-toggle formControlName="substitute_var"></nb-toggle>\n\n\n\n        </div>\n\n        \x3c!--  --\x3e\n   \n  \n      </div>\n\n\n      <app-divider></app-divider>\n\n\n\n\n      \x3c!-- success_endpoint --\x3e\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Success Endpoint\n          </p>\n        </div>\n\n        <div fxLayout="row" fxLayoutGap="1rem">\n          <nb-form-field fxFlex fieldSize="small">\n            <input fullWidth formControlName="success_endpoint" nbInput\n              placeholder="http://success_endpoint.com/usr/bin/mobsf">\n          </nb-form-field>\n        </div>\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- failure_endpoint --\x3e\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Failure Endpoint\n          </p>\n        </div>\n\n        <div fxLayout="row" fxLayoutGap="1rem">\n          <nb-form-field fxFlex fieldSize="small">\n            <input fullWidth formControlName="failure_endpoint" nbInput\n              placeholder="http://failure_endpoint.com/usr/bin/mobsf">\n          </nb-form-field>\n        </div>\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Process Env. Variables --\x3e\n      <div fxLayout="column" formGroupName="config">\n\n        <div fxLayout="row">\n          <p fxFlex class="subtitle-2 text-hint">\n            Environment Variables\n          </p>\n\n\n\n          <button (click)="addConfProcess()" ghost nbButton status="danger">\n            Add\n          </button>\n\n\n        </div>\n\n\n        <ng-container formArrayName="process">\n\n          <ng-container *ngFor="let variable of this.form.get(\'config\').get(\'process\').controls ; let i=index ">\n\n            <div [style.marginBottom]="\'0.5rem\'" [formGroupName]="i" fxLayout="row" fxLayoutGap="1rem">\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <span nbPrefix>$</span>\n\n                <input fullWidth formControlName="key" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n\n\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="value" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n              <button ghost nbButton (click)="deleteConfProcess(i)">\n                <nb-icon icon="trash-outline">\n                </nb-icon>\n              </button>\n\n\n\n\n            </div>\n\n\n          </ng-container>\n\n\n        </ng-container>\n\n\n        <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'config\').get(\'process\').controls .length"\n          fxFlex>\n          <p class="subtitle-2 text-hint">\n            No Environment Variables Defined\n          </p>\n        </div>\n\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Reserved Env. Variables --\x3e\n      <div fxLayout="column" formGroupName="config">\n\n        <div fxLayout="row">\n          <p fxFlex class="subtitle-2 text-hint">\n            Reserved Environment Variables\n          </p>\n\n\n\n          <button (click)="addReservedProcess()" ghost nbButton status="danger">\n            Add\n          </button>\n\n\n        </div>\n\n\n        <ng-container formArrayName="reserved">\n\n          <ng-container *ngFor="let variable of this.form.get(\'config\').get(\'reserved\').controls ; let i=index ">\n\n            <div [style.marginBottom]="\'0.5rem\'" [formGroupName]="i" fxLayout="row" fxLayoutGap="1rem">\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <span nbPrefix>$</span>\n\n                <input fullWidth formControlName="key" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n\n\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="value" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n              <button ghost nbButton (click)="deleteConfReserved(i)">\n                <nb-icon icon="trash-outline">\n                </nb-icon>\n              </button>\n\n\n\n\n            </div>\n\n\n          </ng-container>\n\n\n        </ng-container>\n\n        <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'config\').get(\'reserved\').controls .length"\n          fxFlex>\n          <p class="subtitle-2 text-hint">\n            No Reserved Variables Defined\n          </p>\n        </div>\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Systen Env. Variables --\x3e\n      <div fxLayout="column" formGroupName="config">\n\n        <div fxLayout="row">\n          <p fxFlex class="subtitle-2 text-hint">\n            Systen Environment Variables\n          </p>\n\n\n\n          <button (click)="addSystemProcess()" ghost nbButton status="danger">\n            Add\n          </button>\n\n\n        </div>\n\n\n        <ng-container formArrayName="system">\n\n          <ng-container *ngFor="let variable of this.form.get(\'config\').get(\'system\').controls ; let i=index ">\n\n            <div [style.marginBottom]="\'0.5rem\'" [formGroupName]="i" fxLayout="row" fxLayoutGap="1rem">\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <span nbPrefix>$</span>\n\n                <input fullWidth formControlName="key" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n\n\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="value" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n              <button ghost nbButton (click)="deleteConfSystem(i)">\n                <nb-icon icon="trash-outline">\n                </nb-icon>\n              </button>\n\n\n\n\n            </div>\n\n\n          </ng-container>\n\n\n        </ng-container>\n\n        <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'config\').get(\'system\').controls .length"\n          fxFlex>\n          <p class="subtitle-2 text-hint">\n            No System Variables Defined\n          </p>\n        </div>\n      </div>\n\n      <app-divider></app-divider>\n\n    </nb-card-body>\n\n\n    <nb-card-footer (click)="run()">\n\n      <button class="buildBtn" fxLayoutAlign="space-between center" size="giant" status="danger" filled fullWidth\n        nbButton>\n\n        <span>\n          Run\n\n        </span>\n        <nb-icon icon="play-circle"></nb-icon>\n\n      </button>\n    </nb-card-footer>\n\n  </nb-card>\n\n\n\n\n\n</ng-container>\n\n<ng-template #loading>\n  <div fxLayoutAlign="center center">\n    <ngx-progress-spinner></ngx-progress-spinner>\n  </div>\n\n</ng-template>\n\n<ng-template #logsTemplate let-close="close" let-context="context">\n\n  <app-log-stream  [close]="close" [deep_link]="true" [log_id]="context?.id"></app-log-stream>\n\n\n</ng-template>\n',styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\nnb-card {\n  max-height: calc(100vh - 7rem);\n  margin: 0;\n}\nnb-card .container {\n  margin-top: 1rem;\n}\nnb-card textarea {\n  resize: none;\n}\n.label-text {\n  border-left: 2px var(--text-hint-color) solid !important;\n  margin-bottom: 1rem;\n  padding-left: 4px;\n}\n.subtitle {\n  margin: 0;\n  padding-left: 4px;\n}\nnb-card-header {\n  padding: 0.4rem;\n  box-shadow: 2px 2px 3px rgba(0, 0, 0, 0.16), 2px 2px 3px rgba(0, 0, 0, 0.23);\n}\nnb-card-footer {\n  padding: 0;\n}\nnb-card {\n  border: 0;\n}\n.buildBtn {\n  border-radius: 0;\n}"]})],Oe);let De=class{};De=Object(o.a)([Object(s.N)({declarations:[te,de,pe.a,$,ue,me,se,T,z,Pe,S,Be,B,O,q,Oe,V],imports:[Fe.a,ne.p,le.a,i.c,re,ne.n,ae.a,ne.z.forRoot(),ne.E.forRoot({name:"default"}),ce.a,ne.i.forChild(),ne.e,l.f,he,ne.q,ne.f,ne.b,ne.a,je,ne.o,ne.l,ne.c,l.m,ne.i.forChild(),ne.y,ne.q,ne.A,ne.g,Me.a,ne.C,ne.w,ae.a,ze.a,a.c,ce.a,W.b,ne.G,ne.d,ne.D,ne.u,ne.h,ne.d,ne.x],providers:[L,P]})],De)}}]);