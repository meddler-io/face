!function(){function e(e){return function(e){if(Array.isArray(e))return n(e)}(e)||function(e){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(e))return Array.from(e)}(e)||function(e,t){if(!e)return;if("string"==typeof e)return n(e,t);var o=Object.prototype.toString.call(e).slice(8,-1);"Object"===o&&e.constructor&&(o=e.constructor.name);if("Map"===o||"Set"===o)return Array.from(e);if("Arguments"===o||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o))return n(e,t)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function n(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,o=new Array(n);t<n;t++)o[t]=e[t];return o}function t(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function o(e,n){for(var t=0;t<n.length;t++){var o=n[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}function s(e,n,t){return n&&o(e.prototype,n),t&&o(e,t),e}(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{rtBl:function(n,o,i){"use strict";i.r(o),i.d(o,"ToolManagementModule",function(){return Be});var r,a=i("mrSG"),l=i("fXoL"),c=i("ofXK"),d=i("tyNb"),h=i("3Pt+"),u=i("tk/3"),p=i("l5mm"),m=i("XNiG"),b=i("NXyV"),f=i("LRne"),w=i("EY2u"),g=i("coGc"),x=i("eIep"),v=i("vkgz"),y=i("lJxs"),k=i("FQpF"),A=i("nYR2"),L=i("7qw2"),S=L.a+"api/v2",R=L.c+"api/v2/";!function(e){e[e.PAUSE=0]="PAUSE",e[e.RESUME=1]="RESUME",e[e.START=2]="START",e[e.STOP=3]="STOP"}(r||(r={}));var C=function(){function e(n){t(this,e),this.http=n}return s(e,[{key:"getDelay",value:function(e){return console.log("getDelay"),Object(p.a)(e)}},{key:"getLogs",value:function(e,n,t,o){var s,i=this,a=0,l=new m.a,c=0;return Object(b.a)(function(){return t.pipe().subscribe(function(t){var d=Object(f.a)(w.a).pipe(Object(g.a)(function(){return e=Object(p.a)(c),c=o,e;var e}),Object(x.a)(function(t){var o=new u.e({"X-Id":e,"X-Lines":n.toString(),"X-Seek":a+""});return i.http.get(R+"/tool/host",{headers:o,observe:"response",responseType:"text"}).pipe(Object(v.a)(function(e){var n=e.headers.get("X-File-Range"),t=e.headers.get("X-File-Size");if(null!=n&&null!=t){var o=n.split("-")[1];a=parseInt(o),parseInt(t)}}),Object(y.a)(function(e){return""+e.body}))}));if(t==r.RESUME)s&&s.unsubscribe(),s=d.pipe(Object(k.a)(function(e){return d})).subscribe(function(e){l.next(e)});else if(t==r.PAUSE)s&&(s.unsubscribe(),s=void 0);else if(t==r.STOP)return console.log("stopped"),l.complete(),void s.unsubscribe()}),l})}},{key:"createTool",value:function(e){return this.http.post(S+"/tool",e)}},{key:"editTool",value:function(e,n){return this.http.put("".concat(S,"/tool/").concat(e),n)}},{key:"runTool",value:function(e,n){return this.http.post("".concat(S,"/build/run/").concat(e),n)}},{key:"getTool",value:function(e){return this.http.get("".concat(S,"/tool/").concat(e))}},{key:"getTools",value:function(){return this.http.get(S+"/tool")}},{key:"createBuild",value:function(e,n){return this.http.post("".concat(S,"/build/").concat(e),n)}},{key:"editBuild",value:function(e,n,t){return this.http.put("".concat(S,"/build/").concat(n,"/").concat(e),t)}},{key:"updateBuildConfig",value:function(e,n){return this.http.put("".concat(S,"/build/config/").concat(e),n)}},{key:"getBuild",value:function(e,n){return this.http.get("".concat(S,"/build/").concat(e,"/").concat(n))}},{key:"getBuildConfig",value:function(e){return this.http.get("".concat(S,"/build/config/").concat(e))}},{key:"getBuilds",value:function(e){return this.http.get("".concat(S,"/builds/").concat(e))}},{key:"getBuildExecoturs",value:function(e){return this.http.get("".concat(S,"/build/executors/").concat(e))}},{key:"getBuildExecutorStatus",value:function(e){return this.http.get("".concat(S,"/build/executors/status/").concat(e))}},{key:"getToolImages",value:function(e){return this.http.get("".concat(S,"/deployment/images/").concat(e))}},{key:"getToolImageTags",value:function(e){return this.http.get("".concat(S,"/deployment/images/tags/").concat(e))}},{key:"getBuildUploadUrl",value:function(e,n){return this.http.post(S+"/build/upload/init",{id:e,filename:n})}},{key:"getBuildDownloadUrl",value:function(e){return this.http.post(S+"/build/download/init",e)}},{key:"uploadWithUrl",value:function(e,n){var t=new FormData;console.log("file_debug",e.name),console.log("file_debug",e.size),t.append("files",e);var o=new u.e,s=this.http.put(n,e,{reportProgress:!0,observe:"events",headers:o}),i=new m.a;return s.pipe(Object(A.a)(function(){return console.log("complete...")})).subscribe(function(e){if(e.type===u.d.UploadProgress){var n=Math.round(100*e.loaded/e.total);i.next({status:!1,progress:n})}else e instanceof u.f&&(i.next({status:!0,progress:100,fileData:e.body}),i.complete())}),i.asObservable()}},{key:"getDeployment",value:function(e){return this.http.post(S+"/deployment/service",{deployment_id:e})}},{key:"runDeployment",value:function(e){return this.http.post(S+"/deployment/run",{job_id:e})}},{key:"execJob",value:function(e,n){return this.http.post("".concat(S,"/job/exec/").concat(e),n)}},{key:"stopDeployment",value:function(e){return this.http.delete(S+"/deployment/service",{params:{job_id:e}})}},{key:"getJobStatus",value:function(e){return this.http.get("".concat(S,"/job/status/").concat(e))}},{key:"getJobs",value:function(e){return this.http.get("".concat(S,"/jobs/").concat(e))}},{key:"purgeDeployment",value:function(){return this.http.delete(S+"/deployment/purge")}},{key:"getDeployments",value:function(e){return this.http.get("".concat(S,"/deployment/services/").concat(e))}},{key:"createDeployment",value:function(e){return this.http.post("".concat(S,"/deployment/service/").concat(e),{})}}]),e}();C.ctorParameters=function(){return[{type:u.b}]},C=Object(a.a)([Object(l.F)({providedIn:"root"})],C);var I=function(){function e(n,o,s){t(this,e),this.fb=n,this.toolApiService=o,this.cdr=s,this.LOADING=!1,this.build_id="6023ed566c2cdfd6f2edb435",this.form=new h.e({id:new h.d(""),entrypoint:this.fb.array([new h.d("/bin/entrypoint")]),cmd:this.fb.array([this.fb.control("/bin/cmd")]),args:this.fb.array([this.fb.control("hello"),this.fb.control("hello")]),substitute_var:new h.d(!0),variables:new h.b([new h.e({key:new h.d("key"),value:new h.d("value")})]),success_endpoint:new h.d("http://success_endpoint.com/usr/bin/mobsf"),failure_endpoint:new h.d(""),config:new h.e({process:new h.b([new h.e({key:new h.d("key"),value:new h.d("value")})]),reserved:new h.b([new h.e({key:new h.d("key"),value:new h.d("value")})]),_reserved:new h.e({message_queue_topic:new h.d("")}),system:new h.b([new h.e({key:new h.d("key"),value:new h.d("value")})]),_process:new h.e({input_api:new h.d(""),input_api_token:new h.d(""),output_api:new h.d(""),file_upload_api:new h.d("")}),_system:new h.e({base_path:new h.d(""),input_dir:new h.d(""),output_dir:new h.d(""),results_json:new h.d(""),results_schema:new h.d(""),log_to_file:new h.d(!0),stdout_file:new h.d(""),stderr_file:new h.d(""),enable_logging:new h.d(!0),max_output_filesize:new h.d(1e3),sample_inputfile:new h.d(""),sample_outputfile:new h.d("")})})})}return s(e,[{key:"getArgs",value:function(){return this.form.get("args")}},{key:"deleteArg",value:function(e){this.getArgs().removeAt(e)}},{key:"getVariables",value:function(){return this.form.get("variables")}},{key:"getConfProcess",value:function(){return this.form.get("config").get("process")}},{key:"getConfSystem",value:function(){return this.form.get("config").get("system")}},{key:"getConfReserved",value:function(){return this.form.get("config").get("reserved")}},{key:"deleteVariables",value:function(e){this.getVariables().removeAt(e)}},{key:"deleteConfProcess",value:function(e){this.getConfProcess().removeAt(e)}},{key:"deleteConfSystem",value:function(e){this.getConfSystem().removeAt(e)}},{key:"deleteConfReserved",value:function(e){this.getConfReserved().removeAt(e)}},{key:"ngOnInit",value:function(){this.loadConfig()}},{key:"addArg",value:function(){this.getArgs().push(this.fb.control(""))}},{key:"addVar",value:function(){this.getVariables().push(new h.e({key:new h.d(""),value:new h.d("")}))}},{key:"addConfProcess",value:function(){this.getConfProcess().push(new h.e({key:new h.d(""),value:new h.d("")}))}},{key:"addSystemProcess",value:function(){this.getConfSystem().push(new h.e({key:new h.d(""),value:new h.d("")}))}},{key:"addReservedProcess",value:function(){this.getConfReserved().push(new h.e({key:new h.d(""),value:new h.d("")}))}},{key:"formToJson",value:function(){var e=this.form.getRawValue(),n={};e.variables.forEach(function(e){n[e.key]=e.value});var t={process:{},reserved:{},system:{}};return e.config.process.forEach(function(e){t.process[e.key]=e.value}),e.config.reserved.forEach(function(e){t.reserved[e.key]=e.value}),e.config.system.forEach(function(e){t.system[e.key]=e.value}),delete e._process,delete e._reserved,delete e._system,e.config=t,e}},{key:"save",value:function(){this.toolApiService.updateBuildConfig(this.build_id,this.formToJson()).subscribe()}},{key:"loadConfig",value:function(){var e=this;this.LOADING=!0,this.toolApiService.getBuildConfig(this.build_id).subscribe(function(n){if(n||(n={}),n.id&&e.form.setControl("id",e.fb.control(n.id)),n.cmd){var t=[];n.cmd.forEach(function(n){t.push(e.fb.control(n))}),e.form.setControl("cmd",e.fb.array(t))}if(n.entrypoint){var o=[];n.entrypoint.forEach(function(n){o.push(e.fb.control(n))}),e.form.setControl("entrypoint",e.fb.array(o))}if(n.args){var s=[];n.args.forEach(function(n){s.push(e.fb.control(n))}),e.form.setControl("args",e.fb.array(s))}if(n.substitute_var&&e.form.setControl("substitute_var",e.fb.control(n.substitute_var)),n.success_endpoint&&e.form.setControl("success_endpoint",e.fb.control(n.success_endpoint)),n.failure_endpoint&&e.form.setControl("failure_endpoint",e.fb.control(n.failure_endpoint)),n.config){var i=[],r=[],a=[];n.config.process&&Object.keys(n.config.process).forEach(function(t){i.push(e.fb.group({key:e.fb.control(t),value:e.fb.control(n.config.process[t])}))}),n.config.system&&Object.keys(n.config.system).forEach(function(t){r.push(e.fb.group({key:e.fb.control(t),value:e.fb.control(n.config.system[t])}))}),n.config.reserved&&Object.keys(n.config.reserved).forEach(function(t){a.push(e.fb.group({key:e.fb.control(t),value:e.fb.control(n.config.reserved[t])}))});var l=e.fb.group({process:e.fb.array(i),reserved:e.fb.array(a),system:e.fb.array(r)});e.form.setControl("config",l)}e.LOADING=!1,e.cdr.markForCheck()})}}]),e}();I.ctorParameters=function(){return[{type:h.c},{type:C},{type:l.k}]},I.propDecorators={close:[{type:l.I,args:["close"]}],refrence_id:[{type:l.I,args:["refrence_id"]}],build_id:[{type:l.I,args:["build_id"]}]},I=Object(a.a)([Object(l.n)({selector:"app-build-config",template:'<ng-container *ngIf=" LOADING == false ; else loading">\n\n\n\n  <nb-card fxFill [formGroup]="form">\n\n\n    <nb-card-header fxLayoutAlign="space-between center">\n\n      <div fxLayoutAlign="start center" fxLayout="row">\n\n        <button (click)="close.next(true)" shape="round" ghost status="basic" class="action" size="large" nbButton>\n          <nb-icon icon="arrow-back-outline">\n\n          </nb-icon>\n        </button>\n\n        <span class="subtitle text-hint lineV">\n          Build Creator\n        </span>\n\n      </div>\n\n      <button (click)="close.next(true)" shape="round" ghost status="basic" class="action" size="large" nbButton>\n        <nb-icon icon="info">\n\n        </nb-icon>\n      </button>\n\n\n    </nb-card-header>\n\n    <nb-card-body>\n\n\n\n\n\n      <div fxLayoutAlign="space-between center" fxLayout="row" fxLayoutGap="1rem">\n        <p class="subtitle text-basic">\n          Build Configuration\n        </p>\n\n        <button shape="round" ghost nbButton>\n          <nb-icon icon="info"></nb-icon>\n        </button>\n      </div>\n      <app-divider></app-divider>\n\n      \x3c!-- Identifier --\x3e\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Identifier\n          </p>\n        </div>\n\n        <div fxLayout="row" fxLayoutGap="1rem">\n          <nb-form-field fxFlex fieldSize="small">\n            <input fullWidth cdkFocusInitial formControlName="id" nbInput placeholder="/bin/watchdog">\n          </nb-form-field>\n        </div>\n      </div>\n\n      \x3c!-- Entrypoint --\x3e\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Entrypoint\n          </p>\n        </div>\n\n\n        <ng-container formArrayName="entrypoint">\n\n          <ng-container *ngFor="let entrypoint of this.form.get(\'entrypoint\').controls ; let i=index ">\n\n            <div fxLayout="row" fxLayoutGap="1rem">\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth cdkFocusInitial [formControlName]="i" nbInput placeholder="/bin/watchdog">\n              </nb-form-field>\n            </div>\n\n          </ng-container>\n        </ng-container>\n\n      </div>\n\n      <app-divider></app-divider>\n\n      \x3c!-- Command --\x3e\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Command\n          </p>\n        </div>\n\n\n\n\n        <ng-container formArrayName="cmd">\n\n          <ng-container *ngFor="let _cmd of this.form.get(\'cmd\').controls ; let i=index ">\n\n\n            \x3c!-- <div [style.marginBottom]="\'0.5rem\'" fxLayout="row" fxLayoutGap="1rem"> --\x3e\n\n            <div fxFlex  fxLayoutGap="1rem">\n              <nb-form-field  fieldSize="small">\n                <input cdkFocusInitial fullWidth [formControlName]="i" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n            </div>\n\n\n\n\n            \x3c!-- </div> --\x3e\n\n\n          </ng-container>\n\n\n        </ng-container>\n\n\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Arguments --\x3e\n      <div fxLayout="column">\n\n        <div fxLayout="row">\n          <p fxFlex class="subtitle-2 text-hint">\n            Arguments\n          </p>\n\n          <button (click)="addArg()" ghost nbButton status="danger">\n            Add\n          </button>\n\n        </div>\n\n\n        <div fxFlex>\n\n          <ng-container formArrayName="args">\n\n            <ng-container *ngFor="let arg of this.form.get(\'args\').controls ; let i=index ">\n\n\n              <div [style.marginBottom]="\'0.5rem\'" fxLayout="row" fxLayoutGap="1rem">\n                <nb-form-field fxFlex fieldSize="small">\n                  <input fullWidth cdkFocusInitial [formControlName]="i" nbInput placeholder="/usr/bin/mobsf">\n\n\n                </nb-form-field>\n\n\n                <button ghost nbSuffix nbButton (click)="deleteArg(i)">\n                  <nb-icon icon="trash-outline">\n                  </nb-icon>\n                </button>\n\n              </div>\n\n\n            </ng-container>\n\n\n          </ng-container>\n        </div>\n\n        <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'args\').controls.length" fxFlex>\n          <p class="subtitle-2 text-hint">\n            No Arguments Defined\n          </p>\n        </div>\n\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Variables --\x3e\n      <div fxLayout="column">\n\n        <div fxLayout="row">\n          <p fxFlex class="subtitle-2 text-hint">\n            Variables\n          </p>\n\n\n\n          <button (click)="addVar()" ghost nbButton status="danger">\n            Add\n          </button>\n\n\n        </div>\n\n\n        <ng-container formArrayName="variables">\n\n          <ng-container *ngFor="let variable of this.form.get(\'variables\').controls ; let i=index ">\n\n            <div [style.marginBottom]="\'0.5rem\'" [formGroupName]="i" fxLayout="row" fxLayoutGap="1rem">\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="key" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n\n\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="value" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n              <button ghost nbButton (click)="deleteVariables(i)">\n                <nb-icon icon="trash-outline">\n                </nb-icon>\n              </button>\n\n\n\n\n            </div>\n\n\n          </ng-container>\n\n\n        </ng-container>\n\n\n        <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'variables\').controls.length" fxFlex>\n          <p class="subtitle-2 text-hint">\n            No Variables Defined\n          </p>\n        </div>\n\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Substitute Variables --\x3e\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Substitute Variables\n          </p>\n        </div>\n\n        <div fxLayout="row" fxLayoutGap="1rem">\n\n          <nb-checkbox formControlName="substitute_var">Substitute Variables </nb-checkbox>\n\n        </div>\n      </div>\n\n\n      <app-divider></app-divider>\n\n\n\n\n      \x3c!-- success_endpoint --\x3e\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Success Endpoint\n          </p>\n        </div>\n\n        <div fxLayout="row" fxLayoutGap="1rem">\n          <nb-form-field fxFlex fieldSize="small">\n            <input fullWidth cdkFocusInitial formControlName="success_endpoint" nbInput\n              placeholder="http://success_endpoint.com/usr/bin/mobsf">\n          </nb-form-field>\n        </div>\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- failure_endpoint --\x3e\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Failure Endpoint\n          </p>\n        </div>\n\n        <div fxLayout="row" fxLayoutGap="1rem">\n          <nb-form-field fxFlex fieldSize="small">\n            <input fullWidth cdkFocusInitial formControlName="failure_endpoint" nbInput\n              placeholder="http://failure_endpoint.com/usr/bin/mobsf">\n          </nb-form-field>\n        </div>\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Process Env. Variables --\x3e\n      <div fxLayout="column" formGroupName="config">\n\n        <div fxLayout="row">\n          <p fxFlex class="subtitle-2 text-hint">\n            Environment Variables\n          </p>\n\n\n\n          <button (click)="addConfProcess()" ghost nbButton status="danger">\n            Add\n          </button>\n\n\n        </div>\n\n\n        <ng-container formArrayName="process">\n\n          <ng-container *ngFor="let variable of this.form.get(\'config\').get(\'process\').controls ; let i=index ">\n\n            <div [style.marginBottom]="\'0.5rem\'" [formGroupName]="i" fxLayout="row" fxLayoutGap="1rem">\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="key" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n\n\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="value" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n              <button ghost nbButton (click)="deleteConfProcess(i)">\n                <nb-icon icon="trash-outline">\n                </nb-icon>\n              </button>\n\n\n\n\n            </div>\n\n\n          </ng-container>\n\n\n        </ng-container>\n\n\n        <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'config\').get(\'process\').controls .length"\n          fxFlex>\n          <p class="subtitle-2 text-hint">\n            No Environment Variables Defined\n          </p>\n        </div>\n\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Reserved Env. Variables --\x3e\n      <div fxLayout="column" formGroupName="config">\n\n        <div fxLayout="row">\n          <p fxFlex class="subtitle-2 text-hint">\n            Reserved Environment Variables\n          </p>\n\n\n\n          <button (click)="addReservedProcess()" ghost nbButton status="danger">\n            Add\n          </button>\n\n\n        </div>\n\n\n        <ng-container formArrayName="reserved">\n\n          <ng-container *ngFor="let variable of this.form.get(\'config\').get(\'reserved\').controls ; let i=index ">\n\n            <div [style.marginBottom]="\'0.5rem\'" [formGroupName]="i" fxLayout="row" fxLayoutGap="1rem">\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="key" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n\n\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="value" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n              <button ghost nbButton (click)="deleteConfReserved(i)">\n                <nb-icon icon="trash-outline">\n                </nb-icon>\n              </button>\n\n\n\n\n            </div>\n\n\n          </ng-container>\n\n\n        </ng-container>\n\n        <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'config\').get(\'reserved\').controls .length"\n          fxFlex>\n          <p class="subtitle-2 text-hint">\n            No Reserved Variables Defined\n          </p>\n        </div>\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Systen Env. Variables --\x3e\n      <div fxLayout="column" formGroupName="config">\n\n        <div fxLayout="row">\n          <p fxFlex class="subtitle-2 text-hint">\n            Systen Environment Variables\n          </p>\n\n\n\n          <button (click)="addSystemProcess()" ghost nbButton status="danger">\n            Add\n          </button>\n\n\n        </div>\n\n\n        <ng-container formArrayName="system">\n\n          <ng-container *ngFor="let variable of this.form.get(\'config\').get(\'system\').controls ; let i=index ">\n\n            <div [style.marginBottom]="\'0.5rem\'" [formGroupName]="i" fxLayout="row" fxLayoutGap="1rem">\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="key" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n\n\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="value" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n              <button ghost nbButton (click)="deleteConfSystem(i)">\n                <nb-icon icon="trash-outline">\n                </nb-icon>\n              </button>\n\n\n\n\n            </div>\n\n\n          </ng-container>\n\n\n        </ng-container>\n\n        <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'config\').get(\'system\').controls .length"\n          fxFlex>\n          <p class="subtitle-2 text-hint">\n            No System Variables Defined\n          </p>\n        </div>\n      </div>\n\n      <app-divider></app-divider>\n\n    </nb-card-body>\n\n\n    <nb-card-footer (click)="save()">\n\n      <button class="buildBtn" fxLayoutAlign="space-between center" size="giant" status="success" filled fullWidth\n        nbButton>\n\n        <span>\n          Save\n\n        </span>\n        <nb-icon icon="play-circle"></nb-icon>\n\n      </button>\n    </nb-card-footer>\n\n  </nb-card>\n\n\n\n\n\n</ng-container>\n\n<ng-template #loading>\n  <div fxLayoutAlign="center center">\n    <ngx-progress-spinner></ngx-progress-spinner>\n  </div>\n\n</ng-template>\n',styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\nnb-card {\n  max-height: calc(100vh - 7rem);\n  margin: 0;\n}\nnb-card .container {\n  margin-top: 1rem;\n}\nnb-card textarea {\n  resize: none;\n}\n.label-text {\n  border-left: 2px var(--text-hint-color) solid !important;\n  margin-bottom: 1rem;\n  padding-left: 4px;\n}\n.subtitle {\n  margin: 0;\n  padding-left: 4px;\n}\nnb-card-header {\n  padding: 0.4rem;\n  box-shadow: 2px 2px 3px rgba(0, 0, 0, 0.16), 2px 2px 3px rgba(0, 0, 0, 0.23);\n}\nnb-card-footer {\n  padding: 0;\n}\nnb-card {\n  border: 0;\n}\n.buildBtn {\n  border-radius: 0;\n}"]})],I);var T=i("2Vo4"),_=i("5+tZ"),j=i("pLZG"),F=function(){function e(n,o){t(this,e),this.toolApiService=n,this.cdr=o,this.edit_mode=!1,this.build_id=void 0,this.meta_tags=new Set,this.bundke_upload_progress=new T.a({progress:20,uploading:!1}),this.buildTypes=[{name:"Docker File",id:"dockerfile",active:!0,children:[{name:"Dockerfile",id:"dockerfile",active:!0}]},{name:"Docker Image",id:"repository",active:!0,children:[{name:"Docker Hub",id:"registry_public",active:!0},{name:"Private Repository",id:"registry_private",active:!1}]},{name:"Docker Bundle",id:"repository",children:[{name:"Git Repository",id:"bundle_git",active:!0},{name:"Bundle Url",id:"bundle_url",active:!1},{name:"Upload Bundle",id:"bundle_upload",active:!0}]}],this.gitRepositories=[{name:"GitHub",id:"github"},{name:"GitLab",id:"gitlab"},{name:"Bitbucket",id:"bitbucket"},{name:"Other",id:"other"}],this.bundleType=[{name:"Zip",id:"zip"},{name:"Tar",id:"tar"}],this.config_form=new h.e({dockerfile:new h.e({authentication:new h.d("none",[]),data:new h.e({dockerfile:new h.d("Dockerfile",[h.n.required])}),auth_mode:new h.e({none:new h.e({}),credentials:new h.e({username:new h.d("",[h.n.required]),password:new h.d("",[h.n.required])}),token:new h.e({auth_token:new h.d("",[h.n.required])})})}),registry_public:new h.e({authentication:new h.d("credentials",[]),data:new h.e({image_name:new h.d("",[h.n.required]),image_tag:new h.d("",[h.n.required])}),auth_mode:new h.e({none:new h.e({}),credentials:new h.e({username:new h.d("",[h.n.required]),password:new h.d("",[h.n.required])}),token:new h.e({auth_token:new h.d("",[h.n.required])})})}),registry_private:new h.e({authentication:new h.d("credentials",[]),data:new h.e({image_name:new h.d("",[h.n.required]),image_tag:new h.d("",[h.n.required]),registry_url:new h.d("")}),auth_mode:new h.e({none:new h.e({}),credentials:new h.e({username:new h.d("",[h.n.required]),password:new h.d("",[h.n.required])}),token:new h.e({auth_token:new h.d("",[h.n.required])})})}),bundle_git:new h.e({authentication:new h.d("credentials",[]),data:new h.e({repository:new h.d("github",[h.n.required]),repository_url:new h.d("",[h.n.required,h.n.pattern("(git)?(://)(.*)(.git)(/)?")]),repository_context:new h.d("",[])}),auth_mode:new h.e({none:new h.e({}),credentials:new h.e({username:new h.d("",[h.n.required]),password:new h.d("",[h.n.required])}),token:new h.e({auth_token:new h.d("",[h.n.required])}),ssh:new h.e({ssh_key:new h.d("",[h.n.required])})})}),bundle_url:new h.e({authentication:new h.d("none",[]),data:new h.e({type:new h.d("tar"),url:new h.d("",[h.n.required])}),auth_mode:new h.e({none:new h.e({})})}),bundle_upload:new h.e({authentication:new h.d("none",[]),meta:new h.e({progress:new h.d(54)}),data:new h.e({type:new h.d("zip"),url:new h.d("",[h.n.required]),bucket:new h.d("",[h.n.required]),filename:new h.d("",[h.n.required]),identifier:new h.d("",[h.n.required]),version:new h.d("",[h.n.required])}),auth_mode:new h.e({none:new h.e({})})})}),this.form=new h.e({tool:new h.e({name:new h.d({value:"tool_name",disabled:!0},[h.n.required]),alias:new h.d({value:"tool_name",disabled:!0},[h.n.required])}),tool_name:new h.d({value:"tool_name",disabled:!0},[h.n.required]),tool_tag:new h.d({value:"tool_tag",disabled:!0},[h.n.required]),build_type:new h.d("bundle_git"),desc:new h.d("")})}return s(e,[{key:"onTagRemove",value:function(e){this.meta_tags.delete(e.text)}},{key:"onTagAdd",value:function(e){var n=e.value,t=e.input;n&&this.meta_tags.add(n),t.nativeElement.value=""}},{key:"ngOnInit",value:function(){this.init()}},{key:"init",value:function(){var e=this;this.edit_mode&&this.toolApiService.getBuild(this.refrence_id,this.build_id).subscribe(function(n){var t=n.build,o=(n.meta||{tags:[]}).tags||[];e.meta_tags=new Set(o);var s=t.type,i=n.auth,r=n.tool,a=i.mode;i=i.auth;var l=t.config;console.log("build",t),console.log("build_type",s),console.log("auth",i),console.log("auth_mode",a),console.log("config",l);var c=e.config_form.get(s);if(c){var d=c.get("data"),h=c.get("auth_mode"),u=c.get("authentication");u&&u.setValue(a),h&&(h=h.get(a),Object.keys(i).forEach(function(e){console.log("config key",e,h.get(e)),h.get(e).setValue(i[e])}),console.log("authentication_form",h)),d&&Object.keys(l).forEach(function(e){console.log("config key",e,d.get(e)),d.get(e).setValue(l[e])})}s&&e.form.get("build_type").setValue(s),r&&(r.name&&e.form.get("tool").get("name").setValue(r.name),r.alias&&e.form.get("tool").get("alias").setValue(r.alias))})}},{key:"download",value:function(e){console.log("download",e),this.toolApiService.getBuildDownloadUrl(e).pipe(Object(y.a)(function(e){return e.url}),Object(v.a)(function(e){var n=document.createElement("a");n.href=e,n.target="_blank",n.click()})).subscribe()}},{key:"upload",value:function(e,n){var t=this,o={};this.toolApiService.getBuildUploadUrl("test_id",e.name).pipe(Object(y.a)(function(e){return o=e,e.url})).pipe(Object(y.a)(function(n){return t.toolApiService.uploadWithUrl(e,n)}),Object(_.b)(function(e){return e}),Object(v.a)(function(e){t.bundke_upload_progress.next({uploading:!0,progress:e.progress})}),Object(j.a)(function(e){return e.status})).subscribe(function(e){t.bundke_upload_progress.next({uploading:!1,progress:0});var s=n.controls;Object.keys(o).forEach(function(e){s[e].setValue(o[e])}),console.log("controls",s),t.cdr.markForCheck()})}},{key:"saveChanges",value:function(){this.edit_mode?this.editBuild():this.createBuild()}},{key:"createBuild",value:function(){var e=this.form.get("build_type").value,n=this.config_form.get(e),t=n.get("authentication").value,o={auth:{auth:n.get("auth_mode").get(t).value,mode:t},build:{config:n.get("data").value,type:e},meta:{tags:Array.from(this.meta_tags.values())},refrence_id:this.refrence_id};this.toolApiService.createBuild(e,o).subscribe(function(e){console.log(e)}),console.log("config",o)}},{key:"editBuild",value:function(){var e=this.form.get("build_type").value,n=this.config_form.get(e),t=n.get("authentication").value,o={auth:{auth:n.get("auth_mode").get(t).value,mode:t},build:{config:n.get("data").value,type:e},meta:{tags:Array.from(this.meta_tags.values())},refrence_id:this.refrence_id};this.toolApiService.editBuild(this.build_id,e,o).subscribe(function(e){}),console.log("config",o)}}]),e}();F.ctorParameters=function(){return[{type:C},{type:l.k}]},F.propDecorators={edit_mode:[{type:l.I,args:["edit_mode"]}],build_id:[{type:l.I,args:["build_id"]}],close:[{type:l.I,args:["close"]}],refrence_id:[{type:l.I,args:["refrence_id"]}]},F=Object(a.a)([Object(l.n)({selector:"app-build-create",template:'\x3c!-- File:  Dockerfile --\x3e\n<ng-template #dockerfile [formGroup]="config_form">\n\n  <ng-container formGroupName="dockerfile">\n\n    <div formGroupName="data" fxLayout="column">\n\n      <div>\n        <p class="subtitle-2 text-hint">\n          Dockerfile\n        </p>\n      </div>\n\n      <div fxLayout="row" fxLayoutGap="1rem">\n\n        <nb-form-field fxFlex>\n          <textarea formControlName="dockerfile" fullWidth nbInput placeholder=" Dockerfile">\n\n          </textarea>\n\n        </nb-form-field>\n\n\n      </div>\n\n\n\n    </div>\n\n    <app-divider></app-divider>\n\n\n  </ng-container>\n\n</ng-template>\n\n\x3c!-- Image:  Docker Hub --\x3e\n<ng-template #registry_public [formGroup]="config_form">\n\n  <ng-container formGroupName="registry_public">\n\n    <div formGroupName="data" fxLayout="column">\n\n      <div>\n        <p class="subtitle-2 text-hint">\n          Docker Image\n        </p>\n      </div>\n\n      <div fxLayout="row" fxLayoutGap="1rem">\n\n        <nb-form-field>\n          <input formControlName="image_name" fullWidth nbInput placeholder="Image Name">\n\n        </nb-form-field>\n\n        <nb-form-field>\n          <input formControlName="image_tag" fullWidth nbInput placeholder="Tag Name">\n        </nb-form-field>\n      </div>\n\n\n\n    </div>\n\n    <app-divider></app-divider>\n\n    <div fxLayout="column">\n\n      <div>\n        <p class="subtitle-2 text-hint">\n          Credentials\n        </p>\n      </div>\n      <div>\n\n        <nb-select size="medium" status="primary" formControlName="authentication" filled placeholder="Authentication">\n\n          <nb-option value="none">\n            No Auth\n          </nb-option>\n          <nb-option value="credentials">\n            Credentials\n          </nb-option>\n\n\n        </nb-select>\n      </div>\n\n    </div>\n\n    <app-divider></app-divider>\n\n    <ng-container formGroupName="auth_mode">\n\n      <ng-container formGroupName="credentials"\n        *ngIf="config_form.value.registry_public.authentication == \'credentials\' ">\n\n        \x3c!-- <div class="subtitle text-hint container label-text">\n          Username\n        </div> --\x3e\n\n        <div fxLayout="row" class="container">\n          <nb-form-field>\n            <nb-icon icon="at-outline" nbPrefix></nb-icon>\n            <input formControlName="username" fullWidth nbInput placeholder="Username">\n          </nb-form-field>\n        </div>\n\n        <div fxLayout="row" class="container">\n\n          <nb-form-field>\n            <nb-icon icon="hash-outline" nbPrefix></nb-icon>\n\n            <input formControlName="password" fullWidth nbInput placeholder="Password">\n          </nb-form-field>\n        </div>\n\n      </ng-container>\n\n      <ng-container formGroupName="token" *ngIf="config_form.value.registry_public.authentication == \'token\' ">\n\n        <div fxLayout="row" class="container">\n          <nb-form-field fxFlex>\n            <textarea formControlName="auth_token" fullWidth nbInput placeholder="Auth token"></textarea>\n          </nb-form-field>\n\n        </div>\n\n      </ng-container>\n\n    </ng-container>\n\n  </ng-container>\n\n</ng-template>\n\n\n\x3c!-- Image: Private Repository --\x3e\n<ng-template #registry_private [formGroup]="config_form">\n\n  <ng-container formGroupName="registry_private">\n\n    <div formGroupName="data" fxLayout="column">\n\n\n\n      <div>\n        <p class="subtitle-2 text-hint">\n          Private Docker Registry\n        </p>\n      </div>\n\n      <div fxLayout="row" fxLayoutGap="1rem">\n\n        <nb-form-field>\n          <input formControlName="registry_url" fullWidth nbInput placeholder="Registry Url">\n\n        </nb-form-field>\n\n\n      </div>\n      <div fxLayout="row" fxLayoutGap="1rem">\n\n        <nb-form-field>\n          <input formControlName="image_name" fullWidth nbInput placeholder="Image Name">\n\n        </nb-form-field>\n\n        <nb-form-field>\n          <input formControlName="image_tag" fullWidth nbInput placeholder="Tag Name">\n        </nb-form-field>\n      </div>\n\n\n\n    </div>\n\n    <app-divider></app-divider>\n\n    <div fxLayout="column">\n\n      <div>\n        <p class="subtitle-2 text-hint">\n          Credentials\n        </p>\n      </div>\n      <div>\n\n        <nb-select size="medium" status="primary" formControlName="authentication" filled placeholder="Authentication">\n\n          <nb-option value="none">\n            No Auth\n          </nb-option>\n          <nb-option value="credentials">\n            Credentials\n          </nb-option>\n\n\n        </nb-select>\n      </div>\n\n    </div>\n\n    <app-divider></app-divider>\n\n    <ng-container formGroupName="auth_mode">\n\n      <ng-container formGroupName="credentials"\n        *ngIf="config_form.value.registry_private.authentication == \'credentials\' ">\n\n        \x3c!-- <div class="subtitle text-hint container label-text">\n          Username\n        </div> --\x3e\n\n        <div fxLayout="row" class="container">\n          <nb-form-field>\n            <nb-icon icon="at-outline" nbPrefix></nb-icon>\n            <input formControlName="username" fullWidth nbInput placeholder="Username">\n          </nb-form-field>\n        </div>\n\n        <div fxLayout="row" class="container">\n\n          <nb-form-field>\n            <nb-icon icon="hash-outline" nbPrefix></nb-icon>\n\n            <input formControlName="password" fullWidth nbInput placeholder="Password">\n          </nb-form-field>\n        </div>\n\n      </ng-container>\n\n      <ng-container formGroupName="token" *ngIf="config_form.value.registry_private.authentication == \'token\' ">\n\n        <div fxLayout="row" class="container">\n          <nb-form-field fxFlex>\n            <textarea formControlName="auth_token" fullWidth nbInput placeholder="Auth token"></textarea>\n          </nb-form-field>\n\n        </div>\n\n      </ng-container>\n\n    </ng-container>\n\n  </ng-container>\n\n</ng-template>\n\n\n\x3c!-- Bundle: Git Repository --\x3e\n<ng-template #bundle_git [formGroup]="config_form">\n\n\n  <ng-container formGroupName="bundle_git">\n\n    <div fxFlex fxLayoutGap="1rem" fxLayout="column">\n\n\n      <ng-container formGroupName="data">\n\n        <div fxLayoutAlign="start center" fxLayout="row" fxLayoutGap="1rem">\n\n\n          <div fxFlex>\n            <p class="subtitle-2 text-hint">\n              Repository\n            </p>\n          </div>\n\n          <nb-select size="small" status="primary" formControlName="repository" outline placeholder="Repository">\n\n            <nb-option *ngFor="let repo of gitRepositories" [value]="repo.id">\n              {{repo?.name}}\n            </nb-option>\n\n\n          </nb-select>\n        </div>\n\n        <div fxLayout="row">\n\n          <nb-form-field fxFlex>\n            <span nbPrefix>\n              Url\n            </span>\n\n            <input formControlName="repository_url" fullWidth nbInput placeholder="Repository URL">\n\n          </nb-form-field>\n\n\n        </div>\n\n\n        <div fxLayout="row">\n\n          <nb-form-field fxFlex>\n            <span nbPrefix>\n              file://\n            </span>\n\n            <input fieldSize="small" formControlName="repository_context" fullWidth nbInput\n              placeholder="Repository Context">\n\n          </nb-form-field>\n\n\n        </div>\n\n      </ng-container>\n\n      <div fxLayoutAlign="end center" fxLayout="row">\n\n        <nb-select size="tiny" status="danger" filled formControlName="authentication" placeholder="Authentication">\n\n          <nb-option value="none">\n            No Auth\n          </nb-option>\n          <nb-option value="credentials">\n            Credentials\n          </nb-option>\n          <nb-option value="token">\n            Auth Token\n          </nb-option>\n          <nb-option value="ssh">\n            SSH Key\n          </nb-option>\n        </nb-select>\n      </div>\n\n      <div fxLayout="row" fxLayoutGap="1rem">\n\n        <ng-container formGroupName="auth_mode">\n\n          <ng-container formGroupName="credentials"\n            *ngIf="config_form.value.bundle_git.authentication == \'credentials\' ">\n\n            \x3c!-- <div class="subtitle text-hint container label-text">\n          Username\n        </div> --\x3e\n\n\n\n            <div fxFlex>\n\n              <nb-form-field>\n                <nb-icon icon="at-outline" nbPrefix></nb-icon>\n                <input fieldSize="small" formControlName="username" nbInput placeholder="Username">\n              </nb-form-field>\n            </div>\n\n            <div fxFlex>\n\n              <nb-form-field>\n                <nb-icon icon="hash-outline" nbPrefix></nb-icon>\n\n                <input fieldSize="small" formControlName="password" nbInput placeholder="Password">\n              </nb-form-field>\n\n            </div>\n\n\n          </ng-container>\n\n          <ng-container formGroupName="token" *ngIf="config_form.value.bundle_git.authentication == \'token\' ">\n\n            <div fxFlex>\n              <nb-form-field fxFlex>\n                <textarea fieldSize="small" formControlName="auth_token" fullWidth nbInput\n                  placeholder="Auth token"></textarea>\n              </nb-form-field>\n\n            </div>\n\n          </ng-container>\n\n          <ng-container formGroupName="ssh" *ngIf="config_form.value.bundle_git.authentication == \'ssh\' ">\n\n            <div fxFlex>\n              <nb-form-field fxFlex>\n                <textarea fieldSize="small" formControlName="ssh_key" fullWidth nbInput\n                  placeholder="SSH Key"></textarea>\n              </nb-form-field>\n\n            </div>\n\n          </ng-container>\n\n        </ng-container>\n      </div>\n\n    </div>\n\n\n\n\n  </ng-container>\n\n\n</ng-template>\n\n\n\x3c!-- Bundle: Url  --\x3e\n<ng-template #bundle_url [formGroup]="config_form">\n  <ng-container formGroupName="bundle_url">\n\n\n\n\n    <div fxFlex formGroupName="data" fxLayout="column" fxLayoutGap="1rem">\n\n\n      <div fxLayout="row">\n\n\n        <nb-select size="small" status="primary" formControlName="type" filled placeholder="Repository">\n\n          <nb-option *ngFor="let bundle of bundleType" [value]="bundle.id">\n            {{bundle?.name}}\n          </nb-option>\n\n\n        </nb-select>\n\n      </div>\n\n      <div fxLayout="row">\n\n\n        <nb-form-field fxFlex>\n\n          <span nbPrefix>Url</span>\n\n          <input fieldSize="small" formControlName="url" fullWidth nbInput\n            placeholder="git://github.com/meddler-io/first-tool.git">\n\n        </nb-form-field>\n\n\n      </div>\n\n\n    </div>\n\n\n\n\n  </ng-container>\n\n\n</ng-template>\n\n\x3c!-- Bundle: Upload  --\x3e\n<ng-template #bundle_upload [formGroup]="config_form">\n\n  <ng-container formGroupName="bundle_upload">\n\n\n    <ng-container formGroupName="data">\n\n\n      <div fxLayout="column" fxLayoutGap="1rem">\n\n        <div fxLayout="row">\n\n          <nb-select size="small" status="primary" formControlName="type" filled placeholder="Repository">\n\n            <nb-option *ngFor="let bundle of bundleType" [value]="bundle.id">\n              {{bundle?.name}}\n            </nb-option>\n\n\n          </nb-select>\n\n\n        </div>\n\n\n\n\n        <div fxLayout="row" fxLayoutGap="1rem">\n          <input type="file" #file style="display: none"\n            (change)="upload( $event.target.files[0] ,  config_form.get(  \'bundle_upload\').get(\'data\') )">\n\n\n          <button *ngIf=" config_form.get(\'bundle_upload\').get(\'data\').invalid " (click)="file.click()" nbButton\n            size="small">\n            Upload\n\n          </button>\n\n          <button status="primary" [disabled]=" config_form.get(\'bundle_upload\').get(\'data\').invalid "\n            (click)="download( config_form.get(\'bundle_upload\').get(\'data\').value )" nbButton size="small">\n            Download\n\n          </button>\n\n\n          <button (click)=" config_form.get(\'bundle_upload\').get(\'data\').get(\'url\').setValue(\'\') " nbButton\n            size="small">\n            Reset\n\n          </button>\n\n        </div>\n\n        <div fxLayout="row">\n\n          <ng-container *ngIf="bundke_upload_progress | async as bundke_upload_progress">\n\n            <div fxFlex fxLayout="row">\n\n              <nb-progress-bar *ngIf="bundke_upload_progress?.uploading" size="tiny" fxFlex\n                [value]="bundke_upload_progress?.progress" status="success" [displayValue]="true">\n              </nb-progress-bar>\n            </div>\n          </ng-container>\n        </div>\n\n      </div>\n\n\n    </ng-container>\n\n\n  </ng-container>\n\n\n</ng-template>\n\n\n\n<ng-container [formGroup]="form">\n\n\n\n  <nb-card fxFill>\n\n    <nb-card-header fxLayoutAlign="space-between center">\n\n      <div fxLayoutAlign="start center" fxLayout="row">\n\n        <button (click)="close.next(true)" shape="round" ghost status="basic" class="action" size="large" nbButton>\n          <nb-icon icon="arrow-back-outline">\n\n          </nb-icon>\n        </button>\n\n        <span class="subtitle text-hint lineV">\n          Build Creator\n        </span>\n\n      </div>\n\n      <button (click)="close.next(true)" shape="round" ghost status="basic" class="action" size="large" nbButton>\n        <nb-icon icon="info">\n\n        </nb-icon>\n      </button>\n\n\n    </nb-card-header>\n\n\n    <nb-card-body>\n\n\n      <div fxLayoutAlign="space-between center" fxLayout="row" fxLayoutGap="1rem">\n        <p class="subtitle text-basic">\n          Build Info\n        </p>\n\n        <button shape="round" ghost nbButton>\n          <nb-icon icon="info"></nb-icon>\n        </button>\n      </div>\n      <app-divider></app-divider>\n\n\n      <div fxLayoutGap="1rem" fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Name\n          </p>\n        </div>\n\n        <div formGroupName="tool" fxLayout="row" fxLayoutGap="1rem">\n\n          <nb-form-field>\n\n            <input cdkFocusInitial formControlName="name" nbInput placeholder="Tool Name">\n\n          </nb-form-field>\n          <nb-form-field fieldSize="small">\n            <input formControlName="alias" nbInput placeholder="Tool tag">\n          </nb-form-field>\n        </div>\n      </div>\n\n      <app-divider></app-divider>\n\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Description\n          </p>\n        </div>\n\n        <div fxLayout="row">\n\n          <nb-form-field fxFlex>\n            <textarea formControlName="desc" fullWidth nbInput placeholder="Description"></textarea>\n          </nb-form-field>\n\n        </div>\n\n\n        <app-divider></app-divider>\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Tags\n          </p>\n        </div>\n        <div fxLayout="row">\n\n          <nb-tag-list fxFlex (tagRemove)="onTagRemove($event)">\n            <nb-tag   size="small" *ngFor="let tag of meta_tags" [text]="tag" removable></nb-tag>\n            <input type="text" nbTagInput (tagAdd)="onTagAdd($event)" fullWidth>\n            \n          </nb-tag-list>\n\n        </div>\n\n      <app-divider></app-divider>\n\n      </div>\n\n      <app-divider></app-divider>\n\n\n\n\n      <div fxLayoutAlign="space-between center" fxLayout="row" fxLayoutGap="1rem">\n        <p fxFlex class="subtitle text-basic">\n          Tools Source\n        </p>\n\n\n        <nb-select size="small" #buildTypeSelect hero [status]="  form?.value?.build_type ? \'primary\' : \'danger\' "\n          formControlName="build_type" placeholder="Select Build Type">\n          <nb-option-group *ngFor="let group of buildTypes" [title]="group.name">\n            <nb-option [disabled]="!option?.active" *ngFor="let option of group.children " [value]="option.id">\n              {{option?.name}}\n            </nb-option>\n          </nb-option-group>\n        </nb-select>\n\n\n\n      </div>\n\n      <app-divider></app-divider>\n\n\n\n\n\n      \x3c!-- <div class="subtitle text-hint container label-text">\n        Information\n      </div> --\x3e\n\n\n      <div fxLayoutAlign="space-between center" fxLayout="row" fxLayoutGap="1rem">\n\n        <ng-container [ngSwitch]="form.value.build_type">\n\n          <ng-container *ngSwitchCase="\'dockerfile\'">\n            <ng-template *ngTemplateOutlet="dockerfile"> </ng-template>\n          </ng-container>\n\n          <ng-container *ngSwitchCase="\'registry_public\'">\n            <ng-template *ngTemplateOutlet="registry_public"> </ng-template>\n          </ng-container>\n\n          <ng-container *ngSwitchCase="\'registry_private\'">\n            <ng-template *ngTemplateOutlet="registry_private"> </ng-template>\n          </ng-container>\n\n\n          <ng-container *ngSwitchCase="\'bundle_git\'">\n            <ng-template *ngTemplateOutlet="bundle_git"> </ng-template>\n          </ng-container>\n\n\n          <ng-container *ngSwitchCase="\'bundle_url\'">\n            <ng-template *ngTemplateOutlet="bundle_url"> </ng-template>\n          </ng-container>\n\n\n          <ng-container *ngSwitchCase="\'bundle_upload\'">\n            <ng-template *ngTemplateOutlet="bundle_upload"> </ng-template>\n          </ng-container>\n\n\n\n\n        </ng-container>\n\n\n      </div>\n\n    </nb-card-body>\n\n\n\n\n\n    <nb-card-footer (click)="saveChanges()">\n\n      <button [disabled]="\n\n      config_form?.get( form.get(\'build_type\').value )?.get(\'data\')?.invalid \n      ||\n      config_form?.get( form.get(\'build_type\').value )?.get(\'auth_mode\')?.get(  config_form?.get( form.get(\'build_type\').value )?.get(\'authentication\')?.value ).invalid\n\n      \n      " class="buildBtn" fxLayoutAlign="space-between center" size="giant" status="success" filled fullWidth nbButton>\n\n        <span>\n\n\n\n          Build\n        </span>\n        <nb-icon icon="play-circle"></nb-icon>\n\n      </button>\n    </nb-card-footer>\n\n  </nb-card>\n\n</ng-container>\n',changeDetection:l.j.OnPush,styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\nnb-card {\n  max-height: calc(100vh - 7rem);\n  margin: 0;\n}\nnb-card .container {\n  margin-top: 1rem;\n}\nnb-card textarea {\n  resize: none;\n}\n.label-text {\n  border-left: 2px var(--text-hint-color) solid !important;\n  margin-bottom: 1rem;\n  padding-left: 4px;\n}\n.subtitle {\n  margin: 0;\n  padding-left: 4px;\n}\nnb-card-header {\n  padding: 0.4rem;\n  box-shadow: 2px 2px 3px rgba(0, 0, 0, 0.16), 2px 2px 3px rgba(0, 0, 0, 0.23);\n}\nnb-card-footer {\n  padding: 0;\n}\nnb-card {\n  border: 0;\n}\n.buildBtn {\n  border-radius: 0;\n}"]})],F);var P=i("SDw7"),M=i("KPRU"),z=i("ZfaG"),B=function(){function e(){t(this,e),this.toolId=new T.a("dfault")}return s(e,[{key:"ToolId",get:function(){return this.toolId.asObservable()}},{key:"SetToolId",value:function(e){console.log("SetToolId"),this.toolId.next(e)}}]),e}();B.ctorParameters=function(){return[]},B=Object(a.a)([Object(l.F)({providedIn:"root"})],B);var O=i("quSY"),D=function(){function e(n,o,s,i,r){t(this,e),this.toolApiService=n,this.drawerMngr=o,this.document=s,this.sharedDataService=i,this.activatedRoute=r,this.refrence_id="refrence_id",this.sharedServiceSubscription$=O.a.EMPTY,this.tabs=[]}return s(e,[{key:"ngOnDestroy",value:function(){this.sharedServiceSubscription$.unsubscribe()}},{key:"ngOnInit",value:function(){var e=this;this.sharedServiceSubscription$=this.sharedDataService.ToolId.pipe(Object(v.a)(function(n){e.refrence_id=n})).subscribe(function(){e.loadData()})}},{key:"loadData",value:function(){var e=this;this.builds$=this.toolApiService.getBuilds(this.refrence_id).pipe(Object(v.a)(function(n){n.length<1&&e.openDrawer(e.buildCreateTemplate)}))}},{key:"openDrawer",value:function(e,n){var t=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:P.a.Left,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"50",i=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],r=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],a=arguments.length>6?arguments[6]:void 0;n||(n={}),console.log("context",n),this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:o,template:e,size:s,context:n,closeOnOutsideClick:i,parentContainer:a,isRoot:r,zIndex:1e3,cssClass:"backdrop_color"}).onDestroy(function(){t.document.body.classList.remove("cdk-global-scrollblock")})}},{key:"openLogs",value:function(e,n){var t=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:P.a.Left,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"50%",i=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],r=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],a=arguments.length>6?arguments[6]:void 0;this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:o,template:e,size:s,closeOnOutsideClick:i,parentContainer:a,isRoot:r,zIndex:1e3,cssClass:"backdrop_color",context:{id:n}}).onDestroy(function(){t.document.body.classList.remove("cdk-global-scrollblock")})}},{key:"runTask",value:function(e){var n=this,t={TraceId:e,fprocess:"echo hello world"};this.toolApiService.runTool(e,t).subscribe(function(t){console.log(t),n.openLogs(n.logTemplate,e)})}}]),e}();D.ctorParameters=function(){return[{type:C},{type:M.a},{type:Document,decorators:[{type:l.D,args:[c.d]}]},{type:B},{type:d.a}]},D.propDecorators={buildCreateTemplate:[{type:l.qb,args:["buildCreateTemplate",{static:!1}]}],logTemplate:[{type:l.qb,args:["logsTemplate",{static:!1}]}]},D=Object(a.a)([Object(l.n)({selector:"app-build-list",template:'<ng-container *ngIf=" builds$ | async as builds ; else loading">\n\n\n  \x3c!-- <nb-layout-header *ngIf="false" @init subHeader>\n\n\n\n    <div fxFlex fxLayout="row" fxLayoutAlign="space-between center">\n\n      <div fxLayout="row" fxLayoutAlign="start center">\n\n        <button shape="round" [routerLink]="[\'/tools\' ]" ghost status="basic" class="action" size="large" nbButton>\n          <nb-icon icon="arrow-back-outline">\n\n          </nb-icon>\n        </button>\n\n        <div class="h6 text-hint">\n\n          Builds\n\n        </div>\n      </div>\n\n\n\n      <div [style.marginRight]=" \'0.5rem\' " fxFlex fxLayout="row" fxLayoutAlign="end center">\n\n        <button (click)="openDrawer(buildCreateTemplate)" class="newBtn" shape="round" nbButton>\n\n          <div class="icon"></div>\n\n          <span>\n            Create Build\n\n          </span>\n        </button>\n\n\n      </div>\n\n    </div>\n\n  </nb-layout-header> --\x3e\n\n\n\n  <nb-accordion @init>\n    <nb-accordion-item [expanded]="index == 0" *ngFor="let build of builds  ; index as index">\n      <nb-accordion-item-header fxLayoutAlign="space-between">\n\n        <span>\n          {{ build?.name || \'Build Name\' }}\n\n        </span>\n\n        <span class="text-hint">\n          {{ \'@\' +  ( build?.tool?.alias || \'Alias\' ) }}\n        </span>\n      </nb-accordion-item-header>\n      <nb-accordion-item-body>\n\n        <nb-card>\n          <nb-card-body>\n            <div class="text-hint">\n              {{ build?.description || \'Build Description\' }}\n\n            </div>\n\n            <div class="text-hint">\n              {{ build?.doc || date }}\n\n            </div>\n\n          </nb-card-body>\n          <nb-card-footer fxLayoutGap="1rem" fxLayoutAlign="end center">\n\n            <button (click)="openDrawer(buildconfigTemplate , context =  { \'build_id\':  build?._id } )" status="basic"\n              ghost size="small" nbButton>\n\n              <nb-icon icon="file-text-outline"></nb-icon>\n              Config\n            </button>\n\n            <button (click)="openLogs(logsTemplate, build?._id)" status="basic" ghost size="small" nbButton>\n\n              <nb-icon icon="file-text-outline"></nb-icon>\n              Logs\n            </button>\n\n            <button (click)="openDrawer(logsTemplate)" status="basic" ghost size="small" nbButton>\n\n              <nb-icon icon="settings-2-outline"></nb-icon>\n              Monitor\n            </button>\n\n\n            <button status="basic" ghost size="small" nbButton>\n\n              <nb-icon icon="diagonal-arrow-left-down-outline"></nb-icon>\n              Fork\n            </button>\n\n\n\n          </nb-card-footer>\n\n          <nb-card-footer fxLayoutGap="1rem" fxLayoutAlign="end center">\n\n\n            <nb-select [style.marginRight]="\'1rem\'" [selected]="0" *ngIf="build?.executors?.length > 0"\n              placeholder="Success" size="small" status="danger" filled>\n              <nb-option status="success" *ngFor="let topic of build?.executors ; index as index" [value]="index">\n                {{topic?._id}}\n\n              </nb-option>\n\n            </nb-select>\n\n            <button\n              (click)="openDrawer(buildEditTemplate  , context =  { \'build_id\':  build?._id , \'edit_mode\': true } )"\n              status="basic" size="small" nbButton>Edit</button>\n\n            <button (click)="runTask( build?._id ) " status="primary" size="small" nbButton>Build</button>\n\n            <button (click)="runTask( build?._id ) " status="danger" size="small" nbButton>Run</button>\n          </nb-card-footer>\n        </nb-card>\n\n\n      </nb-accordion-item-body>\n    </nb-accordion-item>\n\n  </nb-accordion>\n\n\n</ng-container>\n\n\n<ng-template #loading>\n  <div fxLayoutAlign="center center">\n    <ngx-progress-spinner></ngx-progress-spinner>\n  </div>\n\n</ng-template>\n\n<ng-template #logsTemplate let-close="close" let-context="context">\n\n  <app-log-stream [close]="close" [log_id]="context?.id"></app-log-stream>\n\n\n</ng-template>\n\n<ng-template let-close="close" let-context="context" #buildEditTemplate>\n\n  <app-build-create [edit_mode]="context.edit_mode" [close]="close" [build_id]="context.build_id"\n    [refrence_id]="refrence_id"></app-build-create>\n\n</ng-template>\n\n<ng-template let-close="close" #buildCreateTemplate>\n\n  <app-build-create [close]="close" [refrence_id]="refrence_id"></app-build-create>\n\n</ng-template>\n\n\n\n\n<ng-template let-close="close" let-context="context" #buildconfigTemplate>\n\n  <app-build-config [close]="close" [build_id]="context?.build_id"></app-build-config>\n\n</ng-template>\n',changeDetection:l.j.OnPush,animations:e(z.a),styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\n:host ::ng-deep nb-route-tabset {\n  overflow-x: auto;\n  overflow-y: hidden;\n  padding-bottom: 0.2rem !important;\n  /* IE and Edge */\n  /* Firefox */\n}\n:host ::ng-deep nb-route-tabset ::-webkit-scrollbar {\n  display: none;\n}\n:host ::ng-deep nb-route-tabset .tab {\n  margin-right: 0.5rem;\n}\nnb-accordion {\n  margin: 0 !important;\n}\nnb-accordion-item {\n  margin-top: 0.4rem;\n}\nnb-accordion-item nb-accordion-item-header:hover {\n  background: var(--color-basic-700);\n  color: #fff;\n}\nnb-card {\n  margin-bottom: 0;\n  border: 0;\n}\nnb-accordion {\n  margin: 1rem;\n}\n.h6 {\n  margin-left: 1rem;\n}\nnb-accordion-item-header.accordion-item-header-expanded {\n  border-left: 2px var(--text-basic-color) solid !important;\n}\nbutton.newBtn {\n  padding: 0.3rem !important;\n  padding-left: 1rem !important;\n  padding-right: 1rem !important;\n  text-transform: capitalize !important;\n  box-shadow: 0 1px 2px 0 rgba(60, 64, 67, 0.302), 0 1px 3px 1px rgba(60, 64, 67, 0.149) !important;\n  align-items: center !important;\n  background-color: #fff !important;\n  border: 1px solid transparent;\n  border-radius: 24px;\n  color: #3c4043 !important;\n}\nbutton.newBtn span {\n  margin-right: 1rem;\n  margin-top: 0.5rem;\n  margin-bottom: 0.5rem;\n  font-weight: 600;\n}\nbutton.newBtn .icon {\n  margin-right: 1rem;\n  background-image: url(\"data:image/svg+xml;charset=UTF-8,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2236%22 height=%2236%22 viewBox=%220 0 36 36%22%3E%3Cpath fill=%22%2334A853%22 d=%22M16 16v14h4V20z%22/%3E%3Cpath fill=%22%234285F4%22 d=%22M30 16H20l-4 4h14z%22/%3E%3Cpath fill=%22%23FBBC05%22 d=%22M6 16v4h10l4-4z%22/%3E%3Cpath fill=%22%23EA4335%22 d=%22M20 16V6h-4v14z%22/%3E%3Cpath fill=%22none%22 d=%22M0 0h36v36H0z%22/%3E%3C/svg%3E\");\n  width: 2rem !important;\n  height: 2rem !important;\n}\nbutton.newBtn:hover {\n  box-shadow: 0 3px 5px 0 rgba(60, 64, 67, 0.302), 0 3px 5px 1px rgba(60, 64, 67, 0.149) !important;\n  background-color: #fff !important;\n}\n.icon {\n  background-image: url(\"data:image/svg+xml;charset=UTF-8,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2236%22 height=%2236%22 viewBox=%220 0 36 36%22%3E%3Cpath fill=%22%2334A853%22 d=%22M16 16v14h4V20z%22/%3E%3Cpath fill=%22%234285F4%22 d=%22M30 16H20l-4 4h14z%22/%3E%3Cpath fill=%22%23FBBC05%22 d=%22M6 16v4h10l4-4z%22/%3E%3Cpath fill=%22%23EA4335%22 d=%22M20 16V6h-4v14z%22/%3E%3Cpath fill=%22none%22 d=%22M0 0h36v36H0z%22/%3E%3C/svg%3E\");\n}\n.head {\n  height: 4rem;\n  background: var(--background-alternative-color-2);\n  box-shadow: 2px 2px 3px rgba(255, 255, 255, 0.16), 2px 2px 3px rgba(255, 255, 255, 0.23);\n  color: #fff;\n}\n.content {\n  height: calc(100% - 4rem);\n  overflow: auto;\n}\n.action {\n  margin-left: 5px;\n}\n.action:hover nb-icon {\n  color: var(--color-alternate-500);\n}\nnb-tab {\n  padding: 0px;\n}\nnb-card {\n  max-height: calc(100vh - 7rem);\n  margin: 0;\n}\nnb-card .container {\n  margin-top: 1rem;\n}\nnb-card textarea {\n  resize: none;\n}\nnb-card nb-card-header {\n  padding: 0.4rem;\n}"]})],D);var W=function(){function e(n,o,s,i,r,a){t(this,e),this.toolApiService=n,this.cdr=o,this.drawerMngr=s,this.document=i,this.activatedRoute=r,this.sharedDataService=a,this.images=[],this.sharedServiceSubscription$=O.a.EMPTY}return s(e,[{key:"ngOnDestroy",value:function(){this.sharedServiceSubscription$.unsubscribe()}},{key:"ngOnInit",value:function(){var e=this;this.sharedServiceSubscription$=this.sharedDataService.ToolId.pipe(Object(v.a)(function(n){e.tool_id=n})).subscribe(function(){e.loadData()})}},{key:"loadData",value:function(){var e=this;this.toolApiService.getToolImageTags(this.tool_id).subscribe(function(n){e.images=n,e.cdr.markForCheck()})}},{key:"openDrawer",value:function(e,n){var t=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:P.a.Left,s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],i=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],r=arguments.length>6?arguments[6]:void 0;n||(n={}),console.log("context",n),this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:o,template:e,context:n,closeOnOutsideClick:s,parentContainer:r,isRoot:i,zIndex:1e3,cssClass:"backdrop_color"}).onDestroy(function(){t.document.body.classList.remove("cdk-global-scrollblock")})}},{key:"deploy",value:function(e){this.toolApiService.createDeployment(e).subscribe(function(e){console.log(e)})}}]),e}();W.ctorParameters=function(){return[{type:C},{type:l.k},{type:M.a},{type:Document,decorators:[{type:l.D,args:[c.d]}]},{type:d.a},{type:B}]},W.propDecorators={tool_id:[{type:l.I,args:["tool_id"]}]},W=Object(a.a)([Object(l.n)({selector:"app-built-image-list",template:'<nb-accordion>\n  <nb-accordion-item [expanded]="index == 0" *ngFor="let build of images  ; index as index">\n    <nb-accordion-item-header fxLayoutAlign="space-between">\n\n      <span>\n        {{ build?.name || \'Build Name\' }}\n\n      </span>\n\n      <span class="text-hint">\n        {{ \'@\' +  ( build?.tool?.alias || \'Alias\' ) }}\n      </span>\n    </nb-accordion-item-header>\n    <nb-accordion-item-body>\n\n      <nb-card>\n        <nb-card-body>\n          <div class="text-hint">\n            {{ build?.description || \'Build Description\' }}\n\n          </div>\n\n          <div class="text-hint">\n            {{ build?.doc || date }}\n\n          </div>\n\n        </nb-card-body>\n        <nb-card-footer fxLayoutGap="1rem" fxLayoutAlign="end center">\n\n          <button (click)="openDrawer(buildconfigTemplate , context =  { \'build_id\':  build?._id } )" status="basic"\n            ghost size="small" nbButton>\n\n            <nb-icon icon="file-text-outline"></nb-icon>\n            Config\n          </button>\n\n          <button (click)="openDrawer(logsTemplate, context = {\n            \'id\': build?._id\n\n          }  )" status="basic" ghost size="small" nbButton>\n\n            <nb-icon icon="file-text-outline"></nb-icon>\n            Logs\n          </button>\n\n\n\n\n\n\n        </nb-card-footer>\n\n        <nb-card-footer fxLayoutGap="1rem" fxLayoutAlign="end center">\n\n\n          <nb-select [style.marginRight]="\'1rem\'" [selected]="0" *ngIf="build?.executors?.length > 0"\n            placeholder="Success" size="small" status="danger" filled>\n            <nb-option status="success" *ngFor="let topic of build?.executors ; index as index" [value]="index">\n              {{topic?._id}}\n\n            </nb-option>\n\n          </nb-select>\n\n          <button (click)="openDrawer(buildEditTemplate  , context =  { \'build_id\':  build?._id , \'edit_mode\': true } )"\n            status="basic" size="small" nbButton>Edit</button>\n\n          <button (click)="runTask( build?._id ) " status="primary" size="small" nbButton>Build</button>\n\n          <button (click)="deploy( build?._id ) " status="danger" size="small" nbButton>Deploy</button>\n        </nb-card-footer>\n      </nb-card>\n\n\n    </nb-accordion-item-body>\n  </nb-accordion-item>\n\n</nb-accordion>\n\n<ng-template #logsTemplate let-close="close" let-context="context">\n\n  <app-log-stream [close]="close" [deep_link]="true" [log_id]="context?.id"></app-log-stream>\n\n\n</ng-template>\n\n\n\n<ng-container #loading *ngIf="!images || images.length == 0">\n  <div fxLayoutAlign="center center">\n    <ngx-progress-spinner></ngx-progress-spinner>\n  </div>\n\n</ng-container>\n',styles:[""]})],W);var E=function(){function e(n,o,s,i,r,a){t(this,e),this.toolApiService=n,this.drawerMngr=o,this.document=s,this.activatedRoute=i,this.cdr=r,this.sharedDataService=a,this.sharedServiceSubscription$=O.a.EMPTY}return s(e,[{key:"ngOnDestroy",value:function(){this.sharedServiceSubscription$.unsubscribe()}},{key:"ngOnInit",value:function(){var e=this;this.sharedServiceSubscription$=this.sharedDataService.ToolId.pipe(Object(v.a)(function(n){e.tool_id=n})).subscribe(function(){e.loadData()})}},{key:"loadData",value:function(){var e=this;console.log("ngOnInit"),this.toolApiService.getDeployments(this.tool_id).pipe(Object(y.a)(function(n){var t=[];return n.forEach(function(n,o){var s=n,i={id:s,details:e.toolApiService.getDeployment(s)};t.push(i)}),t})).subscribe(function(n){e.deployments=n,e.cdr.markForCheck()})}},{key:"deploy",value:function(){this.toolApiService.createDeployment("123").subscribe()}},{key:"stopJob",value:function(e){this.toolApiService.stopDeployment(e).subscribe()}},{key:"purge",value:function(){this.toolApiService.purgeDeployment().subscribe()}},{key:"runJob",value:function(e){console.log("runJob",e)}},{key:"execJob",value:function(e){this.toolApiService.execJob(e,{}).subscribe()}},{key:"openDrawer",value:function(e,n){var t=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:P.a.Left,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"50",i=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],r=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],a=arguments.length>6?arguments[6]:void 0;n||(n={}),console.log("context",n),this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:o,template:e,size:s,context:n,closeOnOutsideClick:i,parentContainer:a,isRoot:r,zIndex:1e3,cssClass:"backdrop_color"}).onDestroy(function(){t.document.body.classList.remove("cdk-global-scrollblock")})}}]),e}();E.ctorParameters=function(){return[{type:C},{type:M.a},{type:Document,decorators:[{type:l.D,args:[c.d]}]},{type:d.a},{type:l.k},{type:B}]},E.propDecorators={tool_id:[{type:l.I,args:["tool_id"]}]},E=Object(a.a)([Object(l.n)({selector:"app-deployment-ui",template:'<div fxLayout="column">\n  <ng-container *ngFor="let deploy of deployments  ; index as index">\n\n    <nb-card *ngIf="deploy.details | async as details">\n      <nb-card-header>\n        \x3c!-- Name --\x3e\n        <div class="row">\n          <div fxFlex class="text-hint">\n\n            @{{ details?.Name  }}\n\n          </div>\n          <div fxFlex class="subtitle-2">\n            {{details?.Status}}\n\n\n            \x3c!-- @{{ details?.BuildDetails | json  }} --\x3e\n\n\n          </div>\n        </div>\n\n      </nb-card-header>\n\n      <nb-card-body>\n\n\n        \x3c!-- Namespace --\x3e\n        <div class="row">\n          <div fxFlex class="subtitle">\n            Namespace\n\n          </div>\n          <div fxFlex class="subtitle-2">\n            {{ details?.Namespace  }}\n\n          </div>\n        </div>\n\n\n\n        \x3c!-- Status --\x3e\n        <div class="row">\n          <div fxFlex class="subtitle">\n            Status\n\n          </div>\n          <div fxFlex class="subtitle-2">\n            {{ details?.Status  }}\n\n          </div>\n        </div>\n\n\n        \x3c!-- Submitted On --\x3e\n        <div class="row">\n          <div fxFlex class="subtitle">\n            SubmitTime\n\n          </div>\n          <div fxFlex class="subtitle-2">\n            {{ details?.SubmitTime / 1000000  | date:"dd-MM-YY , HH:mm:ss" }}\n\n          </div>\n        </div>\n\n\n\n\n\n      </nb-card-body>\n\n\n      <nb-card-footer fxLayoutGap="1rem" fxLayoutAlign="start">\n\n\n        <button (click)="purge(  )" status="primary" ghost size="small" nbButton>\n\n          <nb-icon icon="settings-2-outline"></nb-icon>\n          Purge\n        </button>\n\n\n        <button (click)="execJob( deploy?.id )" status="primary" ghost size="small" nbButton>\n\n          <nb-icon icon="settings-2-outline"></nb-icon>\n          Exec\n        </button>\n\n        <button (click)="openDrawer(jobConfigTemplate , context =  { config: details?.JobConfig , id : deploy?.id }  ) "\n          status="success" ghost size="small" nbButton>\n\n          <nb-icon icon="settings-2-outline"></nb-icon>\n          Run\n        </button>\n\n\n        <button (click)="stopJob( deploy?.id )" status="basic" ghost size="small" nbButton>\n\n          <nb-icon icon="settings-2-outline"></nb-icon>\n          Stop\n        </button>\n\n        <button (click)="openDrawer(logsTemplate)" status="danger" ghost size="small" nbButton>\n\n          <nb-icon icon="settings-2-outline"></nb-icon>\n          Logs\n        </button>\n\n\n        <button status="basic" ghost size="small" nbButton>\n\n          <nb-icon icon="diagonal-arrow-left-down-outline"></nb-icon>\n\n          {{details?.Status}}\n        </button>\n\n\n\n      </nb-card-footer>\n    </nb-card>\n  </ng-container>\n\n</div>\n\n\n<ng-template #logsTemplate let-close="close" let-context="context">\n\n  <app-log-stream [close]="close" [deep_link]="true" [log_id]="context?.id"></app-log-stream>\n\n</ng-template>\n\n\n<ng-template let-close="close" let-context="context" #jobConfigTemplate>\n\n  <app-job-config [config]="context?.config" [id]="context?.id"></app-job-config>\n\n</ng-template>\n\n\n<ng-container #loading *ngIf="!deployments || deployments.length == 0">\n  <div fxLayoutAlign="center center">\n    <ngx-progress-spinner></ngx-progress-spinner>\n  </div>\n\n</ng-container>\n',styles:["nb-card-footer {\n  padding: 0.3rem;\n  overflow-x: scroll;\n  overflow-y: hidden;\n}"]})],E);var G,N=i("G1Gu"),$=i("3E0/"),q=i("/d8p"),V=i("1G5W");!function(e){e.IMAGE_BUILDER="image_builder",e.JOB="job"}(G||(G={}));var U=function(){function e(n,o){t(this,e),this.toolApiService=n,this.cdr=o,this.logSource=G.IMAGE_BUILDER,this.LOG_STREAM_STATUS$=r,this.testLogs="",this.deep_link=!1,this.log_id="npop3",this.topic=void 0,this.topics_=[],this.build_list=[],this.tailing=!0,this.streaming=!0,this.pollJobStatusSubscription$=O.a.EMPTY,this.scrollSubscruption=O.a.EMPTY}return s(e,[{key:"ngOnDestroy",value:function(){console.log("unsubscribe"),this.topic.subscription.unsubscribe(),this.topic.pauseStreamer$.next(r.STOP),this.pollJobStatusSubscription$.unsubscribe()}},{key:"toggleTail",value:function(e){1==e?this.resumeKeepAtBottom():this.pauseKeepAtBottom()}},{key:"toggleStreamingLogs",value:function(e,n){e?this.pause(n):this.resume(e)}},{key:"getSource",value:function(e){switch(console.log("logsource",this.logSource),this.logSource){case G.IMAGE_BUILDER:return this.toolApiService.getBuildExecutorStatus(e);case G.JOB:return this.toolApiService.getJobStatus(e);default:return this.toolApiService.getBuildExecutorStatus(e)}}},{key:"pollJobStatus",value:function(e){var n=this,t=new m.a;this.pollJobStatusSubscription$.unsubscribe(),this.pollJobStatusSubscription$=this.getSource(e).pipe(Object(v.a)(function(e){0==e.poll_again&&t.next(""),n.STATUS=e.exec_status,console.log("tap_1",e)}),Object($.a)(1e3),Object(q.a)(),Object(V.a)(t)).subscribe(function(e){})}},{key:"ngOnInit",value:function(){1==this.deep_link?this.deepLinkLoadLog():this.getExecutors(this.log_id)}},{key:"deepLinkLoadLog",value:function(){console.log("deep_link"),this.topic={log_id:this.log_id,exec_status:"SUCCESS",title:"val['_id']",desc:"Dummy Description",loaded:!1,initiated:!1,collapsed:!0,loading:new m.a,content:[],content$:new m.a,pauseStreamer$:new T.a(r.RESUME),subscription:O.a.EMPTY},this.streamLogs(0,!0),this.pollJobStatus(this.topic.log_id)}},{key:"resumeKeepAtBottom",value:function(){var e=this;this.scrollSubscruption.unsubscribe(),this.scrollSubscruption=Object(p.a)(300).subscribe(function(n){e.scrollbarRef.scrollTo({bottom:0,duration:150})})}},{key:"pauseKeepAtBottom",value:function(){this.scrollSubscruption.unsubscribe(),this.scrollbarRef.scrollTo({bottom:0,duration:0})}},{key:"streamLogs",value:function(e,n){var t=this;this.topic&&this.topic.loaded||(console.log(this.topic),this.topic.loading.next(!0),this.topic.subscription=this.toolApiService.getLogs(this.topic.log_id,200,this.topic.pauseStreamer$,L.d).pipe(Object(v.a)(function(e){t.topic.initiated=!0})).subscribe(function(e){t.topic.loaded=!0,t.topic.loading.next(!1),null!=e&&null!=e&&0!=e.length&&(t.topic.content.push(e),console.log("log loaded"),t.cdr.markForCheck())},function(e){console.log("error",e)},function(){console.log("completed"),t.topic.pauseStreamer$.next(r.STOP),t.cdr.markForCheck()}))}},{key:"getStatus",value:function(){}},{key:"collapsedChange",value:function(e,n){var t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];n||this.streamLogs(e,t)}},{key:"onSelectionChange",value:function(e){this.topic&&(console.log("onSelectioChange",e),this.topic.subscription.unsubscribe(),this.topic.pauseStreamer$.next(r.STOP),this.topic.content$.complete()),this.topic={log_id:this.build_list[e].log_id,exec_status:this.build_list[e].exec_status,title:"val['_id']",desc:"Dummy Description",loaded:!1,initiated:!1,collapsed:!0,loading:new m.a,content:[],content$:new m.a,pauseStreamer$:new T.a(r.RESUME),subscription:O.a.EMPTY},this.streamLogs(e,!1),this.pollJobStatus(this.topic.log_id),console.log("this.topic",this.topic)}},{key:"getExecutors",value:function(e){var n=this;this.toolApiService.getBuildExecoturs(e).subscribe(function(e){e.forEach(function(e,t){n.build_list.push({log_id:e._id,title:e._id,exec_status:e.exec_status,desc:"Dummy Description",loaded:!1,initiated:!1,collapsed:!0}),n.cdr.markForCheck(),0==t&&n.onSelectionChange(t)})})}},{key:"pause",value:function(e){this.topic.pauseStreamer$.next(r.PAUSE),this.cdr.markForCheck()}},{key:"resume",value:function(e){this.topic.pauseStreamer$.next(r.RESUME),this.cdr.markForCheck()}}]),e}();U.ctorParameters=function(){return[{type:C},{type:l.k}]},U.propDecorators={logSource:[{type:l.I,args:["logsource"]}],close:[{type:l.I,args:["close"]}],deep_link:[{type:l.I,args:["deep_link"]}],log_id:[{type:l.I,args:["log_id"]}],scrollbarRef:[{type:l.qb,args:[N.a,{static:!1}]}]},U=Object(a.a)([Object(l.n)({selector:"app-log-stream",template:'<nb-card fxFill >\n\n\n  <nb-card-header fxLayoutAlign="space-between center">\n\n    <div fxLayout="row" fxLayoutAlign="start center">\n      <button (click)="close.emit(true)" ghost status="basic" class="action" size="giant" nbButton>\n        <nb-icon class="text-alternate" icon="arrow-back-outline">\n        </nb-icon>\n      </button>\n\n      <div fxFlex>\n\n\n        <div fxLayout="column">\n          <div fxFlex class="subtitle text-alternate">\n            Logs  {{logsource | json}} {{STATUS}} \n          </div>\n          <div class="overflowFix">\n\n\n            <nb-select [style.marginRight]="\'1rem\'" (selectedChange)="onSelectionChange($event)" [selected]="0"\n              *ngIf="build_list.length > 0" placeholder="Success" size="tiny" status="danger" filled>\n              <nb-option *ngFor="let topic of build_list ; index as index" [value]="index">{{topic?.log_id}}\n              </nb-option>\n\n            </nb-select>\n          </div>\n        </div>\n      </div>\n\n\n\n    </div>\n\n\n  </nb-card-header>\n\n  <nb-card-body fxLayoutAlign="center center" fxLayout="column" class="content log-container">\n\n\n\n\n\n\n\n\n\n\n    <ng-template #logTemplate let-topic="topic">\n\n      <ng-container>\n\n        <div fxFill fxLayout="column" class="log-container">\n\n\n          <div fxFlexAlign="center" *ngIf=" topic?.content == undefined ||  topic?.content?.length < 1"\n            fxLayoutAlign="center center">\n            <ngx-progress-spinner></ngx-progress-spinner>\n          </div>\n\n\n\n\n\n\n          <ng-scrollbar [style.pointerEvents]=" tailing ? \'none\' : \'all\' " track="vertical" [scrollAuditTime]="20">\n\n            <div fxFlex>\n\n\n              <div class="code">\n\n                <div *ngFor="let content of topic?.content">\n                  <code fxFlex>\n                    <pre [innerText]="content">   </pre>\n                  </code>\n                </div>\n              </div>\n\n\n\n\n            </div>\n\n\n          </ng-scrollbar>\n\n\n\n\n\n        </div>\n\n\n      </ng-container>\n\n\n    </ng-template>\n\n\n\n    <ng-container *ngIf="topic">\n      <ng-container *ngTemplateOutlet="logTemplate; context: { \'topic\': topic } ">\n      </ng-container>\n    </ng-container>\n\n\n\n\n\n\n  </nb-card-body>\n\n\n  <nb-card-footer fxLayoutAlign="start center" (click)="save()">\n\n\n    <div class="overlay-button">\n\n      <ng-template #actionBtns let-status="pauseStatus">\n\n        <div class="row" fxFlex fxLayoutAlign="center center" fxLayoutGap="1rem">\n\n\n          <nb-button-group size="small" shape="round" multiple>\n\n            <button hero status="danger" (click)="toggleStreamingLogs($event)" nbButtonToggle size="small">\n              <nb-icon icon="pause-circle">\n              </nb-icon>\n\n              {{  ( status == LOG_STREAM_STATUS$.PAUSE   )  ? \'Resume\' : \'Pause\'  }}\n\n            </button>\n\n\n\n            <button [(pressed)]="tailing" (pressedChange)="toggleTail($event)" nbButtonToggle size="small">\n              <nb-icon icon="arrowhead-down-outline"></nb-icon>\n              Follow\n            </button>\n          </nb-button-group>\n        </div>\n      </ng-template>\n\n      <ng-container *ngTemplateOutlet="actionBtns; context:{pauseStatus: topic?.pauseStreamer$ | async }">\n      </ng-container>\n    </div>\n\n  </nb-card-footer>\n\n</nb-card>\n',changeDetection:l.j.OnPush,styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\nnb-card {\n  max-height: calc(100vh - 7rem);\n  margin: 0;\n}\nnb-card .container {\n  margin-top: 1rem;\n}\nnb-card textarea {\n  resize: none;\n}\nnb-card-header {\n  padding: 0.4rem;\n  background: var(--background-alternative-color-2);\n  box-shadow: 2px 2px 3px rgba(255, 255, 255, 0.16), 2px 2px 3px rgba(255, 255, 255, 0.23);\n  border: 0em;\n  color: #fff;\n}\nnb-card-footer {\n  padding: 0.3rem;\n  background: var(--background-alternative-color-2);\n  border: 0em;\n}\n.subtitle {\n  color: #a4b1cd !important;\n  font-weight: 600;\n  line-height: 1rem;\n  font-size: 1rem;\n}\nnb-card {\n  border: 0;\n}\nnb-card-body {\n  border: 0;\n  padding: 0rem;\n}\n.buildBtn {\n  border-radius: 0;\n}\n.log-container {\n  background: var(--background-alternative-color-1);\n  color: var(--text-alternate-color);\n}\n.log-container .ng-trigger-accordionItemBody {\n  margin-left: 1rem;\n  margin-right: 1rem;\n  margin-top: 0.5rem;\n  margin-bottom: 0.5rem;\n}\n.log-container pre {\n  margin: 0;\n}\n.overlay-button {\n  position: -webkit-sticky;\n  position: sticky;\n  bottom: 1rem;\n  right: 1rem;\n}\n:host ::ng-deep nb-accordion nb-accordion-item nb-accordion-item-header:hover {\n  background: var(--background-alternative-color-1);\n  color: var(--text-alternate-color);\n}\n:host ::ng-deep nb-accordion nb-accordion-item nb-accordion-item-header.accordion-item-header-expanded {\n  background: var(--background-alternative-color-2);\n  color: var(--text-alternate-color);\n}\n:host ::ng-deep nb-accordion nb-accordion-item nb-accordion-item-body.marginBody {\n  overflow: scroll;\n  background: var(--background-alternative-color-1);\n  color: var(--text-alternate-color);\n}\n:host ::ng-deep nb-accordion nb-accordion-item nb-accordion-item-body.marginBody .ng-trigger-accordionItemBody {\n  margin-left: 1rem;\n  margin-right: 1rem;\n  margin-top: 0.5rem;\n  margin-bottom: 0.5rem;\n}\n:host ::ng-deep nb-accordion nb-accordion-item nb-accordion-item-body.marginBody pre {\n  margin: 0;\n}\n.head {\n  height: 4rem;\n  background: var(--background-alternative-color-2);\n  box-shadow: 2px 2px 3px rgba(255, 255, 255, 0.16), 2px 2px 3px rgba(255, 255, 255, 0.23);\n  color: #fff;\n}\n.content {\n  height: calc(100% - 4rem);\n}\n.action {\n  margin-left: 5px;\n}\n.action:hover nb-icon {\n  color: var(--color-alternate-500);\n}\n.code {\n  padding: 1rem;\n}\n.overflowFix {\n  overflow: auto;\n}"]})],U);var J=function(){function e(n,o,s,i,r){t(this,e),this.toolApiService=n,this.sharedDataService=o,this.cdr=s,this.document=i,this.drawerMngr=r}return s(e,[{key:"ngOnInit",value:function(){var e=this;this.jobs=this.sharedDataService.ToolId.pipe(Object(y.a)(function(n){return e.toolApiService.getJobs(n)}),Object(_.b)(function(e){return e}))}},{key:"openDrawer",value:function(e,n){var t=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:P.a.Left,s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],i=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],r=arguments.length>6?arguments[6]:void 0;n||(n={}),n.logsource=G.JOB,console.log("context",n),this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:o,template:e,context:n,closeOnOutsideClick:s,parentContainer:r,isRoot:i,zIndex:1e3,cssClass:"backdrop_color"}).onDestroy(function(){t.document.body.classList.remove("cdk-global-scrollblock")})}}]),e}();J.ctorParameters=function(){return[{type:C},{type:B},{type:l.k},{type:Document,decorators:[{type:l.D,args:[c.d]}]},{type:M.a}]},J=Object(a.a)([Object(l.n)({selector:"app-job-list",template:'<nb-accordion>\n  <nb-accordion-item *ngFor="let job of jobs | async ;  let i=index  ">\n\n    <nb-accordion-item-header fxLayoutAlign="space-between">\n\n      <span>\n\n        Job {{i + 1}}\n        {{ job | json }}\n\n      </span>\n\n      <span class="text-hint">\n        {{ \'@\' +  ( job?.exec_status || \'Unknown\' ) }}\n      </span>\n    </nb-accordion-item-header>\n    <nb-accordion-item-body>\n\n\n      <button [routerLink]="[ \'/jobs\' , \'job\' , job?._id ]" status="basic" filled size="small" nbButton>\n\n        <nb-icon icon="file-text-outline"></nb-icon>\n        Details\n      </button>\n\n      <button (click)="openDrawer(logsTemplate, context = {\n        \'id\': job?._id\n\n      }  )" status="basic" filled size="small" nbButton>\n\n        <nb-icon icon="file-text-outline"></nb-icon>\n        Logs\n      </button>\n\n    </nb-accordion-item-body>\n  </nb-accordion-item>\n</nb-accordion>\n\n\n<ng-template #logsTemplate let-close="close" let-context="context">\n\n\n  <app-log-stream [logsource]="context?.logsource" [close]="close" [deep_link]="true" [log_id]="context?.id">\n  </app-log-stream>\n\n\n</ng-template>\n',styles:[""]})],J);var H,Y=function(){function e(n,o,s,i,r){t(this,e),this.toolApiService=n,this.drawerMngr=o,this.document=s,this.activatedRoute=i,this.sharedDataService=r,this.tabs=[],this.refrence_id="refrence_id"}return s(e,[{key:"ngOnInit",value:function(){var e=this;this.activatedRoute.params.pipe(Object(y.a)(function(e){return e.id})).pipe(Object(j.a)(function(e){return e})).pipe(Object(v.a)(function(n){e.refrence_id=n,e.sharedDataService.SetToolId(n),e.tabs=[{title:"Deployments",route:[{outlets:{view:"deployments"}}],responsive:!0},{title:"Images",route:[{outlets:{view:"images"}}],responsive:!0},{title:"Builds",route:[{outlets:{view:"builds"}}],responsive:!0},{title:"Jobs",route:[{outlets:{view:"jobs"}}],responsive:!0}]})).subscribe(function(n){e.builds$=e.toolApiService.getBuilds(n).pipe(Object(v.a)(function(n){n.length<1&&e.openDrawer(e.buildCreateTemplate)}))})}},{key:"openDrawer",value:function(e,n){var t=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:P.a.Left,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"50",i=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],r=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],a=arguments.length>6?arguments[6]:void 0;n||(n={}),console.log("context",n),this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:o,template:e,size:s,context:n,closeOnOutsideClick:i,parentContainer:a,isRoot:r,zIndex:1e3,cssClass:"backdrop_color"}).onDestroy(function(){t.document.body.classList.remove("cdk-global-scrollblock")})}},{key:"openLogs",value:function(e,n){var t=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:P.a.Left,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"50%",i=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],r=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],a=arguments.length>6?arguments[6]:void 0;this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:o,template:e,size:s,closeOnOutsideClick:i,parentContainer:a,isRoot:r,zIndex:1e3,cssClass:"backdrop_color",context:{id:n}}).onDestroy(function(){t.document.body.classList.remove("cdk-global-scrollblock")})}}]),e}();Y.ctorParameters=function(){return[{type:C},{type:M.a},{type:Document,decorators:[{type:l.D,args:[c.d]}]},{type:d.a},{type:B}]},Y.propDecorators={buildCreateTemplate:[{type:l.qb,args:["buildCreateTemplate",{static:!1}]}],logTemplate:[{type:l.qb,args:["logsTemplate",{static:!1}]}]},Y=Object(a.a)([Object(l.n)({selector:"app-tool-explore",template:'<nb-card fxFill>\n\n  <nb-card-header>\n\n    <div fxLayout="row">\n\n      <button shape="round" [routerLink]="[\'/tools\' ]" ghost status="basic" class="action" size="large" nbButton>\n        <nb-icon icon="arrow-back-outline">\n        </nb-icon>\n      </button>\n      <nb-route-tabset fxFlex [tabs]="tabs"></nb-route-tabset>\n\n\n    </div>\n\n\n  </nb-card-header>\n\n\n  <nb-card-body>\n\n\n    <router-outlet name="view">\n\n    </router-outlet>\n  </nb-card-body>\n\n</nb-card>\n',styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\n.head {\n  height: 4rem;\n  background: var(--background-alternative-color-2);\n  box-shadow: 2px 2px 3px rgba(255, 255, 255, 0.16), 2px 2px 3px rgba(255, 255, 255, 0.23);\n  color: #fff;\n}\n.content {\n  height: calc(100% - 4rem);\n  overflow: auto;\n}\n.action {\n  margin-left: 5px;\n}\n.action:hover nb-icon {\n  color: var(--color-alternate-500);\n}\nnb-tab {\n  padding: 0px;\n}\nnb-card {\n  max-height: calc(100vh - 7rem);\n  margin: 0;\n}\nnb-card .container {\n  margin-top: 1rem;\n}\nnb-card textarea {\n  resize: none;\n}\nnb-card nb-card-header {\n  padding: 0.4rem;\n}"]})],Y),function(e){e.HOST="host",e.DOMAIN="domain",e.ANDROID="android",e.IOS="ios",e.WEB="web",e.REPOSITORY="repository",e.DOCKER="docker"}(H||(H={}));var K="host",X="domain",Q=function(){function e(){t(this,e)}return s(e,[{key:"getToolMenu",get:function(){return[{name:"Tools",icon:"eva-arrow-left",type:H.HOST,link:["/tool","host","import"],id:K,path:["/tool/host"],children:[{name:"Create Tool",icon:"external-link-outline",link:["/tool","host","import"],id:K},{name:"Configure",icon:"external-link-outline",link:["/tool","host","configure"],id:"host_configure"}]},{name:"Data Sources",type:H.DOMAIN,link:["/tool","domain","add"],path:["/tool/domain"],id:X,children:[{name:"Create",icon:"plus-circle-outline",link:["/tool","domain","add"],id:X},{name:"Manage",icon:"external-link-outline",link:["/tool","domain","configure"],id:"domain_configure"}]},{name:"Plugin Store",type:H.WEB,link:["/tool","web","add"],id:"web",path:["/tool/web"],children:[{name:"Create",icon:"plus-circle-outline",link:["/tool","web","add"],id:"web"},{name:"Import",icon:"external-link-outline",link:["/tool","web","import"],id:"web_create"},{name:"Configure",icon:"external-link-outline",link:["/tool","web","configure"],id:"web_configure"}]}]}}]),e}();Q.ctorParameters=function(){return[]},Q=Object(a.a)([Object(l.F)({providedIn:"root"})],Q);var Z=i("aceb"),ee=function(){function e(n,o,s,i,r){t(this,e),this.toolStoreService=n,this.dialogService=o,this.toolApiService=s,this.drawerMngr=i,this.document=r,this.tabs=[{title:"Logs",route:[{}]},{title:"Result",route:[{}]},{title:"Deployments",route:[]}],this.testLogs="",this.readOnly=!1,this.mode="markdown",this.options={mode:this.mode},this.toolMenu=this.toolStoreService.getToolMenu,this.tools$=this.toolApiService.getTools()}return s(e,[{key:"ngOnInit",value:function(){}},{key:"open",value:function(e){this.dialogService.open(e,{dialogClass:"test",closeOnBackdropClick:!1,context:"this is some additional data passed to dialog"})}},{key:"openDrawer",value:function(e,n){var t=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:P.a.Left,s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],i=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],r=arguments.length>6?arguments[6]:void 0;n||(n={}),console.log("context",n),this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:o,template:e,context:n,closeOnOutsideClick:s,parentContainer:r,isRoot:i,zIndex:1e3,cssClass:"backdrop_color"}).onDestroy(function(){t.document.body.classList.remove("cdk-global-scrollblock")})}}]),e}();ee.ctorParameters=function(){return[{type:Q},{type:Z.j},{type:C},{type:M.a},{type:Document,decorators:[{type:l.D,args:[c.d]}]}]},ee=Object(a.a)([Object(l.n)({selector:"app-tool-home",template:'<nb-layout withScroll center>\n\n\n  <nb-layout-header fixed>\n    <div fxFlex fxLayoutAlign="space-between center">\n      <div class="imageContainer" fxLayoutAlign="center center">\n        <img src="/assets/logo.png">\n      </div>\n\n\n      <div>\n\n\n\n\n\n      </div>\n\n\n    </div>\n\n\n\n  </nb-layout-header>\n\n\n\n  <nb-sidebar *ngIf="false" right fxLayout="column">\n\n\n\n    <nb-list>\n\n      <nb-list-item class="create" @init fxLayoutAlign="center">\n\n\n        <div fxFlex fxLayout="row">\n\n          <button (click)="openDrawer(dialog)" fullWidth class="newBtn" shape="round" nbButton>\n\n            <div class="icon" icon="plus"></div>\n\n            <span>\n              Create Tool\n\n            </span>\n          </button>\n\n        </div>\n      </nb-list-item>\n\n\n      <nb-list-item @init *ngFor="let toolMenuItem of toolMenu; index as index">\n        <app-navbar-list-item [activestate]="activeState" [item]="toolMenuItem" [routerlink]="toolMenuItem.type"\n          fxLayout="column" [title]="toolMenuItem.name" fxFlex>\n\n        </app-navbar-list-item>\n      </nb-list-item>\n\n\n    </nb-list>\n\n\n\n  </nb-sidebar>\n\n\n\n\n\n\n  <nb-layout-column>\n    <router-outlet>\n    </router-outlet>\n    \x3c!-- <app-tool-screen></app-tool-screen> --\x3e\n\n  </nb-layout-column>\n\n  \x3c!-- <nb-layout-column>\n\n    <app-tool-screen></app-tool-screen>\n\n  </nb-layout-column> --\x3e\n\n</nb-layout>\n\n\n\n\n<ng-template #dialog let-close="close" let-data let-ref="dialogRef">\n  <app-tool-create [close]="close"></app-tool-create>\n</ng-template>\n',changeDetection:l.j.OnPush,animations:e(z.a),styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\n.subtitle {\n  color: #a4b1cd !important;\n  font-weight: 600;\n  line-height: 1rem;\n  font-size: 1rem;\n}\n.avatar {\n  width: 2rem;\n  height: 2rem;\n}\nimg {\n  height: 3rem;\n}\n:host ::ng-deep nb-sidebar {\n  margin-right: 0 !important;\n  margin-left: 0 !important;\n}\n:host ::ng-deep nb-sidebar nb-list-item {\n  padding: 0px !important;\n  border: 0 !important;\n}\n:host ::ng-deep nb-sidebar .item {\n  border: 0;\n}\n:host ::ng-deep nb-sidebar .scrollable {\n  padding: 0px !important;\n}\n:host ::ng-deep nb-sidebar nb-tab {\n  padding: 1.25rem;\n}\nnb-list-item {\n  margin-left: 3px !important;\n  margin-right: 3px !important;\n  margin-top: 0px !important;\n  padding: 0.8rem !important;\n  font-weight: 350 !important;\n}\n:host ::ng-deep nb-layout-header nav {\n  padding: 0rem !important;\n}\n:host ::ng-deep .accordion-item-header-expanded {\n  background: #fff !important;\n  color: #292828 !important;\n  font-weight: 550 !important;\n}\n:host ::ng-deep nb-accordion-item-body .item-body {\n  padding: 0px !important;\n}\n.selected-route {\n  background: #fff !important;\n  color: #000 !important;\n  font-weight: 600 !important;\n}\nnb-sidebar-footer {\n  margin: 0.4rem !important;\n}\nnb-sidebar-header {\n  background: #171a21 !important;\n}\n.colored {\n  color: #3366ff;\n}\n.logo {\n  width: 190px;\n  height: auto;\n}\nnb-layout-column {\n  overflow: hidden;\n}\n.roundBtn {\n  width: 4rem;\n  height: 4rem;\n  line-height: 115px;\n  text-align: center;\n  border: 0px solid red;\n  background-image: url(\"/assets/logo_mini.png\");\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: contain;\n}\npre {\n  font: 500 12px/1.5 Monaco, Consolas, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", \"Courier New\", Courier, monospace;\n  white-space: pre;\n  padding: 0px 0px 0px 31px;\n}\nbutton.newBtn {\n  padding: 0.3rem !important;\n  padding-left: 1rem !important;\n  padding-right: 1rem !important;\n  text-transform: capitalize !important;\n  box-shadow: 0 1px 2px 0 rgba(60, 64, 67, 0.302), 0 1px 3px 1px rgba(60, 64, 67, 0.149) !important;\n  align-items: center !important;\n  background-color: #fff !important;\n  border: 1px solid transparent;\n  border-radius: 24px;\n  color: #3c4043 !important;\n}\nbutton.newBtn span {\n  margin-right: 1rem;\n  margin-top: 0.5rem;\n  margin-bottom: 0.5rem;\n  font-weight: 600;\n}\nbutton.newBtn .icon {\n  margin-right: 1rem;\n  background-image: url(\"data:image/svg+xml;charset=UTF-8,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2236%22 height=%2236%22 viewBox=%220 0 36 36%22%3E%3Cpath fill=%22%2334A853%22 d=%22M16 16v14h4V20z%22/%3E%3Cpath fill=%22%234285F4%22 d=%22M30 16H20l-4 4h14z%22/%3E%3Cpath fill=%22%23FBBC05%22 d=%22M6 16v4h10l4-4z%22/%3E%3Cpath fill=%22%23EA4335%22 d=%22M20 16V6h-4v14z%22/%3E%3Cpath fill=%22none%22 d=%22M0 0h36v36H0z%22/%3E%3C/svg%3E\");\n  width: 2rem !important;\n  height: 2rem !important;\n}\nbutton.newBtn:hover {\n  box-shadow: 0 3px 5px 0 rgba(60, 64, 67, 0.302), 0 3px 5px 1px rgba(60, 64, 67, 0.149) !important;\n  background-color: #fff !important;\n}\n.dialog nb-card {\n  width: 50rem !important;\n  box-shadow: 0 4px 8px 0 rgba(60, 64, 67, 0.302), 0 4px 8px 1px rgba(60, 64, 67, 0.149) !important;\n}\n.create {\n  margin: 1rem !important;\n}"]})],ee);var ne=i("JX91"),te=function(){function e(n,o,s){t(this,e),this.toolApiService=n,this.drawerMngr=o,this.document=s,this.tools$=this.toolApiService.getTools()}return s(e,[{key:"ngOnInit",value:function(){var e=this;this.groups=[{name:"Group 1",children:["Option 11","Option 12","Option 13"]},{name:"Group 2",children:["Option 21","Option 22","Option 23"]},{name:"Group 3",children:["Option 31","Option 32","Option 33"]}],this.filteredGroups$=Object(f.a)(this.groups),this.inputFormControl=new h.d,this.filteredGroups$=this.inputFormControl.valueChanges.pipe(Object(ne.a)(""),Object(y.a)(function(n){return e.filter(n)}))}},{key:"filterChildren",value:function(e,n){return e.filter(function(e){return e.toLowerCase().includes(n)})}},{key:"filter",value:function(e){var n=this,t=e.toLowerCase();return this.groups.map(function(e){return{name:e.name,children:n.filterChildren(e.children,t)}}).filter(function(e){return e.children.length})}},{key:"trackByFn",value:function(e,n){return n.name}},{key:"openDrawer",value:function(e,n){var t=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:P.a.Left,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"50%",i=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],r=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],a=arguments.length>6?arguments[6]:void 0;n||(n={}),this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:o,template:e,size:s,context:n,closeOnOutsideClick:i,parentContainer:a,isRoot:r,zIndex:1e3,cssClass:"backdrop_color"}).onDestroy(function(){t.document.body.classList.remove("cdk-global-scrollblock")})}}]),e}();te.ctorParameters=function(){return[{type:C},{type:M.a},{type:Document,decorators:[{type:l.D,args:[c.d]}]}]};var oe=[{path:"",component:ee,children:[{path:"test",component:I},{path:"",component:te=Object(a.a)([Object(l.n)({selector:"app-tool-list",template:'<ng-container *ngIf=" tools$ | async as tools ; else loading">\n\n\n\n  <nb-card *ngIf="false">\n    <nb-card-header>\n\n\n      <div fxLayout="row" fxLayoutAlign="start center">\n\n        <button shape="round" [routerLink]="[\'/tools\' , \'\']" ghost status="basic" class="action" size="large" nbButton>\n          <nb-icon icon="arrow-back-outline">\n\n          </nb-icon>\n        </button>\n\n        <div class="h6 text-hint">\n          Tools\n\n        </div>\n\n\n\n\n\n      </div>\n    </nb-card-header>\n    <nb-list>\n      <nb-list-item fxLayout="row" fxLayoutAlign="space-between" *ngFor="let tool of tools">\n\n        <div>\n\n          <div class="title text-hint">\n            {{ tool?.name || \'Tool Name\' }}\n          </div>\n          <div class="desc text-hint">\n            {{ tool?.description || \'Tool Description\' }}\n          </div>\n        </div>\n\n\n        <div>\n\n\n\n\n\n          <button (click)="openDrawer(toolEditTemplate  , context =  { \'tool_id\':  tool?._id , \'edit_mode\': true } )"\n            status="basic" ghost size="small" nbButton>\n\n            <nb-icon icon="settings-2-outline"></nb-icon>\n            Edits\n          </button>\n\n\n          <button status="basic" ghost size="small" nbButton>\n\n            <nb-icon icon="diagonal-arrow-left-down-outline"></nb-icon>\n            Fork\n          </button>\n\n\n          <button [routerLink]="[ \'builds\' , tool?._id ]  " status="success" size="small" nbButton>Explore</button>\n        </div>\n\n\n\n      </nb-list-item>\n    </nb-list>\n  </nb-card>\n\n\n\n  <nb-layout-header subHeader>\n\n    <div fxLayout="row" fxFlex fxLayoutAlign="start center">\n\n      <button shape="round" [routerLink]="[\'/\'  ]" ghost status="basic" class="action" size="large" nbButton>\n        <nb-icon icon="arrow-back-outline">\n\n        </nb-icon>\n      </button>\n\n      <div fxFlex class="h6 text-hint">\n        Tools\n\n      </div>\n\n      <button (click)="openDrawer(toolEditTemplate)" class="newBtn" shape="round" nbButton>\n\n        <div class="icon" icon="plus"></div>\n\n        <span>\n          Create Tool\n\n        </span>\n      </button>\n    </div>\n\n  </nb-layout-header>\n\n\n\n\n  <nb-accordion>\n    <nb-accordion-item [expanded]="index == 0" *ngFor="let tool of tools   ; index as index ">\n      <nb-accordion-item-header fxLayoutAlign="space-between">\n\n\n        <span>\n          {{ tool?.name || \'Tool Name\' }}\n\n        </span>\n\n        <span class="text-hint">\n          {{ \'@\' +  ( tool?.alias || \'Alias\' ) }}\n        </span>\n      </nb-accordion-item-header>\n      <nb-accordion-item-body>\n\n        <nb-card>\n          <nb-card-body>\n            <div>\n\n              <div class="text-hint">\n                {{ tool?.description || \'Tool Description\' }}\n              </div>\n\n            </div>\n          </nb-card-body>\n          <nb-card-footer fxLayoutGap="1rem" fxLayoutAlign="end center">\n\n            <div fxLayoutGap="0.5rem" fxLayoutAlign="end center">\n\n\n              <nb-button-group multiple status="primary" size="small" appearance="filled">\n\n                <button\n                  (click)="openDrawer(toolEditTemplate  , context =  { \'tool_id\':  tool?._id , \'edit_mode\': true } )"\n                  nbButton>\n\n                  <nb-icon icon="settings-2-outline"></nb-icon>\n                  Edit\n                </button>\n                <button (click)="openDrawer(logsTemplate)" nbButton>\n\n                  <nb-icon icon="flip-2-outline"></nb-icon>\n                  Deployments\n                </button>\n\n\n                <button [routerLink]="[  \'/tools\'  , \'builds\', tool?._id ]  " nbButton>\n                  <nb-icon icon="expand-outline"></nb-icon>\n\n                  Explore\n                </button>\n\n              </nb-button-group>\n\n\n\n\n\n            </div>\n\n          </nb-card-footer>\n\n        </nb-card>\n\n      </nb-accordion-item-body>\n    </nb-accordion-item>\n\n  </nb-accordion>\n\n</ng-container>\n\n\n<ng-template #loading>\n  <div fxLayoutAlign="center center">\n    <ngx-progress-spinner></ngx-progress-spinner>\n  </div>\n\n</ng-template>\n\n\n\n<ng-template #toolEditTemplate let-close="close" let-context="context" let-ref="dialogRef">\n\n  <app-tool-create [edit_mode]="context.edit_mode" [close]="close" [tool_id]="context.tool_id"></app-tool-create>\n</ng-template>\n',changeDetection:l.j.OnPush,animations:e(z.a),styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\nnb-accordion-item {\n  margin-top: 0.4rem;\n  margin-bottom: 0.4rem;\n}\nnb-accordion-item nb-accordion-item-header .text-hint {\n  color: #000 !important;\n}\nnb-accordion-item nb-accordion-item-header:hover {\n  background: linear-gradient(to right, #457fca, #5b86e5);\n  color: #fff;\n}\nnb-accordion-item nb-accordion-item-header:hover .text-hint {\n  color: #fff !important;\n}\nnb-accordion-item nb-accordion-item-header .text-hint {\n  color: var(--text-basic-color) !important;\n}\nnb-accordion-item nb-accordion-item-header.accordion-item-header-expanded {\n  border-left: 2px var(--text-basic-color) solid !important;\n}\nnb-accordion-item nb-accordion-item-header.accordion-item-header-expanded .text-hint {\n  color: var(--text-alternate-color) !important;\n}\nnb-layout-header {\n  padding: 0rem !important;\n  margin: 0rem !important;\n}\ninput {\n  height: 100%;\n}\nnb-card {\n  margin-bottom: 0;\n  border: 0;\n}\nnb-accordion {\n  margin-top: 1rem;\n}\nbutton.newBtn {\n  padding: 0.3rem !important;\n  padding-left: 1rem !important;\n  padding-right: 1rem !important;\n  text-transform: capitalize !important;\n  box-shadow: 0 1px 2px 0 rgba(60, 64, 67, 0.302), 0 1px 3px 1px rgba(60, 64, 67, 0.149) !important;\n  align-items: center !important;\n  background-color: #fff !important;\n  border: 1px solid transparent;\n  border-radius: 24px;\n  color: #3c4043 !important;\n}\nbutton.newBtn span {\n  margin-right: 1rem;\n  margin-top: 0.5rem;\n  margin-bottom: 0.5rem;\n  font-weight: 600;\n}\nbutton.newBtn .icon {\n  margin-right: 1rem;\n  background-image: url(\"data:image/svg+xml;charset=UTF-8,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2236%22 height=%2236%22 viewBox=%220 0 36 36%22%3E%3Cpath fill=%22%2334A853%22 d=%22M16 16v14h4V20z%22/%3E%3Cpath fill=%22%234285F4%22 d=%22M30 16H20l-4 4h14z%22/%3E%3Cpath fill=%22%23FBBC05%22 d=%22M6 16v4h10l4-4z%22/%3E%3Cpath fill=%22%23EA4335%22 d=%22M20 16V6h-4v14z%22/%3E%3Cpath fill=%22none%22 d=%22M0 0h36v36H0z%22/%3E%3C/svg%3E\");\n  width: 2rem !important;\n  height: 2rem !important;\n}\nbutton.newBtn:hover {\n  box-shadow: 0 3px 5px 0 rgba(60, 64, 67, 0.302), 0 3px 5px 1px rgba(60, 64, 67, 0.149) !important;\n  background-color: #fff !important;\n}\n.h6 {\n  margin-left: 1rem;\n}\n.action {\n  margin-left: 5px;\n}\n.action:hover nb-icon {\n  color: var(--color-primary-500);\n}\nnb-list {\n  margin-top: 0.4rem;\n  margin-bottom: 0.4rem;\n}\nnb-list nb-list-item .text-hint {\n  color: #000 !important;\n}\nnb-list nb-list-item .text-hint {\n  color: var(--text-basic-color) !important;\n}\nnb-list nb-list-item.accordion-item-header-expanded {\n  border-left: 2px var(--text-basic-color) solid !important;\n}\nnb-list nb-list-item.accordion-item-header-expanded .text-hint {\n  color: var(--text-alternate-color) !important;\n}\nnb-card-header {\n  padding: 0rem !important;\n  margin: 0rem !important;\n}"]})],te)},{path:"builds/:id",component:Y,children:[{path:"",redirectTo:"builds",outlet:"view"},{path:"deployments",component:E,outlet:"view"},{path:"images",component:W,outlet:"view"},{path:"builds",component:D,outlet:"view"},{path:"jobs",component:J,outlet:"view"},{path:"**",redirectTo:"builds",outlet:"view"}]},{path:"builds/all/:id",component:D},{path:"details/:id",component:F},{path:"**",redirectTo:"/tools"}]}],se=function e(){t(this,e)};se=Object(a.a)([Object(l.N)({imports:[d.j.forChild(oe)],exports:[d.j]})],se);var ie=i("YUcS"),re=i("EcHK"),ae=i("tR1z"),le=function(){function e(){t(this,e)}return s(e,[{key:"ngOnInit",value:function(){}}]),e}();le.ctorParameters=function(){return[]},le=Object(a.a)([Object(l.n)({selector:"app-headbar",template:'<nb-layout-header fixed>\n\n  <div fxFlex fxLayoutAlign="center center">\n    <div fxFlex fxLayoutAlign="start center">\n      <button routerLink="/" nbButton ghost status="danger" size="small">\n        <img class="logo" src="/assets/logo.png">\n      </button>\n    </div>\n  </div>\n\n</nb-layout-header>\n',styles:[""]})],le);var ce=function e(){t(this,e)};ce=Object(a.a)([Object(l.N)({declarations:[],imports:[c.c]})],ce);var de=i("BN9v"),he=function(){function e(){t(this,e),this.loop=[1,1,1,1,11,1,1,1,2,312,3,213,12,312]}return s(e,[{key:"ngOnInit",value:function(){}}]),e}();he.ctorParameters=function(){return[]},he=Object(a.a)([Object(l.n)({selector:"app-tool-build-variants",template:'<app-build-create>\n  \n</app-build-create>\n\n<nb-list fxFlex>\n\n  <nb-list-item  *ngFor="let _ of loop">\n\n    <nb-card status="success" fxFlex>\n      <nb-card-header fxLayoutAlign="space-between center">\n\n        <div fxLayoutGap="1rem" fxLayoutAlign="start center">\n\n          <nb-icon icon="checkmark-circle-2"></nb-icon>\n\n          <span class="subtitle-2 text-alternate">\n            Hello World\n          </span>\n\n\n\n        </div>\n\n        <button status="control" hero nbButton size="tiny">\n          Save\n        </button>\n      </nb-card-header>\n      <nb-card-body>\n\n        <div class="cardcontainer" fxLayout="column">\n\n\n          <div fxFlex fxLayoutAlign="start center" fxLayoutGap="1rem">\n            <nb-icon icon="flip-2"></nb-icon>\n\n            <span>\n              <a class="text-basic">\n                Helllo\n              </a>\n            </span>\n            <span>\n              Word\n            </span>\n          </div>\n\n          <div fxFlex fxLayoutAlign="start center" fxLayoutGap="1rem">\n            <nb-icon icon="flip-2"></nb-icon>\n\n            <span>\n              <a>\n                Helllo\n              </a>\n            </span>\n            <span>\n              Word\n            </span>\n          </div>\n\n\n          <div fxFlex fxLayoutAlign="start center" fxLayoutGap="1rem">\n            <nb-icon icon="flip-2"></nb-icon>\n\n            <span>\n              <a>\n                Helllo\n              </a>\n            </span>\n            <span>\n              Word\n            </span>\n          </div>\n\n\n          <div fxFlex fxLayoutAlign="start center" fxLayoutGap="1rem">\n            <nb-icon icon="flip-2"></nb-icon>\n\n            <span>\n              <a>\n                Helllo\n              </a>\n            </span>\n            <span>\n              Word\n            </span>\n          </div>\n\n\n          <div fxFlex fxLayoutAlign="start center" fxLayoutGap="1rem">\n            <nb-icon icon="flip-2"></nb-icon>\n\n            <span>\n              <a>\n                Helllo\n              </a>\n            </span>\n            <span>\n              Word\n            </span>\n          </div>\n\n        </div>\n\n      </nb-card-body>\n    </nb-card>\n\n  </nb-list-item>\n\n</nb-list>\n',changeDetection:l.j.OnPush,styles:[".cardcontainer {\n  border-radius: 3px;\n  background: white;\n  box-shadow: rgba(9, 30, 66, 0.31) 0px 0px 1px;\n  padding: 1rem;\n  box-sizing: border-box;\n  position: relative;\n}\n\nnb-card-body {\n  background: rgba(244, 245, 247, 0.212);\n  box-sizing: border-box;\n  padding: 8px;\n  border-radius: 0px 0px 5px 5px;\n}"]})],he);var ue=function(){function e(){t(this,e),this.direction="horizontal"}return s(e,[{key:"ngOnInit",value:function(){}}]),e}();ue.ctorParameters=function(){return[]},ue=Object(a.a)([Object(l.n)({selector:"app-tool-screen",template:" <app-tool-list></app-tool-list>\n",changeDetection:l.j.OnPush,styles:["nb-layout-column:first-child {\n  flex: 1 !important;\n}\n\nnb-layout-column:last-child {\n  flex: 1 !important;\n}"]})],ue);var pe=i("HDdC"),me=i("Kj3r"),be=["gutterEls"];function fe(e,n){if(1&e){var t=l.Xc();l.Wc(0,"div",2,3),l.ed("mousedown",function(e){l.td(t);var n=l.gd().index;return l.gd().startDragging(e,2*n+1,n+1)})("touchstart",function(e){l.td(t);var n=l.gd().index;return l.gd().startDragging(e,2*n+1,n+1)})("mouseup",function(e){l.td(t);var n=l.gd().index;return l.gd().clickGutter(e,n+1)})("touchend",function(e){l.td(t);var n=l.gd().index;return l.gd().clickGutter(e,n+1)}),l.Rc(2,"div",4),l.Vc()}if(2&e){var o=l.gd().index,s=l.gd();l.xd("flex-basis",s.gutterSize,"px")("order",2*o+1)}}function we(e,n){if(1&e&&l.zd(0,fe,3,4,"div",1),2&e){var t=n.last;l.md("ngIf",!1===t)}}function ge(e){return void 0!==e.changedTouches&&e.changedTouches.length>0?{x:e.changedTouches[0].clientX,y:e.changedTouches[0].clientY}:void 0!==e.clientX&&void 0!==e.clientY?{x:e.clientX,y:e.clientY}:null}function xe(e,n){var t=e.nativeElement.getBoundingClientRect();return"horizontal"===n?t.width:t.height}function ve(e){return"boolean"==typeof e?e:"false"!==e}function ye(e,n){return null==e?n:(e=Number(e),!isNaN(e)&&e>=0?e:n)}function ke(e,n){if("percent"===e){var t=n.reduce(function(e,n){return null!==n?e+n:e},0);return n.every(function(e){return null!==e})&&t>99.9&&t<100.1}if("pixel"===e)return 1===n.filter(function(e){return null===e}).length}function Ae(e){return null===e.size?null:!0===e.component.lockSize?e.size:null===e.component.minSize?null:e.component.minSize>e.size?e.size:e.component.minSize}function Le(e){return null===e.size?null:!0===e.component.lockSize?e.size:null===e.component.maxSize?null:e.component.maxSize<e.size?e.size:e.component.maxSize}function Se(e,n,t,o){return n.reduce(function(n,t){var s=function(e,n,t,o){return 0===t?{areaSnapshot:n,pixelAbsorb:0,percentAfterAbsorption:n.sizePercentAtStart,pixelRemain:0}:0===n.sizePixelAtStart&&t<0?{areaSnapshot:n,pixelAbsorb:0,percentAfterAbsorption:0,pixelRemain:t}:"percent"===e?function(e,n,t){var o=(e.sizePixelAtStart+n)/t*100;if(n>0){if(null!==e.area.maxSize&&o>e.area.maxSize){var s=e.area.maxSize/100*t;return{areaSnapshot:e,pixelAbsorb:s,percentAfterAbsorption:e.area.maxSize,pixelRemain:e.sizePixelAtStart+n-s}}return{areaSnapshot:e,pixelAbsorb:n,percentAfterAbsorption:o>100?100:o,pixelRemain:0}}if(n<0){if(null!==e.area.minSize&&o<e.area.minSize){var i=e.area.minSize/100*t;return{areaSnapshot:e,pixelAbsorb:i,percentAfterAbsorption:e.area.minSize,pixelRemain:e.sizePixelAtStart+n-i}}return o<0?{areaSnapshot:e,pixelAbsorb:-e.sizePixelAtStart,percentAfterAbsorption:0,pixelRemain:n+e.sizePixelAtStart}:{areaSnapshot:e,pixelAbsorb:n,percentAfterAbsorption:o,pixelRemain:0}}}(n,t,o):"pixel"===e?function(e,n,t){var o=e.sizePixelAtStart+n;return n>0?null!==e.area.maxSize&&o>e.area.maxSize?{areaSnapshot:e,pixelAbsorb:e.area.maxSize-e.sizePixelAtStart,percentAfterAbsorption:-1,pixelRemain:o-e.area.maxSize}:{areaSnapshot:e,pixelAbsorb:n,percentAfterAbsorption:-1,pixelRemain:0}:n<0?null!==e.area.minSize&&o<e.area.minSize?{areaSnapshot:e,pixelAbsorb:e.area.minSize+n-o,percentAfterAbsorption:-1,pixelRemain:o-e.area.minSize}:o<0?{areaSnapshot:e,pixelAbsorb:-e.sizePixelAtStart,percentAfterAbsorption:-1,pixelRemain:n+e.sizePixelAtStart}:{areaSnapshot:e,pixelAbsorb:n,percentAfterAbsorption:-1,pixelRemain:0}:void 0}(n,t):void 0}(e,t,n.remain,o);return n.list.push(s),n.remain=s.pixelRemain,n},{remain:t,list:[]})}function Re(e,n){"percent"===e?n.areaSnapshot.area.size=n.percentAfterAbsorption:"pixel"===e&&null!==n.areaSnapshot.area.size&&(n.areaSnapshot.area.size=n.areaSnapshot.sizePixelAtStart+n.pixelAbsorb)}var Ce=function(){function n(e,o,s,i){t(this,n),this.ngZone=e,this.elRef=o,this.cdRef=s,this.renderer=i,this._direction="horizontal",this._unit="percent",this._gutterSize=11,this._gutterStep=1,this._restrictMove=!1,this._useTransition=!1,this._disabled=!1,this._dir="ltr",this._gutterDblClickDuration=0,this.dragStart=new l.y(!1),this.dragEnd=new l.y(!1),this.gutterClick=new l.y(!1),this.gutterDblClick=new l.y(!1),this.dragProgressSubject=new m.a,this.dragProgress$=this.dragProgressSubject.asObservable(),this.isDragging=!1,this.isWaitingClear=!1,this.dragListeners=[],this.snapshot=null,this.startPoint=null,this.endPoint=null,this.displayedAreas=[],this.hidedAreas=[],this._clickTimeout=null,this.direction=this._direction}return s(n,[{key:"direction",get:function(){return this._direction},set:function(e){this._direction="vertical"===e?"vertical":"horizontal",this.renderer.addClass(this.elRef.nativeElement,"as-"+this._direction),this.renderer.removeClass(this.elRef.nativeElement,"as-"+("vertical"===this._direction?"horizontal":"vertical")),this.build(!1,!1)}},{key:"unit",get:function(){return this._unit},set:function(e){this._unit="pixel"===e?"pixel":"percent",this.renderer.addClass(this.elRef.nativeElement,"as-"+this._unit),this.renderer.removeClass(this.elRef.nativeElement,"as-"+("pixel"===this._unit?"percent":"pixel")),this.build(!1,!0)}},{key:"gutterSize",get:function(){return this._gutterSize},set:function(e){this._gutterSize=ye(e,11),this.build(!1,!1)}},{key:"gutterStep",get:function(){return this._gutterStep},set:function(e){this._gutterStep=ye(e,1)}},{key:"restrictMove",get:function(){return this._restrictMove},set:function(e){this._restrictMove=ve(e)}},{key:"useTransition",get:function(){return this._useTransition},set:function(e){this._useTransition=ve(e),this._useTransition?this.renderer.addClass(this.elRef.nativeElement,"as-transition"):this.renderer.removeClass(this.elRef.nativeElement,"as-transition")}},{key:"disabled",get:function(){return this._disabled},set:function(e){this._disabled=ve(e),this._disabled?this.renderer.addClass(this.elRef.nativeElement,"as-disabled"):this.renderer.removeClass(this.elRef.nativeElement,"as-disabled")}},{key:"dir",get:function(){return this._dir},set:function(e){this._dir="rtl"===e?"rtl":"ltr",this.renderer.setAttribute(this.elRef.nativeElement,"dir",this._dir)}},{key:"gutterDblClickDuration",get:function(){return this._gutterDblClickDuration},set:function(e){this._gutterDblClickDuration=ye(e,0)}},{key:"transitionEnd",get:function(){var e=this;return new pe.a(function(n){return e.transitionEndSubscriber=n}).pipe(Object(me.a)(20))}},{key:"ngAfterViewInit",value:function(){var e=this;this.ngZone.runOutsideAngular(function(){setTimeout(function(){return e.renderer.addClass(e.elRef.nativeElement,"as-init")})})}},{key:"getNbGutters",value:function(){return 0===this.displayedAreas.length?0:this.displayedAreas.length-1}},{key:"addArea",value:function(e){var n={component:e,order:0,size:0,minSize:null,maxSize:null};!0===e.visible?(this.displayedAreas.push(n),this.build(!0,!0)):this.hidedAreas.push(n)}},{key:"removeArea",value:function(e){if(this.displayedAreas.some(function(n){return n.component===e})){var n=this.displayedAreas.find(function(n){return n.component===e});this.displayedAreas.splice(this.displayedAreas.indexOf(n),1),this.build(!0,!0)}else if(this.hidedAreas.some(function(n){return n.component===e})){var t=this.hidedAreas.find(function(n){return n.component===e});this.hidedAreas.splice(this.hidedAreas.indexOf(t),1)}}},{key:"updateArea",value:function(e,n,t){!0===e.visible&&this.build(n,t)}},{key:"showArea",value:function(n){var t,o=this.hidedAreas.find(function(e){return e.component===n});if(void 0!==o){var s=this.hidedAreas.splice(this.hidedAreas.indexOf(o),1);(t=this.displayedAreas).push.apply(t,e(s)),this.build(!0,!0)}}},{key:"hideArea",value:function(n){var t,o=this.displayedAreas.find(function(e){return e.component===n});if(void 0!==o){var s=this.displayedAreas.splice(this.displayedAreas.indexOf(o),1);s.forEach(function(e){e.order=0,e.size=0}),(t=this.hidedAreas).push.apply(t,e(s)),this.build(!0,!0)}}},{key:"getVisibleAreaSizes",value:function(){return this.displayedAreas.map(function(e){return null===e.size?"*":e.size})}},{key:"setVisibleAreaSizes",value:function(e){if(e.length!==this.displayedAreas.length)return!1;var n=e.map(function(e){return ye(e,null)});return!1!==ke(this.unit,n)&&(this.displayedAreas.forEach(function(e,t){return e.component._size=n[t]}),this.build(!1,!0),!0)}},{key:"build",value:function(e,n){if(this.stopDragging(),!0===e&&(this.displayedAreas.every(function(e){return null!==e.component.order})&&this.displayedAreas.sort(function(e,n){return e.component.order-n.component.order}),this.displayedAreas.forEach(function(e,n){e.order=2*n,e.component.setStyleOrder(e.order)})),!0===n){var t=ke(this.unit,this.displayedAreas.map(function(e){return e.component.size}));switch(this.unit){case"percent":var o=100/this.displayedAreas.length;this.displayedAreas.forEach(function(e){e.size=t?e.component.size:o,e.minSize=Ae(e),e.maxSize=Le(e)});break;case"pixel":if(t)this.displayedAreas.forEach(function(e){e.size=e.component.size,e.minSize=Ae(e),e.maxSize=Le(e)});else{var s=this.displayedAreas.filter(function(e){return null===e.component.size});if(0===s.length&&this.displayedAreas.length>0)this.displayedAreas.forEach(function(e,n){e.size=0===n?null:e.component.size,e.minSize=0===n?null:Ae(e),e.maxSize=0===n?null:Le(e)});else if(s.length>1){var i=!1;this.displayedAreas.forEach(function(e){null===e.component.size?!1===i?(e.size=null,e.minSize=null,e.maxSize=null,i=!0):(e.size=100,e.minSize=null,e.maxSize=null):(e.size=e.component.size,e.minSize=Ae(e),e.maxSize=Le(e))})}}}}this.refreshStyleSizes(),this.cdRef.markForCheck()}},{key:"refreshStyleSizes",value:function(){var e=this;if("percent"===this.unit)if(1===this.displayedAreas.length)this.displayedAreas[0].component.setStyleFlex(0,0,"100%",!1,!1);else{var n=this.getNbGutters()*this.gutterSize;this.displayedAreas.forEach(function(e){e.component.setStyleFlex(0,0,"calc( ".concat(e.size,"% - ").concat(e.size/100*n,"px )"),null!==e.minSize&&e.minSize===e.size,null!==e.maxSize&&e.maxSize===e.size)})}else"pixel"===this.unit&&this.displayedAreas.forEach(function(n){null===n.size?1===e.displayedAreas.length?n.component.setStyleFlex(1,1,"100%",!1,!1):n.component.setStyleFlex(1,1,"auto",!1,!1):1===e.displayedAreas.length?n.component.setStyleFlex(0,0,"100%",!1,!1):n.component.setStyleFlex(0,0,n.size+"px",null!==n.minSize&&n.minSize===n.size,null!==n.maxSize&&n.maxSize===n.size)})}},{key:"clickGutter",value:function(e,n){var t=this,o=ge(e);this.startPoint&&this.startPoint.x===o.x&&this.startPoint.y===o.y&&(null!==this._clickTimeout?(window.clearTimeout(this._clickTimeout),this._clickTimeout=null,this.notify("dblclick",n),this.stopDragging()):this._clickTimeout=window.setTimeout(function(){t._clickTimeout=null,t.notify("click",n),t.stopDragging()},this.gutterDblClickDuration))}},{key:"startDragging",value:function(n,t,o){var s=this;n.preventDefault(),n.stopPropagation(),this.startPoint=ge(n),null!==this.startPoint&&!0!==this.disabled&&!0!==this.isWaitingClear&&(this.snapshot={gutterNum:o,lastSteppedOffset:0,allAreasSizePixel:xe(this.elRef,this.direction)-this.getNbGutters()*this.gutterSize,allInvolvedAreasSizePercent:100,areasBeforeGutter:[],areasAfterGutter:[]},this.displayedAreas.forEach(function(e){var n={area:e,sizePixelAtStart:xe(e.component.elRef,s.direction),sizePercentAtStart:"percent"===s.unit?e.size:-1};e.order<t?!0===s.restrictMove?s.snapshot.areasBeforeGutter=[n]:s.snapshot.areasBeforeGutter.unshift(n):e.order>t&&(!0===s.restrictMove?0===s.snapshot.areasAfterGutter.length&&(s.snapshot.areasAfterGutter=[n]):s.snapshot.areasAfterGutter.push(n))}),this.snapshot.allInvolvedAreasSizePercent=[].concat(e(this.snapshot.areasBeforeGutter),e(this.snapshot.areasAfterGutter)).reduce(function(e,n){return e+n.sizePercentAtStart},0),0!==this.snapshot.areasBeforeGutter.length&&0!==this.snapshot.areasAfterGutter.length&&(this.dragListeners.push(this.renderer.listen("document","mouseup",this.stopDragging.bind(this))),this.dragListeners.push(this.renderer.listen("document","touchend",this.stopDragging.bind(this))),this.dragListeners.push(this.renderer.listen("document","touchcancel",this.stopDragging.bind(this))),this.ngZone.runOutsideAngular(function(){s.dragListeners.push(s.renderer.listen("document","mousemove",s.dragEvent.bind(s))),s.dragListeners.push(s.renderer.listen("document","touchmove",s.dragEvent.bind(s)))}),this.displayedAreas.forEach(function(e){return e.component.lockEvents()}),this.isDragging=!0,this.renderer.addClass(this.elRef.nativeElement,"as-dragging"),this.renderer.addClass(this.gutterEls.toArray()[this.snapshot.gutterNum-1].nativeElement,"as-dragged"),this.notify("start",this.snapshot.gutterNum)))}},{key:"dragEvent",value:function(n){var t=this;if(n.preventDefault(),n.stopPropagation(),null!==this._clickTimeout&&(window.clearTimeout(this._clickTimeout),this._clickTimeout=null),!1!==this.isDragging&&(this.endPoint=ge(n),null!==this.endPoint)){var o="horizontal"===this.direction?this.startPoint.x-this.endPoint.x:this.startPoint.y-this.endPoint.y;"rtl"===this.dir&&(o=-o);var s=Math.round(o/this.gutterStep)*this.gutterStep;if(s!==this.snapshot.lastSteppedOffset){this.snapshot.lastSteppedOffset=s;var i=Se(this.unit,this.snapshot.areasBeforeGutter,-s,this.snapshot.allAreasSizePixel),r=Se(this.unit,this.snapshot.areasAfterGutter,s,this.snapshot.allAreasSizePixel);if(0!==i.remain&&0!==r.remain?Math.abs(i.remain)===Math.abs(r.remain)||(Math.abs(i.remain)>Math.abs(r.remain)?r=Se(this.unit,this.snapshot.areasAfterGutter,s+i.remain,this.snapshot.allAreasSizePixel):i=Se(this.unit,this.snapshot.areasBeforeGutter,-(s-r.remain),this.snapshot.allAreasSizePixel)):0!==i.remain?r=Se(this.unit,this.snapshot.areasAfterGutter,s+i.remain,this.snapshot.allAreasSizePixel):0!==r.remain&&(i=Se(this.unit,this.snapshot.areasBeforeGutter,-(s-r.remain),this.snapshot.allAreasSizePixel)),"percent"===this.unit){var a=[].concat(e(i.list),e(r.list)),l=a.find(function(e){return 0!==e.percentAfterAbsorption&&e.percentAfterAbsorption!==e.areaSnapshot.area.minSize&&e.percentAfterAbsorption!==e.areaSnapshot.area.maxSize});l&&(l.percentAfterAbsorption=this.snapshot.allInvolvedAreasSizePercent-a.filter(function(e){return e!==l}).reduce(function(e,n){return e+n.percentAfterAbsorption},0))}i.list.forEach(function(e){return Re(t.unit,e)}),r.list.forEach(function(e){return Re(t.unit,e)}),this.refreshStyleSizes(),this.notify("progress",this.snapshot.gutterNum)}}}},{key:"stopDragging",value:function(e){var n=this;if(e&&(e.preventDefault(),e.stopPropagation()),!1!==this.isDragging){for(this.displayedAreas.forEach(function(e){return e.component.unlockEvents()});this.dragListeners.length>0;){var t=this.dragListeners.pop();t&&t()}this.isDragging=!1,!this.endPoint||this.startPoint.x===this.endPoint.x&&this.startPoint.y===this.endPoint.y||this.notify("end",this.snapshot.gutterNum),this.renderer.removeClass(this.elRef.nativeElement,"as-dragging"),this.renderer.removeClass(this.gutterEls.toArray()[this.snapshot.gutterNum-1].nativeElement,"as-dragged"),this.snapshot=null,this.isWaitingClear=!0,this.ngZone.runOutsideAngular(function(){setTimeout(function(){n.startPoint=null,n.endPoint=null,n.isWaitingClear=!1})})}}},{key:"notify",value:function(e,n){var t=this,o=this.getVisibleAreaSizes();"start"===e?this.dragStart.emit({gutterNum:n,sizes:o}):"end"===e?this.dragEnd.emit({gutterNum:n,sizes:o}):"click"===e?this.gutterClick.emit({gutterNum:n,sizes:o}):"dblclick"===e?this.gutterDblClick.emit({gutterNum:n,sizes:o}):"transitionEnd"===e?this.transitionEndSubscriber&&this.ngZone.run(function(){return t.transitionEndSubscriber.next(o)}):"progress"===e&&this.dragProgressSubject.next({gutterNum:n,sizes:o})}},{key:"ngOnDestroy",value:function(){this.stopDragging()}}]),n}();Ce.\u0275fac=function(e){return new(e||Ce)(l.Qc(l.S),l.Qc(l.v),l.Qc(l.k),l.Qc(l.bb))},Ce.\u0275cmp=l.Kc({type:Ce,selectors:[["as-split"]],viewQuery:function(e,n){var t;(1&e&&l.Ed(be,1),2&e)&&(l.pd(t=l.fd())&&(n.gutterEls=t))},inputs:{direction:"direction",unit:"unit",gutterSize:"gutterSize",gutterStep:"gutterStep",restrictMove:"restrictMove",useTransition:"useTransition",disabled:"disabled",dir:"dir",gutterDblClickDuration:"gutterDblClickDuration"},outputs:{dragStart:"dragStart",dragEnd:"dragEnd",gutterClick:"gutterClick",gutterDblClick:"gutterDblClick",transitionEnd:"transitionEnd"},exportAs:["asSplit"],ngContentSelectors:["*"],decls:2,vars:1,consts:[["ngFor","",3,"ngForOf"],["class","as-split-gutter",3,"flex-basis","order","mousedown","touchstart","mouseup","touchend",4,"ngIf"],[1,"as-split-gutter",3,"mousedown","touchstart","mouseup","touchend"],["gutterEls",""],[1,"as-split-gutter-icon"]],template:function(e,n){1&e&&(l.ld(),l.kd(0),l.zd(1,we,1,1,"ng-template",0)),2&e&&(l.Ec(1),l.md("ngForOf",n.displayedAreas))},directives:[c.m,c.n],styles:['[_nghost-%COMP%]{display:flex;flex-wrap:nowrap;justify-content:flex-start;align-items:stretch;overflow:hidden;width:100%;height:100%}[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]{flex-grow:0;flex-shrink:0;background-color:#eee;display:flex;align-items:center;justify-content:center}[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%] > .as-split-gutter-icon[_ngcontent-%COMP%]{width:100%;height:100%;background-position:center center;background-repeat:no-repeat}[_nghost-%COMP%]    >.as-split-area{flex-grow:0;flex-shrink:0;overflow-x:hidden;overflow-y:auto}[_nghost-%COMP%]    >.as-split-area.as-hidden{flex:0 1 0px!important;overflow-x:hidden;overflow-y:hidden}.as-horizontal[_nghost-%COMP%]{flex-direction:row}.as-horizontal[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]{flex-direction:row;cursor:col-resize;height:100%}.as-horizontal[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%] > .as-split-gutter-icon[_ngcontent-%COMP%]{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAeCAYAAADkftS9AAAAIklEQVQoU2M4c+bMfxAGAgYYmwGrIIiDjrELjpo5aiZeMwF+yNnOs5KSvgAAAABJRU5ErkJggg==)}.as-horizontal[_nghost-%COMP%]    >.as-split-area{height:100%}.as-vertical[_nghost-%COMP%]{flex-direction:column}.as-vertical[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]{flex-direction:column;cursor:row-resize;width:100%}.as-vertical[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]   .as-split-gutter-icon[_ngcontent-%COMP%]{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAFCAMAAABl/6zIAAAABlBMVEUAAADMzMzIT8AyAAAAAXRSTlMAQObYZgAAABRJREFUeAFjYGRkwIMJSeMHlBkOABP7AEGzSuPKAAAAAElFTkSuQmCC)}.as-vertical[_nghost-%COMP%]    >.as-split-area{width:100%}.as-vertical[_nghost-%COMP%]    >.as-split-area.as-hidden{max-width:0}.as-disabled[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]{cursor:default}.as-disabled[_nghost-%COMP%] > .as-split-gutter[_ngcontent-%COMP%]   .as-split-gutter-icon[_ngcontent-%COMP%]{background-image:url("")}.as-transition.as-init[_nghost-%COMP%]:not(.as-dragging)    >.as-split-area, .as-transition.as-init[_nghost-%COMP%]:not(.as-dragging) > .as-split-gutter[_ngcontent-%COMP%]{transition:flex-basis .3s}'],changeDetection:0}),Ce.ctorParameters=function(){return[{type:l.S},{type:l.v},{type:l.k},{type:l.bb}]},Ce.propDecorators={direction:[{type:l.I}],unit:[{type:l.I}],gutterSize:[{type:l.I}],gutterStep:[{type:l.I}],restrictMove:[{type:l.I}],useTransition:[{type:l.I}],disabled:[{type:l.I}],dir:[{type:l.I}],gutterDblClickDuration:[{type:l.I}],dragStart:[{type:l.U}],dragEnd:[{type:l.U}],gutterClick:[{type:l.U}],gutterDblClick:[{type:l.U}],transitionEnd:[{type:l.U}],gutterEls:[{type:l.rb,args:["gutterEls"]}]};var Ie=function(){function e(n,o,s,i){t(this,e),this.ngZone=n,this.elRef=o,this.renderer=s,this.split=i,this._order=null,this._size=null,this._minSize=null,this._maxSize=null,this._lockSize=!1,this._visible=!0,this.lockListeners=[],this.renderer.addClass(this.elRef.nativeElement,"as-split-area")}return s(e,[{key:"order",get:function(){return this._order},set:function(e){this._order=ye(e,null),this.split.updateArea(this,!0,!1)}},{key:"size",get:function(){return this._size},set:function(e){this._size=ye(e,null),this.split.updateArea(this,!1,!0)}},{key:"minSize",get:function(){return this._minSize},set:function(e){this._minSize=ye(e,null),this.split.updateArea(this,!1,!0)}},{key:"maxSize",get:function(){return this._maxSize},set:function(e){this._maxSize=ye(e,null),this.split.updateArea(this,!1,!0)}},{key:"lockSize",get:function(){return this._lockSize},set:function(e){this._lockSize=ve(e),this.split.updateArea(this,!1,!0)}},{key:"visible",get:function(){return this._visible},set:function(e){this._visible=ve(e),this._visible?(this.split.showArea(this),this.renderer.removeClass(this.elRef.nativeElement,"as-hidden")):(this.split.hideArea(this),this.renderer.addClass(this.elRef.nativeElement,"as-hidden"))}},{key:"ngOnInit",value:function(){var e=this;this.split.addArea(this),this.ngZone.runOutsideAngular(function(){e.transitionListener=e.renderer.listen(e.elRef.nativeElement,"transitionend",function(n){"flex-basis"===n.propertyName&&e.split.notify("transitionEnd",-1)})})}},{key:"setStyleOrder",value:function(e){this.renderer.setStyle(this.elRef.nativeElement,"order",e)}},{key:"setStyleFlex",value:function(e,n,t,o,s){this.renderer.setStyle(this.elRef.nativeElement,"flex-grow",e),this.renderer.setStyle(this.elRef.nativeElement,"flex-shrink",n),this.renderer.setStyle(this.elRef.nativeElement,"flex-basis",t),!0===o?this.renderer.addClass(this.elRef.nativeElement,"as-min"):this.renderer.removeClass(this.elRef.nativeElement,"as-min"),!0===s?this.renderer.addClass(this.elRef.nativeElement,"as-max"):this.renderer.removeClass(this.elRef.nativeElement,"as-max")}},{key:"lockEvents",value:function(){var e=this;this.ngZone.runOutsideAngular(function(){e.lockListeners.push(e.renderer.listen(e.elRef.nativeElement,"selectstart",function(e){return!1})),e.lockListeners.push(e.renderer.listen(e.elRef.nativeElement,"dragstart",function(e){return!1}))})}},{key:"unlockEvents",value:function(){for(;this.lockListeners.length>0;){var e=this.lockListeners.pop();e&&e()}}},{key:"ngOnDestroy",value:function(){this.unlockEvents(),this.transitionListener&&this.transitionListener(),this.split.removeArea(this)}}]),e}();Ie.\u0275fac=function(e){return new(e||Ie)(l.Qc(l.S),l.Qc(l.v),l.Qc(l.bb),l.Qc(Ce))},Ie.\u0275dir=l.Lc({type:Ie,selectors:[["as-split-area"],["","as-split-area",""]],inputs:{order:"order",size:"size",minSize:"minSize",maxSize:"maxSize",lockSize:"lockSize",visible:"visible"},exportAs:["asSplitArea"]}),Ie.ctorParameters=function(){return[{type:l.S},{type:l.v},{type:l.bb},{type:Ce}]},Ie.propDecorators={order:[{type:l.I}],size:[{type:l.I}],minSize:[{type:l.I}],maxSize:[{type:l.I}],lockSize:[{type:l.I}],visible:[{type:l.I}]};var Te=function(){function e(){t(this,e)}return s(e,null,[{key:"forRoot",value:function(){return{ngModule:e,providers:[]}}},{key:"forChild",value:function(){return{ngModule:e,providers:[]}}}]),e}();Te.\u0275mod=l.Oc({type:Te}),Te.\u0275inj=l.Nc({factory:function(e){return new(e||Te)},imports:[[c.c]]}),("undefined"==typeof ngJitMode||ngJitMode)&&l.wd(Te,{declarations:function(){return[Ce,Ie]},imports:function(){return[c.c]},exports:function(){return[Ce,Ie]}});var _e=i("1NbL"),je=function(){function e(){t(this,e)}return s(e,[{key:"ngOnInit",value:function(){}}]),e}();je.ctorParameters=function(){return[]},je=Object(a.a)([Object(l.n)({selector:"app-divider",template:'<div class="wrapper">\n  <div class="divider div-transparent"></div>\n</div>\n',styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\n.wrapper {\n  padding-bottom: 4px;\n}\n.divider {\n  position: relative;\n  margin-top: 4px;\n  height: 1px;\n}\n.div-transparent:before {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 5%;\n  right: 5%;\n  width: 90%;\n  height: 1px;\n  background-image: linear-gradient(to right, transparent, var(--input-basic-border-color), transparent);\n}"]})],je);var Fe=i("WONP"),Pe=i("u47x"),Me=function(){function e(n,o){t(this,e),this.toolApiService=n,this.cdr=o,this.edit_mode=!1,this.form=new h.e({alias:new h.d("",[h.n.required,h.n.pattern("[a-z0-9]+(?:[._-]{1,2}[a-z0-9]+)*")]),name:new h.d("",[h.n.required]),description:new h.d("")})}return s(e,[{key:"ngOnInit",value:function(){var e=this;1==this.edit_mode&&this.toolApiService.getTool(this.tool_id).subscribe(function(n){var t=n.alias,o=n.name,s=n.description;e.form.get("alias").setValue(t),e.form.get("alias").disable(),e.form.get("name").setValue(o),e.form.get("description").setValue(s),e.cdr.markForCheck()})}},{key:"createTool",value:function(){var e=this;Object(f.a)(w.a).pipe(Object(y.a)(function(n){return 1==e.edit_mode?e.toolApiService.editTool(e.tool_id,e.form.value):e.toolApiService.createTool(e.form.value)}),Object(_.b)(function(e){return e}),Object(v.a)(function(n){e.close.next()})).subscribe()}}]),e}();Me.ctorParameters=function(){return[{type:C},{type:l.k}]},Me.propDecorators={close:[{type:l.I,args:["close"]}],edit_mode:[{type:l.I,args:["edit_mode"]}],tool_id:[{type:l.I,args:["tool_id"]}]},Me=Object(a.a)([Object(l.n)({selector:"app-tool-create",template:'<nb-card fxFill class="dialog">\n  <nb-card-header fxLayoutAlign="space-between center">\n\n    <div fxLayoutAlign="start center" fxLayout="row">\n\n      <button (click)="close.next(true)" shape="round" ghost status="basic" class="action" size="large" nbButton>\n        <nb-icon icon="arrow-back-outline">\n\n        </nb-icon>\n      </button>\n\n      <span class="subtitle text-hint lineV">\n        Create Tool\n      </span>\n\n    </div>\n\n    <button (click)="close.next(true)" shape="round" ghost status="basic" class="action" size="large" nbButton>\n      <nb-icon icon="info">\n\n      </nb-icon>\n    </button>\n\n\n  </nb-card-header>\n  <nb-card-body [formGroup]="form">\n    <div fxLayout="column" fxLayoutGap="1rem">\n\n\n      \x3c!-- --\x3e\n\n\n\n\n\n      \x3c!--  --\x3e\n      <div>\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Alias\n          </p>\n        </div>\n\n        <nb-form-field>\n          <nb-icon icon="at" nbPrefix></nb-icon>\n          <input cdkFocusInitial fieldSize="small" [status]="form.controls[\'alias\'].valid ? \'primary\' : \'basic\' "\n            formControlName="alias" fullWidth nbInput placeholder="Alias">\n\n        </nb-form-field>\n\n      </div>\n      <app-divider></app-divider>\n\n      <div s>\n        <div>\n          <p class="subtitle-2 text-hint">\n            Name\n          </p>\n        </div>\n\n\n        <nb-form-field>\n\n          <input fieldSize="small" [status]="form.controls[\'name\'].valid ? \'primary\' : \'basic\' " formControlName="name"\n            fullWidth nbInput placeholder="Name">\n        </nb-form-field>\n\n\n      </div>\n      <app-divider></app-divider>\n      <div>\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Description\n          </p>\n        </div>\n\n\n        <nb-form-field>\n\n          <textarea fieldSize="small" [status]="form.controls[\'description\'].valid ? \'primary\' : \'basic\' "\n            formControlName="description" style="resize: none;" fullWidth nbInput\n            placeholder="Description (Optional) "></textarea>\n        </nb-form-field>\n\n\n      </div>\n      <app-divider></app-divider>\n    </div>\n  </nb-card-body>\n\n\n  <nb-card-footer fxLayoutAlign="end" fxLayoutGap="1rem">\n    \x3c!-- <button hero status="basic" nbButton (click)="ref.close()">Go Back</button> --\x3e\n\n    <button fullWidth [disabled]="form.invalid" (click)="createTool()" filled status="success" nbButton>Save</button>\n  </nb-card-footer>\n</nb-card>\n',styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\nnb-card {\n  max-height: calc(100vh - 7rem);\n  margin: 0;\n}\nnb-card .container {\n  margin-top: 1rem;\n}\nnb-card textarea {\n  resize: none;\n}\n.label-text {\n  border-left: 2px var(--text-hint-color) solid !important;\n  margin-bottom: 1rem;\n  padding-left: 4px;\n}\n.subtitle {\n  margin: 0;\n  padding-left: 4px;\n}\nnb-card-header {\n  padding: 0.4rem;\n  box-shadow: 2px 2px 3px rgba(0, 0, 0, 0.16), 2px 2px 3px rgba(0, 0, 0, 0.23);\n}\nnb-card-footer {\n  padding: 0;\n}\nnb-card {\n  border: 0;\n}\n.buildBtn {\n  border-radius: 0;\n}"]})],Me);var ze=function(){function e(n,o,s,i,r){t(this,e),this.fb=n,this.toolApiService=o,this.cdr=s,this.drawerMngr=i,this.document=r,this.LOADING=!1,this.build_id="6023ed566c2cdfd6f2edb435",this.form=new h.e({id:new h.d(""),entrypoint:this.fb.array([new h.d({value:"",disabled:!0})]),cmd:this.fb.array([this.fb.control("/bin/cmd")]),args:this.fb.array([this.fb.control("hello"),this.fb.control("hello")]),substitute_var:new h.d(!0),variables:new h.b([]),success_endpoint:new h.d("http://success_endpoint.com/usr/bin/mobsf"),failure_endpoint:new h.d(""),config:new h.e({process:new h.b([]),reserved:new h.b([]),_reserved:new h.e({}),system:new h.b([]),_process:new h.e({input_api:new h.d(""),input_api_token:new h.d(""),output_api:new h.d(""),file_upload_api:new h.d("")}),_system:new h.e({base_path:new h.d(""),input_dir:new h.d(""),output_dir:new h.d(""),results_json:new h.d(""),results_schema:new h.d(""),log_to_file:new h.d(!0),stdout_file:new h.d(""),stderr_file:new h.d(""),enable_logging:new h.d(!0),max_output_filesize:new h.d(1e3),sample_inputfile:new h.d(""),sample_outputfile:new h.d("")})})})}return s(e,[{key:"getArgs",value:function(){return this.form.get("args")}},{key:"deleteArg",value:function(e){this.getArgs().removeAt(e)}},{key:"getVariables",value:function(){return this.form.get("variables")}},{key:"getConfProcess",value:function(){return this.form.get("config").get("process")}},{key:"getConfSystem",value:function(){return this.form.get("config").get("system")}},{key:"getConfReserved",value:function(){return this.form.get("config").get("reserved")}},{key:"deleteVariables",value:function(e){this.getVariables().removeAt(e)}},{key:"deleteConfProcess",value:function(e){this.getConfProcess().removeAt(e)}},{key:"deleteConfSystem",value:function(e){this.getConfSystem().removeAt(e)}},{key:"deleteConfReserved",value:function(e){this.getConfReserved().removeAt(e)}},{key:"ngOnInit",value:function(){this.loadConfig()}},{key:"addArg",value:function(){this.getArgs().push(this.fb.control(""))}},{key:"addVar",value:function(){this.getVariables().push(new h.e({key:new h.d(""),value:new h.d("")}))}},{key:"addConfProcess",value:function(){this.getConfProcess().push(new h.e({key:new h.d(""),value:new h.d("")}))}},{key:"addSystemProcess",value:function(){this.getConfSystem().push(new h.e({key:new h.d(""),value:new h.d("")}))}},{key:"addReservedProcess",value:function(){this.getConfReserved().push(new h.e({key:new h.d(""),value:new h.d("")}))}},{key:"formToJson",value:function(){var e=this.form.getRawValue(),n={};e.variables.forEach(function(e){n[e.key]=e.value}),e.variables=n;var t={process:{},reserved:{},system:{}};return e.config.process.forEach(function(e){t.process[e.key]=e.value}),e.config.reserved.forEach(function(e){t.reserved[e.key]=e.value}),e.config.system.forEach(function(e){t.system[e.key]=e.value}),delete e._process,delete e._reserved,delete e._system,e.config=t,e}},{key:"save",value:function(){this.toolApiService.updateBuildConfig(this.build_id,this.formToJson()).subscribe(function(e){})}},{key:"loadConfig",value:function(){var e=this;this.LOADING=!0,Object(f.a)(this.config).subscribe(function(n){if(console.log("config",n),n||(n={}),n.id&&e.form.setControl("id",e.fb.control(n.id)),n.cmd){var t=[];n.cmd.forEach(function(n){t.push(e.fb.control(n))}),e.form.setControl("cmd",e.fb.array(t))}if(n.entrypoint){var o=e.fb.array([]);n.entrypoint.forEach(function(n){o.push(e.fb.control({value:n,disabled:!0}))}),e.form.setControl("entrypoint",o)}if(n.entrypoint){var s=[];n.args.forEach(function(n){s.push(e.fb.control(n))}),e.form.setControl("args",e.fb.array(s))}if(n.substitute_var&&e.form.setControl("substitute_var",e.fb.control(n.substitute_var)),n.success_endpoint&&e.form.setControl("success_endpoint",e.fb.control(n.success_endpoint)),n.failure_endpoint&&e.form.setControl("failure_endpoint",e.fb.control(n.failure_endpoint)),n.config){var i=[],r=[],a=[];n.config.process&&Object.keys(n.config.process).forEach(function(t){i.push(e.fb.group({key:e.fb.control(t),value:e.fb.control(n.config.process[t])}))}),n.config.system&&Object.keys(n.config.system).forEach(function(t){r.push(e.fb.group({key:e.fb.control(t),value:e.fb.control(n.config.system[t])}))}),n.config.reserved&&Object.keys(n.config.reserved).forEach(function(t){a.push(e.fb.group({key:e.fb.control({value:t,disabled:!0}),value:e.fb.control({value:n.config.reserved[t],disabled:!0})}))});var l=e.fb.group({process:e.fb.array(i),reserved:e.fb.array(a),system:e.fb.array(r)});e.form.setControl("config",l)}e.LOADING=!1,e.cdr.markForCheck()})}},{key:"run",value:function(){var e=this;this.toolApiService.execJob(this.id,this.formToJson()).subscribe(function(n){var t=n._id;e.openLogs(e.logsTemplate,t)})}},{key:"openLogs",value:function(e,n){var t=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:P.a.Left,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"50%",i=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],r=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],a=arguments.length>6?arguments[6]:void 0;this.document.body.classList.add("cdk-global-scrollblock"),this.drawerMngr.create({direction:o,template:e,size:s,closeOnOutsideClick:i,parentContainer:a,isRoot:r,zIndex:1e3,cssClass:"backdrop_color",context:{id:n}}).onDestroy(function(){t.document.body.classList.remove("cdk-global-scrollblock")})}}]),e}();ze.ctorParameters=function(){return[{type:h.c},{type:C},{type:l.k},{type:M.a},{type:Document,decorators:[{type:l.D,args:[c.d]}]}]},ze.propDecorators={logsTemplate:[{type:l.qb,args:["logsTemplate",{static:!1}]}],id:[{type:l.I,args:["id"]}],config:[{type:l.I,args:["config"]}],close:[{type:l.I,args:["close"]}],refrence_id:[{type:l.I,args:["refrence_id"]}],build_id:[{type:l.I,args:["build_id"]}]},ze=Object(a.a)([Object(l.n)({selector:"app-job-config",template:'<ng-container *ngIf=" LOADING == false ; else loading">\n\n\n\n  <nb-card fxFill [formGroup]="form">\n\n\n    <nb-card-header fxLayoutAlign="space-between center">\n\n      <div fxLayoutAlign="start center" fxLayout="row">\n\n        <button (click)="close.next(true)" shape="round" ghost status="basic" class="action" size="large" nbButton>\n          <nb-icon icon="arrow-back-outline">\n\n          </nb-icon>\n        </button>\n\n        <span class="subtitle text-hint lineV">\n          Job Executor\n        </span>\n\n      </div>\n\n      <button (click)="close.next(true)" shape="round" ghost status="basic" class="action" size="large" nbButton>\n        <nb-icon icon="info">\n\n        </nb-icon>\n      </button>\n\n\n    </nb-card-header>\n\n    <nb-card-body>\n\n\n\n\n\n      <div fxLayoutAlign="space-between center" fxLayout="row" fxLayoutGap="1rem">\n        <p class="subtitle text-basic">\n          Job Configuration\n        </p>\n\n        <button shape="round" ghost nbButton>\n          <nb-icon icon="info"></nb-icon>\n        </button>\n      </div>\n      <app-divider></app-divider>\n\n\n\n      \x3c!-- Entrypoint --\x3e\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Entrypoint\n          </p>\n        </div>\n\n\n        <ng-container formArrayName="entrypoint">\n\n          <ng-container *ngFor="let entrypoint of this.form.get(\'entrypoint\').controls ; let i=index ">\n\n            <div fxLayout="row" fxLayoutGap="1rem">\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth [formControlName]="i" nbInput placeholder="/bin/watchdog">\n              </nb-form-field>\n            </div>\n\n          </ng-container>\n        </ng-container>\n\n      </div>\n\n      <app-divider></app-divider>\n\n      \x3c!-- Command --\x3e\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Command\n          </p>\n        </div>\n\n        <div fxFlex>\n\n\n          <ng-container formArrayName="cmd">\n\n            <ng-container *ngFor="let _cmd of this.form.get(\'cmd\').controls ; let i=index ">\n\n\n              <div [style.marginBottom]="\'0.5rem\'" fxLayout="row" fxLayoutGap="1rem">\n\n                <div fxLayout="row" fxLayoutGap="1rem">\n                  <nb-form-field fxFlex fieldSize="small">\n                    <input fullWidth cdkFocusInitial [formControlName]="i" nbInput placeholder="/usr/bin/mobsf">\n                  </nb-form-field>\n                </div>\n\n\n\n\n              </div>\n\n\n            </ng-container>\n\n\n          </ng-container>\n\n        </div>\n\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Arguments --\x3e\n      <div fxLayout="column">\n\n        <div fxLayout="row">\n          <p fxFlex class="subtitle-2 text-hint">\n            Arguments\n          </p>\n\n          <button (click)="addArg()" ghost nbButton status="danger">\n            Add\n          </button>\n\n        </div>\n\n\n        <div fxFlex>\n\n          <ng-container formArrayName="args">\n\n            <ng-container *ngFor="let arg of this.form.get(\'args\').controls ; let i=index ">\n\n\n              <div [style.marginBottom]="\'0.5rem\'" fxLayout="row" fxLayoutGap="1rem">\n                <nb-form-field fxFlex fieldSize="small">\n\n\n                  <input fullWidth [formControlName]="i" nbInput placeholder="/usr/bin/mobsf">\n\n\n                </nb-form-field>\n\n\n                <button ghost nbSuffix nbButton (click)="deleteArg(i)">\n                  <nb-icon icon="trash-outline">\n                  </nb-icon>\n                </button>\n\n              </div>\n\n\n            </ng-container>\n\n\n          </ng-container>\n        </div>\n\n        <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'args\').controls.length" fxFlex>\n          <p class="subtitle-2 text-hint">\n            No Arguments Defined\n          </p>\n        </div>\n\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Variables --\x3e\n      <div fxLayout="column">\n\n        <div fxLayout="row">\n          <p fxFlex class="subtitle-2 text-hint">\n            Variables\n          </p>\n\n\n\n          <button (click)="addVar()" ghost nbButton status="danger">\n            Add\n          </button>\n\n\n        </div>\n\n\n        <ng-container formArrayName="variables">\n\n          <ng-container *ngFor="let variable of this.form.get(\'variables\').controls ; let i=index ">\n\n            <div [style.marginBottom]="\'0.5rem\'" [formGroupName]="i" fxLayout="row" fxLayoutGap="1rem">\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <span nbPrefix>$</span>\n\n                <input fullWidth formControlName="key" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n\n\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="value" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n              <button ghost nbButton (click)="deleteVariables(i)">\n                <nb-icon icon="trash-outline">\n                </nb-icon>\n              </button>\n\n\n\n\n            </div>\n\n\n          </ng-container>\n\n\n        </ng-container>\n\n\n        <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'variables\').controls.length" fxFlex>\n          <p class="subtitle-2 text-hint">\n            No Variables Defined\n          </p>\n        </div>\n\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Substitute Variables --\x3e\n      <div fxLayout="column">\n\n\n\n\n        <div fxLayout="row">\n          <p fxFlex class="subtitle-2 text-hint">\n            Substitute Variables\n\n          </p>\n\n\n\n\n          <nb-toggle formControlName="substitute_var"></nb-toggle>\n\n\n\n        </div>\n\n        \x3c!--  --\x3e\n   \n  \n      </div>\n\n\n      <app-divider></app-divider>\n\n\n\n\n      \x3c!-- success_endpoint --\x3e\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Success Endpoint\n          </p>\n        </div>\n\n        <div fxLayout="row" fxLayoutGap="1rem">\n          <nb-form-field fxFlex fieldSize="small">\n            <input fullWidth formControlName="success_endpoint" nbInput\n              placeholder="http://success_endpoint.com/usr/bin/mobsf">\n          </nb-form-field>\n        </div>\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- failure_endpoint --\x3e\n      <div fxLayout="column">\n\n        <div>\n          <p class="subtitle-2 text-hint">\n            Failure Endpoint\n          </p>\n        </div>\n\n        <div fxLayout="row" fxLayoutGap="1rem">\n          <nb-form-field fxFlex fieldSize="small">\n            <input fullWidth formControlName="failure_endpoint" nbInput\n              placeholder="http://failure_endpoint.com/usr/bin/mobsf">\n          </nb-form-field>\n        </div>\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Process Env. Variables --\x3e\n      <div fxLayout="column" formGroupName="config">\n\n        <div fxLayout="row">\n          <p fxFlex class="subtitle-2 text-hint">\n            Environment Variables\n          </p>\n\n\n\n          <button (click)="addConfProcess()" ghost nbButton status="danger">\n            Add\n          </button>\n\n\n        </div>\n\n\n        <ng-container formArrayName="process">\n\n          <ng-container *ngFor="let variable of this.form.get(\'config\').get(\'process\').controls ; let i=index ">\n\n            <div [style.marginBottom]="\'0.5rem\'" [formGroupName]="i" fxLayout="row" fxLayoutGap="1rem">\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <span nbPrefix>$</span>\n\n                <input fullWidth formControlName="key" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n\n\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="value" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n              <button ghost nbButton (click)="deleteConfProcess(i)">\n                <nb-icon icon="trash-outline">\n                </nb-icon>\n              </button>\n\n\n\n\n            </div>\n\n\n          </ng-container>\n\n\n        </ng-container>\n\n\n        <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'config\').get(\'process\').controls .length"\n          fxFlex>\n          <p class="subtitle-2 text-hint">\n            No Environment Variables Defined\n          </p>\n        </div>\n\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Reserved Env. Variables --\x3e\n      <div fxLayout="column" formGroupName="config">\n\n        <div fxLayout="row">\n          <p fxFlex class="subtitle-2 text-hint">\n            Reserved Environment Variables\n          </p>\n\n\n\n          <button (click)="addReservedProcess()" ghost nbButton status="danger">\n            Add\n          </button>\n\n\n        </div>\n\n\n        <ng-container formArrayName="reserved">\n\n          <ng-container *ngFor="let variable of this.form.get(\'config\').get(\'reserved\').controls ; let i=index ">\n\n            <div [style.marginBottom]="\'0.5rem\'" [formGroupName]="i" fxLayout="row" fxLayoutGap="1rem">\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <span nbPrefix>$</span>\n\n                <input fullWidth formControlName="key" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n\n\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="value" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n              <button ghost nbButton (click)="deleteConfReserved(i)">\n                <nb-icon icon="trash-outline">\n                </nb-icon>\n              </button>\n\n\n\n\n            </div>\n\n\n          </ng-container>\n\n\n        </ng-container>\n\n        <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'config\').get(\'reserved\').controls .length"\n          fxFlex>\n          <p class="subtitle-2 text-hint">\n            No Reserved Variables Defined\n          </p>\n        </div>\n      </div>\n\n      <app-divider></app-divider>\n\n\n      \x3c!-- Systen Env. Variables --\x3e\n      <div fxLayout="column" formGroupName="config">\n\n        <div fxLayout="row">\n          <p fxFlex class="subtitle-2 text-hint">\n            Systen Environment Variables\n          </p>\n\n\n\n          <button (click)="addSystemProcess()" ghost nbButton status="danger">\n            Add\n          </button>\n\n\n        </div>\n\n\n        <ng-container formArrayName="system">\n\n          <ng-container *ngFor="let variable of this.form.get(\'config\').get(\'system\').controls ; let i=index ">\n\n            <div [style.marginBottom]="\'0.5rem\'" [formGroupName]="i" fxLayout="row" fxLayoutGap="1rem">\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <span nbPrefix>$</span>\n\n                <input fullWidth formControlName="key" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n\n\n\n\n              <nb-form-field fxFlex fieldSize="small">\n                <input fullWidth formControlName="value" nbInput placeholder="/usr/bin/mobsf">\n              </nb-form-field>\n\n\n              <button ghost nbButton (click)="deleteConfSystem(i)">\n                <nb-icon icon="trash-outline">\n                </nb-icon>\n              </button>\n\n\n\n\n            </div>\n\n\n          </ng-container>\n\n\n        </ng-container>\n\n        <div fxFlex fxLayoutAlign="center center" *ngIf="!this.form.get(\'config\').get(\'system\').controls .length"\n          fxFlex>\n          <p class="subtitle-2 text-hint">\n            No System Variables Defined\n          </p>\n        </div>\n      </div>\n\n      <app-divider></app-divider>\n\n    </nb-card-body>\n\n\n    <nb-card-footer (click)="run()">\n\n      <button class="buildBtn" fxLayoutAlign="space-between center" size="giant" status="danger" filled fullWidth\n        nbButton>\n\n        <span>\n          Run\n\n        </span>\n        <nb-icon icon="play-circle"></nb-icon>\n\n      </button>\n    </nb-card-footer>\n\n  </nb-card>\n\n\n\n\n\n</ng-container>\n\n<ng-template #loading>\n  <div fxLayoutAlign="center center">\n    <ngx-progress-spinner></ngx-progress-spinner>\n  </div>\n\n</ng-template>\n\n<ng-template #logsTemplate let-close="close" let-context="context">\n\n  <app-log-stream  [close]="close" [deep_link]="true" [log_id]="context?.id"></app-log-stream>\n\n\n</ng-template>\n',styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\nnb-card {\n  max-height: calc(100vh - 7rem);\n  margin: 0;\n}\nnb-card .container {\n  margin-top: 1rem;\n}\nnb-card textarea {\n  resize: none;\n}\n.label-text {\n  border-left: 2px var(--text-hint-color) solid !important;\n  margin-bottom: 1rem;\n  padding-left: 4px;\n}\n.subtitle {\n  margin: 0;\n  padding-left: 4px;\n}\nnb-card-header {\n  padding: 0.4rem;\n  box-shadow: 2px 2px 3px rgba(0, 0, 0, 0.16), 2px 2px 3px rgba(0, 0, 0, 0.23);\n}\nnb-card-footer {\n  padding: 0;\n}\nnb-card {\n  border: 0;\n}\n.buildBtn {\n  border-radius: 0;\n}"]})],ze);var Be=function e(){t(this,e)};Be=Object(a.a)([Object(l.N)({declarations:[ee,le,de.a,U,he,ue,te,F,D,je,I,Me,W,E,J,ze,Y],imports:[_e.a,Z.p,ie.a,c.c,se,Z.n,re.a,Z.z.forRoot(),Z.E.forRoot({name:"default"}),ae.a,Z.i.forChild(),Z.e,h.f,ce,Z.q,Z.f,Z.b,Z.a,Te,Z.o,Z.l,Z.c,h.m,Z.i.forChild(),Z.y,Z.q,Z.A,Z.g,Fe.a,Z.C,Z.w,re.a,Pe.a,u.c,ae.a,N.b,Z.G,Z.d,Z.D,Z.u,Z.h,Z.d,Z.x],providers:[C,B]})],Be)}}])}();