(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{"8msR":function(e,n,t){"use strict";t.r(n),t.d(n,"JobManagementModule",function(){return ge});var o=t("mrSG"),s=t("fXoL"),i=t("ofXK"),r=t("tyNb");let l=class{constructor(){}ngOnInit(){}};l.ctorParameters=()=>[],l=Object(o.a)([Object(s.n)({selector:"app-job-bootstrap",template:"<router-outlet>\n\n</router-outlet>\n",styles:[""]})],l);var a=t("SDw7"),c=t("ZfaG"),p=t("2Vo4"),h=t("lJxs"),d=t("pLZG"),b=t("vkgz"),x=t("/uUt"),u=t("UXun"),m=t("5+tZ"),w=t("SxV6"),g=t("tk/3"),f=t("XNiG"),y=t("l5mm"),v=t("NXyV"),k=t("LRne"),L=t("EY2u"),A=t("coGc"),S=t("eIep"),R=t("FQpF"),T=t("7qw2");const I=T.a+"api/v2",C=T.c+"api/v2/";var j,M;!function(e){e[e.PAUSE=0]="PAUSE",e[e.RESUME=1]="RESUME",e[e.START=2]="START",e[e.STOP=3]="STOP"}(j||(j={})),function(e){e.IMAGE_BUILDER="image_builder",e.JOB="job"}(M||(M={}));let F=class{constructor(e){this.http=e}getJobStatus(e){return this.http.get(`${I}/job/status/${e}`)}getJob(e){return this.http.get(`${I}/job/${e}`)}getJobs(e){return this.http.get(`${I}/jobs/${e}`)}getAllJobs(){return this.http.get(I+"/jobs")}getBuildExecutorStatus(e){return this.http.get(`${I}/build/executors/status/${e}`)}getLogs(e,n,t,o){let s,i=0,r=-1,l=new f.a,a=0;return Object(v.a)(()=>(t.pipe().subscribe(t=>{let c=Object(k.a)(L.a).pipe(Object(A.a)(()=>(()=>{let e=Object(y.a)(a);return a=o,e})()),Object(S.a)(t=>{let o=new g.e({"X-Id":e,"X-Lines":n.toString(),"X-Seek":i+""});return this.http.get(C+"/tool/host",{headers:o,observe:"response",responseType:"text"}).pipe(Object(b.a)(e=>{let n=e.headers.get("X-File-Range"),t=e.headers.get("X-File-Size");if(null==n||null==t)return;let o=n.split("-")[1];i=parseInt(o),r=parseInt(t)}),Object(h.a)(e=>""+e.body))}));if(t==j.RESUME)s&&s.unsubscribe(),s=c.pipe(Object(R.a)(e=>c)).subscribe(e=>{l.next(e)});else if(t==j.PAUSE)s&&(s.unsubscribe(),s=void 0);else if(t==j.STOP)return console.log("stopped"),l.complete(),void s.unsubscribe()}),l))}getTool(e){return this.http.get(`${I}/tool/${e}`)}getTools(){return this.http.get(I+"/tool")}};F.ctorParameters=()=>[{type:g.b}],F=Object(o.a)([Object(s.F)({providedIn:"root"})],F);const O=Object(h.a)(e=>{if(Array.isArray(e))e.forEach((n,t)=>{let o="basic";switch(n.exec_status){case"FAILURE":case"TIMEOUT":o="danger";break;case"SUCCESS":case"COMPLETED":o="success";break;case"ENQUEUED":case"INITIATED":o="primary";break;case"UNKNOWN":o="basic"}n._status=o,e[t]=n});else{let n="basic";switch(e.exec_status){case"FAILURE":case"TIMEOUT":n="danger";break;case"SUCCESS":case"COMPLETED":n="success";break;case"ENQUEUED":case"INITIATED":n="primary";break;case"UNKNOWN":n="basic"}e._status=n}return e});var P,_;!function(e){e.OPEN="opened",e.CLOSED="closed"}(P||(P={})),function(e){e.REQUEST="request",e.RESULT="result",e.LOG="logs",e.UNDEFINED=""}(_||(_={}));let B=class{constructor(e){this.jobApiService=e,this.toolSidePannelState=new p.a(!0),this.mainContainerActiveTab=new p.a(_.UNDEFINED),this.MainContainerActiveTab=this.mainContainerActiveTab.asObservable().pipe(Object(d.a)(e=>e!==_.UNDEFINED)),this.selectedJob=new p.a(void 0),this.selectedJobId=new p.a(void 0),this.SelectedJobId=this.selectedJobId.pipe(Object(b.a)(e=>{console.log("selectedJobs",e),null!=e&&this.selectedJob.next(this.jobApiService.getJob(e))}),Object(x.a)(),Object(u.a)()),this.SelectedJob=this.selectedJob.asObservable().pipe(Object(d.a)(e=>!!e),Object(m.b)(e=>e)),console.log("constructir","dadsa")}toggle(){this.toolSidePannelState.pipe(Object(w.a)(),Object(b.a)(e=>{this.toolSidePannelState.next(!e)})).subscribe().unsubscribe()}};B.ctorParameters=()=>[{type:F}],B=Object(o.a)([Object(s.F)({providedIn:"root"})],B);let W=class{constructor(e,n,t){this.stateSyncService=e,this.route=n,this.router=t,this.direction=a.a.Left,this.slideState=this.stateSyncService.toolSidePannelState.asObservable(),this.SelectedJobId=this.stateSyncService.SelectedJobId,this.tabs=[{title:"Jobs",route:[{outlets:{view:["job"]}}]},{title:"Result",route:[{outlets:{view:["result"]}}]},{title:"Deployments",route:["/tools"]}]}ngOnInit(){this.SelectedJobId.subscribe(e=>{console.log("loffer",e),e?this.stateSyncService.toolSidePannelState.next(!1):this.stateSyncService.toolSidePannelState.next(!0)}),this.route.paramMap.subscribe(e=>{if(e.has("jobid")){let n=e.get("jobid");console.log("selectedJobs_push",n),this.stateSyncService.selectedJobId.next(n)}else console.log("selectedJobs_push"),this.stateSyncService.selectedJobId.next(void 0)})}toggle(){this.stateSyncService.toggle()}goToToolsSelection(){console.log("route",this.route),this.router.navigate([{outlets:{tool_list:["tools"]}}],{relativeTo:this.route})}};W.ctorParameters=()=>[{type:B},{type:r.a},{type:r.f}],W.propDecorators={direction:[{type:s.I}]},W=Object(o.a)([Object(s.n)({selector:"app-job-home",template:'<nb-layout>\n\n\n  <nb-layout-header>\n\n    <div class="header" fxFlex fxLayoutAlign="space-between">\n\n\n      <div fxLayout="row">\n\n        <button shape="round" [routerLink]="[\'/tools\' ]" ghost status="basic" class="action" size="large" nbButton>\n          <nb-icon icon="arrow-back-outline">\n\n          </nb-icon>\n        </button>\n\n        <nb-route-tabset [activeLinkOptions]="{exact:\n        false}" [tabs]="tabs"></nb-route-tabset>\n\n      </div>\n\n\n    </div>\n\n\n\n  </nb-layout-header>\n\n\n\n  <nb-layout-column\n  fxLayoutGap="1rem"\n  >\n\n    <div id="side" fxFlex.gt-xs="1 1 400px" fxFlex @openClose [fxShow]="true" [fxShow.lt-md]="slideState | async">\n\n      \x3c!-- <nb-card fxFill>\n        <nb-card-header fxLayoutAlign="start center">\n          <button (click)="goToToolsSelection()" ghost status="primary" shape="round" class="title" nbButton\n            size="medium">\n            nmap\n          </button>\n          <nb-icon icon="chevron-right-outline"></nb-icon>\n          <button ghost shape="round" class="title" nbButton size="medium">\n            {{SelectedJobId | async}}\n          </button>\n\n        </nb-card-header>\n\n        <nb-card-body> --\x3e\n      <router-outlet name="tool_list">\n      </router-outlet>\n      \x3c!-- </nb-card-body>\n      </nb-card> --\x3e\n\n\n\n\n    </div>\n\n    <div id="main" [fxHide.lt-sm]="slideState | async" @openClose fxFlex>\n\n      <router-outlet name="view">\n\n      </router-outlet>\n    </div>\n\n\n\n\n\n\n\n  </nb-layout-column>\n\n\n\n</nb-layout>\n',animations:[...c.a],styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\n.list {\n  max-height: calc(100vh - 4rem);\n  overflow: scroll;\n}\nnb-layout-column {\n  max-height: calc(100vh - 4rem);\n}\n.ngx-drawer {\n  display: block;\n  overflow-y: auto;\n  overflow-x: hidden;\n  text-align: left;\n  z-index: 998;\n  min-width: 50%;\n  width: 50%;\n}\n.ngx-drawer.left-drawer {\n  top: 4rem;\n  right: 0;\n  height: 100%;\n}\n.ngx-drawer.bottom-drawer {\n  left: 0;\n  bottom: 0;\n  width: 100%;\n  max-height: calc(100vh - 4rem);\n}\n.ngx-drawer .ngx-drawer-content {\n  height: calc(100% - 4rem);\n  overflow: auto;\n}\n:host ::ng-deep nb-layout-header nav {\n  flex: 1 !important;\n}\nbutton.newBtn {\n  padding: 0.3rem !important;\n  padding-left: 1rem !important;\n  padding-right: 1rem !important;\n  text-transform: capitalize !important;\n  box-shadow: 0 1px 2px 0 rgba(60, 64, 67, 0.302), 0 1px 3px 1px rgba(60, 64, 67, 0.149) !important;\n  align-items: center !important;\n  background-color: #fff !important;\n  border: 1px solid transparent;\n  border-radius: 24px;\n  color: #3c4043 !important;\n}\nbutton.newBtn span {\n  margin-right: 1rem;\n  margin-top: 0.5rem;\n  margin-bottom: 0.5rem;\n  font-weight: 600;\n}\nbutton.newBtn .icon {\n  margin-right: 1rem;\n  background-image: url(\"data:image/svg+xml;charset=UTF-8,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2236%22 height=%2236%22 viewBox=%220 0 36 36%22%3E%3Cpath fill=%22%2334A853%22 d=%22M16 16v14h4V20z%22/%3E%3Cpath fill=%22%234285F4%22 d=%22M30 16H20l-4 4h14z%22/%3E%3Cpath fill=%22%23FBBC05%22 d=%22M6 16v4h10l4-4z%22/%3E%3Cpath fill=%22%23EA4335%22 d=%22M20 16V6h-4v14z%22/%3E%3Cpath fill=%22none%22 d=%22M0 0h36v36H0z%22/%3E%3C/svg%3E\");\n  width: 2rem !important;\n  height: 2rem !important;\n}\nbutton.newBtn:hover {\n  box-shadow: 0 3px 5px 0 rgba(60, 64, 67, 0.302), 0 3px 5px 1px rgba(60, 64, 67, 0.149) !important;\n  background-color: #fff !important;\n}\nnb-route-tabset {\n  overflow-x: scroll !important;\n  vertical-align: bottom;\n  padding-bottom: var(--layout-scrollbar-width);\n}\n.header {\n  overflow: hidden;\n}\n#main {\n  overflow: auto;\n}\nnb-card-header {\n  height: 4rem;\n}\nnb-card-body {\n  border: 0;\n  padding: 0rem;\n}"]})],W);var z=t("quSY"),D=t("3E0/"),E=t("/d8p"),$=t("1G5W");let J=class{constructor(e,n,t,o){this.jobApiService=e,this.cdr=n,this.stateSyncService=t,this.activatedRoute=o,this.tabs=[{title:"Request",route:[{outlets:{view:["logs"]}}],responsive:!0},{title:"Logs",route:[{outlets:{view:["logs"]}}],responsive:!0},{title:"Result",route:[{outlets:{view:["logs"]}}],responsive:!0},{title:"Settings",route:[{outlets:{view:["logs"]}}],responsive:!0},{title:"Scratchpad",route:[{outlets:{view:["logs"]}}],responsive:!0}],this.logSource=M.JOB,this.LOG_STREAM_STATUS$=j,this.testLogs="",this.deep_link=!1,this.topic=void 0,this.topics_=[],this.build_list=[],this.tailing=!0,this.streaming=!1,this.pollJobStatusSubscription$=z.a.EMPTY,this.scrollSubscruption=z.a.EMPTY}ngAfterViewInit(){this.toggleTail(this.tailing)}ngOnDestroy(){this.stateSyncService.mainContainerActiveTab.next(_.UNDEFINED),this.unsubscribeAll()}unsubscribeAll(){this.topic&&(this.topic.subscription.unsubscribe(),this.topic.pauseStreamer$.next(j.STOP)),this.pollJobStatusSubscription$.unsubscribe()}toggleTail(e){1==e?this.resumeKeepAtBottom():this.pauseKeepAtBottom()}toggleStreamingLogs(e,n){e?this.pause(n):this.resume(e)}getSource(e){switch(this.logSource){case M.IMAGE_BUILDER:return this.jobApiService.getBuildExecutorStatus(e);case M.JOB:return this.jobApiService.getJobStatus(e);default:return this.jobApiService.getBuildExecutorStatus(e)}}pollJobStatus(e){let n=new f.a;this.pollJobStatusSubscription$.unsubscribe(),this.pollJobStatusSubscription$=this.getSource(e).pipe(Object(b.a)(e=>{0==e.poll_again&&n.next(""),this.STATUS=e.exec_status}),Object(D.a)(1e3),Object(E.a)(),Object($.a)(n)).subscribe(e=>{})}ngOnInit(){this.stateSyncService.mainContainerActiveTab.next(_.LOG),this.stateSyncService.SelectedJobId.pipe(Object(d.a)(e=>!!e)).subscribe(e=>{this.log_id=e,console.log("logger",this.log_id),this.deepLinkLoadLog()})}deepLinkLoadLog(){this.unsubscribeAll(),this.topic={log_id:this.log_id,exec_status:"SUCCESS",title:"val['_id']",desc:"Dummy Description",loaded:!1,initiated:!1,collapsed:!0,loading:new f.a,content:[],content$:new f.a,pauseStreamer$:new p.a(j.RESUME),subscription:z.a.EMPTY},this.streamLogs(0,!0),this.pollJobStatus(this.topic.log_id)}scrollToBottom(){}resumeKeepAtBottom(){this.scrollSubscruption.unsubscribe(),this.scrollSubscruption=Object(y.a)(300).subscribe(e=>{})}pauseKeepAtBottom(){this.scrollSubscruption.unsubscribe()}streamLogs(e,n){this.topic&&this.topic.loaded||(this.topic.loading.next(!0),this.topic.subscription=this.jobApiService.getLogs(this.topic.log_id,200,this.topic.pauseStreamer$,T.d).pipe(Object(b.a)(e=>{this.topic.initiated=!0})).subscribe(e=>{this.topic.loaded=!0,this.topic.loading.next(!1),null!=e&&null!=e&&0!=e.length&&(this.topic.content.push(e),console.log("log loaded"),this.cdr.markForCheck())},e=>{console.log("error",e)},()=>{console.log("completed"),this.topic.pauseStreamer$.next(j.STOP),this.cdr.markForCheck()}))}getStatus(){}collapsedChange(e,n,t=!1){n||this.streamLogs(e,t)}onSelectionChange(e){this.topic&&(console.log("onSelectioChange",e),this.topic.subscription.unsubscribe(),this.topic.pauseStreamer$.next(j.STOP),this.topic.content$.complete()),this.topic={log_id:this.build_list[e].log_id,exec_status:this.build_list[e].exec_status,title:"val['_id']",desc:"Dummy Description",loaded:!1,initiated:!1,collapsed:!0,loading:new f.a,content:[],content$:new f.a,pauseStreamer$:new p.a(j.RESUME),subscription:z.a.EMPTY},this.streamLogs(e,!1),this.pollJobStatus(this.topic.log_id),console.log("this.topic",this.topic)}pause(e){this.topic.pauseStreamer$.next(j.PAUSE),this.cdr.markForCheck()}resume(e){this.topic.pauseStreamer$.next(j.RESUME),this.cdr.markForCheck()}toggle(){this.stateSyncService.toggle()}};J.ctorParameters=()=>[{type:F},{type:s.k},{type:B},{type:r.a}],J.propDecorators={logSource:[{type:s.I,args:["logsource"]}],close:[{type:s.I,args:["close"]}],deep_link:[{type:s.I,args:["deep_link"]}],log_id:[{type:s.I,args:["log_id"]}],scrollbarRef:[{type:s.qb,args:["ngScrollbar",{static:!1}]}]},J=Object(o.a)([Object(s.n)({selector:"app-job-logs",template:'<div class="container">\n\n  <div class="log-container">\n\n\n\n    \x3c!-- <div class="code"> --\x3e\n\n    <code *ngFor="let content of topic?.content">\n      <pre [innerText]="content"></pre>\n    </code>\n\n    \x3c!-- </div> --\x3e\n  </div>\n\n  \x3c!--  --\x3e\n\n  \x3c!-- <ng-scrollbar #ngScrollbar [style.pointerEvents]=" tailing ? \'none\' : \'all\' " track="all" [scrollAuditTime]="20">\n\n    <div class="log-container">\n      <code *ngFor="let content of topic?.content">\n        <pre [innerText]="content">   </pre>\n      </code>\n\n    </div>\n\n  </ng-scrollbar> --\x3e\n\n\n  \x3c!--  --\x3e\n  <div *ngIf=" topic?.content == undefined ||  topic?.content?.length < 1" class="progressBar">\n\n    <div fxLayoutAlign="center center">\n      <ngx-progress-spinner></ngx-progress-spinner>\n    </div>\n  </div>\n\n\n\n\n\n\n  <div class="overlay-button">\n\n    <ng-template #actionBtns let-status="pauseStatus">\n\n      <div class="row" fxFlex fxLayoutAlign="end center">\n\n\n        <nb-button-group style="margin-right: 1rem;" size="small" shape="round" multiple>\n\n          <button hero status="danger" (click)="toggleStreamingLogs($event)" nbButtonToggle size="small">\n            <nb-icon icon="pause-circle">\n            </nb-icon>\n\n            {{  ( status == LOG_STREAM_STATUS$.PAUSE   )  ? \'Resume\' : \'Pause\'  }}\n\n          </button>\n\n\n\n          <button [(pressed)]="tailing" (pressedChange)="toggleTail($event)" nbButtonToggle size="small">\n            <nb-icon icon="arrowhead-down-outline"></nb-icon>\n            Follow\n          </button>\n        </nb-button-group>\n      </div>\n    </ng-template>\n\n    <ng-container *ngTemplateOutlet="actionBtns; context:{pauseStatus: topic?.pauseStreamer$ | async }">\n    </ng-container>\n  </div>\n\n</div>\n',styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\n.subtitle {\n  color: #a4b1cd !important;\n  font-weight: 600;\n  line-height: 1rem;\n  font-size: 1rem;\n}\n.buildBtn {\n  border-radius: 0;\n}\n.log-container .ng-trigger-accordionItemBody {\n  margin-left: 1rem;\n  margin-right: 1rem;\n  margin-top: 0.5rem;\n  margin-bottom: 0.5rem;\n}\n.log-container pre {\n  margin: 0;\n  word-wrap: break-word;\n  white-space: initial;\n  -webkit-hyphens: auto;\n          hyphens: auto;\n  padding: 1rem;\n  font-weight: 600;\n  font-size: 1rem;\n  line-height: 1.8rem;\n  color: #9e9e9e;\n  color: var(--text-hint-color);\n}\n.container {\n  position: relative;\n}\n.overlay-button {\n  position: -webkit-sticky;\n  position: sticky;\n  bottom: 1rem;\n  right: 1rem;\n}\n.container {\n  border-bottom-left-radius: var(--card-border-radius);\n  border-bottom-right-radius: var(--card-border-radius);\n}\n:host ::ng-deep .ng-scroll-content {\n  display: block;\n}\n.head {\n  background: var(--background-alternative-color-2);\n  box-shadow: 2px 2px 3px rgba(255, 255, 255, 0.16), 2px 2px 3px rgba(255, 255, 255, 0.23);\n  color: #fff;\n}\n.action {\n  margin-left: 5px;\n}\n.action:hover nb-icon {\n  color: var(--color-alternate-500);\n}\n.code {\n  padding: 1rem;\n}\n.overflowFix {\n  overflow: auto;\n}\nnb-route-tabset {\n  overflow: scroll !important;\n  vertical-align: bottom;\n  padding-bottom: var(--layout-scrollbar-width);\n}\n.progressBar {\n  position: absolute;\n  top: calc(50% - 50px);\n  left: calc(50% - 50px);\n}"]})],J);var q=t("KPRU");let G=class{constructor(e,n,t,o){this.stateSyncService=e,this.document=n,this.drawerService=t,this.el=o,this.SelectedJob=this.stateSyncService.SelectedJob.pipe(Object(u.a)())}ngOnDestroy(){this.stateSyncService.mainContainerActiveTab.next(_.UNDEFINED)}ngOnInit(){this.stateSyncService.mainContainerActiveTab.next(_.REQUEST)}open(e){this.addIp(e)}addIp(e,n=a.a.Left,t=50,o=!0,s=!0,i){this.document.body.classList.add("cdk-global-scrollblock"),this.drawerService.create({direction:n,template:e,context:"Alert Everyone!",closeOnOutsideClick:!0,parentContainer:this.el.nativeElement,isRoot:!1,cssClass:"backdrop_color",zIndex:1041}).onDestroy(()=>{this.document.body.classList.remove("cdk-global-scrollblock")})}};G.ctorParameters=()=>[{type:B},{type:Document,decorators:[{type:s.D,args:[i.d]}]},{type:q.a},{type:s.v}],G=Object(o.a)([Object(s.n)({selector:"app-job-request",template:'<div>\n\n  <div class="h6 text-hint">\n    Entrypoint\n  </div>\n\n  <div class="subtitle text-hint">\n    {{ (SelectedJob | async)?.request?.job_config?.entrypoint}}\n  </div>\n\n</div>\n\n<div>\n\n  <div class="h6 text-hint">\n\n    Command\n  </div>\n\n  <div class="subtitle text-hint">\n\n    {{ (SelectedJob | async)?.request?.job_config?.cmd}}\n  </div>\n\n</div>\n\n<div>\n\n  <div class="h6 text-hint">\n\n    Arguments\n  </div>\n\n  <div class="subtitle text-hint">\n\n    {{ (SelectedJob | async)?.request?.job_config?.args.join(\' \')}}\n  </div>\n\n</div>\n\n<code>\n  <pre>{{ ( (SelectedJob | async)?.request | json ).trim() }}</pre>\n</code>\n\n\n<button status="success" size="small" nbButton>\n  Re Run\n</button>\n\n\n\n<button (click)="open(testTemplate)" status="success" size="small" nbButton>\n  Drawer\n</button>\n<ng-template #testTemplate>\n  <h1>Hello World</h1>\n</ng-template>\n',styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\npre {\n  margin: 0;\n  word-wrap: break-word;\n  white-space: break-spaces;\n  -webkit-hyphens: auto;\n          hyphens: auto;\n  padding: 1rem;\n  font-weight: 600;\n  font-size: 1rem;\n  line-height: 1.8rem;\n  color: #9e9e9e;\n  color: var(--text-hint-color);\n}"]})],G);let U=class{constructor(e){this.stateSyncService=e,this.SelectedJob=this.stateSyncService.SelectedJob}ngOnDestroy(){this.stateSyncService.mainContainerActiveTab.next(_.UNDEFINED)}ngOnInit(){this.stateSyncService.mainContainerActiveTab.next(_.RESULT)}};U.ctorParameters=()=>[{type:B}],U=Object(o.a)([Object(s.n)({selector:"app-job-result",template:"\n<code>\n  <pre>{{ ( (SelectedJob | async)?.response | json ).trim() }}</pre>\n</code>\n",styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\npre {\n  margin: 0;\n  word-wrap: break-word;\n  white-space: break-spaces;\n  -webkit-hyphens: auto;\n          hyphens: auto;\n  padding: 1rem;\n  font-weight: 600;\n  font-size: 1rem;\n  line-height: 1.8rem;\n  color: #9e9e9e;\n  color: var(--text-hint-color);\n}"]})],U);var N=t("3Pt+");let H=class{constructor(e,n,t,o){this.jobApiService=e,this.router=n,this.route=t,this.stateSyncService=o,this.tools=this.jobApiService.getTools(),this.selectedTool=new N.d(""),this.SelectedJobId=this.stateSyncService.SelectedJobId}ngOnInit(){this.stateSyncService.MainContainerActiveTab.subscribe(e=>{this.sub_comp_route=e}),this.route.paramMap.subscribe(e=>{let n=e.get("tool_id");console.log("tool_id",n),this.onToolSelectionChange(n),this.selectedTool.setValue(n)}),this.selectedTool.valueChanges.subscribe(e=>{this.onToolSelectionChange(e)})}onToolSelectionChange(e){this.jobs=e?this.jobApiService.getJobs(e).pipe(O):this.jobApiService.getAllJobs().pipe(O)}goToToolsSelection(){console.log("route",this.route.root)}onClick(e){this.router.navigate(["jobs","job",e,{outlets:{tool_list:["tool",this.selectedTool.value],view:["job",{outlets:{sub_comp:[this.sub_comp_route]}}]}}],{})}};H.ctorParameters=()=>[{type:F},{type:r.f},{type:r.a},{type:B}],H=Object(o.a)([Object(s.n)({selector:"app-job-selector",template:'<nb-card fxFill>\n\n\n  <nb-card-header fxLayoutAlign="start center">\n\n\n    <button (click)="goToToolsSelection()" ghost status="primary" shape="round" class="title" nbButton size="medium">\n      nmap\n    </button>\n    <nb-icon icon="chevron-right-outline"></nb-icon>\n    <button ghost shape="round" class="title" nbButton size="medium">\n      {{SelectedJobId | async}}\n    </button>\n\n  </nb-card-header>\n\n\n\n  <nb-list>\n    <nb-list-item *ngFor="let job of jobs | async">\n      \x3c!-- Hello World {{ job | json }} --\x3e\n      <app-list-item [selectedId]="SelectedJobId | async" (click)="onClick(job?._id)" fxFlex [data]="job">\n      </app-list-item>\n    </nb-list-item>\n  </nb-list>\n\n\n\n\n</nb-card>\n',styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\nnb-card-header {\n  height: 4rem;\n}\nnb-card-footer {\n  padding: 0.3rem;\n  border: 0em;\n}\nnb-list {\n  height: 100%;\n}\nnb-list-item {\n  border: none;\n}\nnb-card {\n  border: 0;\n  margin: 0;\n}\nnb-card-body {\n  border: 0;\n  padding: 0rem;\n}\n.head {\n  background: var(--background-alternative-color-2);\n  box-shadow: 2px 2px 3px rgba(255, 255, 255, 0.16), 2px 2px 3px rgba(255, 255, 255, 0.23);\n  color: #fff;\n}\nnb-list-item {\n  padding: 0;\n}"]})],H);let X=class{constructor(e,n,t){this.stateSyncService=e,this.router=n,this.route=t,this.tabs=[{title:"Request",route:[{outlets:{sub_comp:["request"]}}],responsive:!0},{title:"Result",route:[{outlets:{sub_comp:["result"]}}],responsive:!0},{title:"Logs",route:[{outlets:{sub_comp:["logs"]}}],responsive:!0}],this.slideState=this.stateSyncService.toolSidePannelState.asObservable(),this.SelectedJobId=this.stateSyncService.SelectedJobId,this.SelectedJob=this.stateSyncService.SelectedJob}ngOnInit(){}toggleJobSelector(){this.stateSyncService.toggle()}openToToolsSelection(e){let n={};n=null==e?{outlets:{tool_list:["tools"]}}:{outlets:{tool_list:["tool",e]}},this.router.navigate([n],{relativeTo:this.route.parent})}};X.ctorParameters=()=>[{type:B},{type:r.f},{type:r.a}],X=Object(o.a)([Object(s.n)({selector:"app-main-container",template:'<nb-card fxFill>\n\n\n  <nb-card-header fxLayoutAlign="start center">\n\n\n    <div fxFlex fxLayout="row">\n\n      <ng-template #rightBtnTemplate>\n        <button shape="round" (click)="toggleJobSelector()" outline class="action" size="medium" nbButton>\n\n          <nb-icon icon="chevron-right-outline">\n\n          </nb-icon>\n\n        </button>\n      </ng-template>\n\n\n\n      <app-selected-job></app-selected-job>\n\n\n\n\n    </div>\n\n    \x3c!--  --\x3e\n\n\n\n\n    <nb-route-tabset\n    \n    [fxHide.lt-md]="true" [fxShow]="true"\n    [tabs]="tabs"></nb-route-tabset>\n\n\n\n\n  </nb-card-header>\n\n  <nb-card-body fxFlex style="overflow: hidden; border: none;">\n\n\n    <router-outlet name="sub_comp"></router-outlet>\n\n    \x3c!-- <ngx-stepper position="0" [readonly]="false">\n      <ngx-step label="step.title" completeIcon="step.icon" active="1" trackBar="false" step="1">\n      </ngx-step>\n      <ngx-step progress="true" label="step.title" completeIcon="step.icon" step="2">\n      </ngx-step>\n      <ngx-step label="step.title" completeIcon="step.icon">\n      </ngx-step>\n    </ngx-stepper>\n --\x3e\n\n\n  </nb-card-body>\n\n  <nb-card-header [fxShow.lt-md]="true" [fxHide]="true">\n    <nb-route-tabset [tabs]="tabs"></nb-route-tabset>\n\n  </nb-card-header>\n\n\n</nb-card>\n',styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\nnb-card {\n  max-height: calc(100vh - 7rem);\n  margin: 0;\n}\nnb-card textarea {\n  resize: none;\n}\nnb-card-header {\n  padding: 0rem;\n  height: 4rem;\n}\nnb-card-footer {\n  padding: 0.3rem;\n  border: 0em;\n}\n.subtitle {\n  color: #a4b1cd !important;\n  font-weight: 600;\n  line-height: 1rem;\n  font-size: 1rem;\n}\nnb-card {\n  border: 0;\n}\nnb-card-body {\n  border: 0;\n  padding: 0rem;\n  overflow-y: scroll !important;\n}\n.buildBtn {\n  border-radius: 0;\n}\n.log-container {\n  background: var(--background-alternative-color-1);\n  color: var(--text-alternate-color);\n}\n.log-container .ng-trigger-accordionItemBody {\n  margin-left: 1rem;\n  margin-right: 1rem;\n  margin-top: 0.5rem;\n  margin-bottom: 0.5rem;\n}\n.log-container pre {\n  margin: 0;\n}\n.overlay-button {\n  position: -webkit-sticky;\n  position: sticky;\n  bottom: 1rem;\n  right: 1rem;\n}\n:host ::ng-deep nb-accordion nb-accordion-item nb-accordion-item-header:hover {\n  background: var(--background-alternative-color-1);\n  color: var(--text-alternate-color);\n}\n:host ::ng-deep nb-accordion nb-accordion-item nb-accordion-item-header.accordion-item-header-expanded {\n  background: var(--background-alternative-color-2);\n  color: var(--text-alternate-color);\n}\n:host ::ng-deep nb-accordion nb-accordion-item nb-accordion-item-body.marginBody {\n  overflow: scroll;\n  background: var(--background-alternative-color-1);\n  color: var(--text-alternate-color);\n}\n:host ::ng-deep nb-accordion nb-accordion-item nb-accordion-item-body.marginBody .ng-trigger-accordionItemBody {\n  margin-left: 1rem;\n  margin-right: 1rem;\n  margin-top: 0.5rem;\n  margin-bottom: 0.5rem;\n}\n:host ::ng-deep nb-accordion nb-accordion-item nb-accordion-item-body.marginBody pre {\n  margin: 0;\n}\n.head {\n  height: 4rem;\n  background: var(--background-alternative-color-2);\n  box-shadow: 2px 2px 3px rgba(255, 255, 255, 0.16), 2px 2px 3px rgba(255, 255, 255, 0.23);\n  color: #fff;\n}\n.action {\n  margin-left: -20px;\n}\n.action:hover nb-icon {\n  color: var(--color-alternate-500);\n}\n.code {\n  padding: 1rem;\n}\n.overflowFix {\n  overflow: auto;\n}\nnb-route-tabset {\n  overflow: scroll !important;\n  vertical-align: bottom;\n  padding-bottom: var(--layout-scrollbar-width);\n}\n#selectedJob {\n  max-width: 120px;\n  overflow: hidden;\n}"]})],X);let V=class{constructor(){}ngOnInit(){}};V.ctorParameters=()=>[],V=Object(o.a)([Object(s.n)({selector:"app-test",template:"<p>test works!</p>\n",styles:[""]})],V);let Y=class{constructor(e,n,t){this.jobApiService=e,this.route=n,this.router=t,this.tools=this.jobApiService.getTools()}ngOnInit(){}onSelectTool(e){console.log(e,this.route),this.router.navigate([{outlets:{tool_list:"tool/"+e._id}}],{relativeTo:this.route.parent})}closeToolSelection(){this.router.navigate([{outlets:{tool_list:null}}],{relativeTo:this.route.parent})}};Y.ctorParameters=()=>[{type:F},{type:r.a},{type:r.f}],Y=Object(o.a)([Object(s.n)({selector:"app-tool-selector",template:'<nb-card fxFill>\n  <nb-card-header fxLayoutAlign="start center">\n    \x3c!-- <button shape="round" [routerLink]="[\'/tools\' , \'\']" ghost status="basic" class="action" size="medium" nbButton>\n      <nb-icon icon="arrow-back-outline">\n      </nb-icon>\n    </button> --\x3e\n    <div class="subtitle-2">\n      Choose Tool\n    </div>\n\n\n    <button shape="round" (click)="closeToolSelection()" ghost status="basic" class="action" size="medium" nbButton>\n      <nb-icon icon="close-circle-outline">\n      </nb-icon>\n    </button>\n  </nb-card-header>\n\n\n\n  <nb-list>\n    <nb-list-item (click)="onSelectTool(tool)" *ngFor="let tool of tools | async">\n\n      <div class="container" fxLayoutAlign="center center" fxLayout="row">\n\n        <div fxLayoutAlign="start center">\n          <span class="dot text-primary">&#183;</span>\n        </div>\n\n        <div fxFlex fxLayout="column" fxLayoutAlign="space-between start">\n          <div fxFlex class="subtitle-2 ">\n            {{tool?.alias}}\n          </div>\n        </div>\n      </div>\n\n    </nb-list-item>\n  </nb-list>\n\n\n</nb-card>',styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\nnb-card-header {\n  height: 4rem;\n}\nnb-card {\n  border: 0;\n  margin: 0;\n}\n.dot {\n  font-size: 60px;\n  margin-right: 1rem;\n  margin-left: 0.3rem;\n}\nnb-list {\n  height: 100%;\n}\nnb-list-item {\n  padding-left: 0.8rem;\n  padding-right: 0.8rem;\n  padding-top: 0.4rem;\n  padding-bottom: 0.4rem;\n  margin-bottom: 2px;\n  background-color: var(--color-basic-100);\n  border-top-right-radius: 1.2rem;\n  border-bottom-right-radius: 1.2rem;\n  margin-right: 1rem;\n}\nnb-list-item:hover {\n  background-color: var(--color-basic-400);\n}\nnb-list-item.selected {\n  background-color: var(--color-success-200);\n  color: var(--navitem-selected-text);\n}"]})],Y);const K=[{path:"",component:l,children:[{component:W,path:"job/all",children:[{path:"",redirectTo:"tools",outlet:"tool_list"},{path:"tools",component:Y,outlet:"tool_list"},{path:"jobs",component:H,outlet:"tool_list"},{path:"test",component:V,outlet:"tool_list"},{path:"tool/:tool_id",component:H,outlet:"tool_list"},{path:"**",redirectTo:"tools",outlet:"tool_list"}]},{component:W,path:"job/:jobid",children:[{path:"",redirectTo:"job",outlet:"view"},{path:"job",component:X,outlet:"view",children:[{path:"",redirectTo:"request",outlet:"sub_comp"},{path:"request",component:G,outlet:"sub_comp"},{path:"logs",component:J,outlet:"sub_comp"},{path:"result",component:U,outlet:"sub_comp"},{path:"settings",component:J,outlet:"sub_comp"},{path:"scratchpad",component:J,outlet:"sub_comp"},{path:"**",redirectTo:"request",outlet:"sub_comp"}]},{path:"result",component:X,outlet:"view",children:[{path:"",component:J,outlet:"sub_comp"},{path:"request",component:G,outlet:"sub_comp"},{path:"logs",component:J,outlet:"sub_comp"},{path:"result",component:U,outlet:"sub_comp"},{path:"settings",component:J,outlet:"sub_comp"},{path:"scratchpad",component:J,outlet:"sub_comp"},{path:"**",component:J,outlet:"sub_comp"}]},{path:"settings",component:J,outlet:"view"},{path:"",redirectTo:"tools",outlet:"tool_list"},{path:"test",component:V,outlet:"tool_list"},{path:"tools",component:Y,outlet:"tool_list"},{path:"jobs",component:H,outlet:"tool_list"},{path:"tool/:tool_id",component:H,outlet:"tool_list"}]},{path:"**",redirectTo:"job/all",pathMatch:"full"}]}];let Q=class{};Q=Object(o.a)([Object(s.N)({imports:[r.j.forChild(K)],exports:[r.j]})],Q);var Z=t("aceb"),ee=t("YUcS"),ne=t("1NbL");let te=class{constructor(e){this.jobApiService=e,this.jobs=[]}ngOnInit(){this.getJobs()}getJobs(){this.jobApiService.getJobs("6040b3b797db9259f9ca741e").subscribe(e=>{this.jobs=e})}};te.ctorParameters=()=>[{type:F}],te=Object(o.a)([Object(s.n)({selector:"app-job-list",template:'<nb-list>\n\n\n  <nb-list-item *ngFor="let job of jobs  ;  let i=index ">\n    <nb-card fxFlex status="basic">\n      <nb-card-header>\n\n        Job {{job?._id}}\n\n\n\n      </nb-card-header>\n\n\n      <nb-card-body>\n\n        <nb-tag-list>\n\n          <nb-tag appearance="outline" status="warning" size="small"\n            [text]="job?.request?.job_config?.entrypoint?.join(\' \')">\n          </nb-tag>\n\n          <nb-tag appearance="outline" status="primary" size="small" [text]="job?.request?.job_config?.cmd?.join(\' \')">\n          </nb-tag>\n\n          <nb-tag appearance="outline" status="basic" size="small" *ngFor="let arg of job?.request?.job_config?.args"\n            [text]="arg"></nb-tag>\n\n          \x3c!-- <input type="text" nbTagInput [disabled]="true" [value]="job?.request?.job_config?.args.join(\' \')" fullWidth> --\x3e\n\n        </nb-tag-list>\n      </nb-card-body>\n      \x3c!-- \n      <nb-card-body>\n        {{job | json}}\n\n      </nb-card-body> --\x3e\n\n\n      <nb-card-footer fxLayoutGap="1rem" fxLayoutAlign="end">\n\n\n        <button outline size="small" nbButton>\n          Logs {{stateSyncService.SelectedJobId | async}}\n        </button>\n\n        <button outline status="primary" size="small" nbButton>\n          Response\n        </button>\n\n      </nb-card-footer>\n    </nb-card>\n\n\n  </nb-list-item>\n</nb-list>\n',styles:["nb-list-item {\n  padding: 0;\n}\n\nnb-card {\n  margin-bottom: 0.3rem;\n}"]})],te);var oe=t("tR1z"),se=t("G1Gu"),ie=t("WONP");let re=class{constructor(){this.test="#000",this.onClickEvent=new f.a}get selectedItem(){return this.selectedId==this.data._id}ngOnInit(){}onClick(){}};re.ctorParameters=()=>[],re.propDecorators={selectedItem:[{type:s.A,args:["class.selected"]}],data:[{type:s.I,args:["data"]}],selectedId:[{type:s.I,args:["selectedId"]}],onClickEvent:[{type:s.U,args:["click"]}]},re=Object(o.a)([Object(s.n)({selector:"app-list-item",template:'<div (click)="onClick()" [class.selected]="selectedId == data?._id" class="container" fxLayoutAlign="center center"\n  fxLayout="row">\n\n  <div fxLayoutAlign="start center">\n    <span class="dot " [ngClass]="\'text-\'+data?._status">&#183;</span>\n  </div>\n\n  <div fxFlex fxLayout="column" fxLayoutAlign="space-between start">\n    <div fxFlex class="subtitle-2 ">\n      {{data?._id}}\n\n    </div>\n\n    <div style="width: \'100%\' " fxFlex="1 1 100%" fxLayoutAlign="space-between"\n      [class.selected]="selectedId == data?._id">\n\n\n      <div fxFlex class="caption-2">\n\n\n        {{data?.tool?.alias}}\n\n      </div>\n      <div class="caption ">\n        {{data?.doc | date}}\n\n      </div>\n\n    </div>\n\n\n\n\n  </div>\n\n  <div *ngIf="false">\n    <nb-tag status="basic" appearance="outline" size="tiny" [text]="data?.exec_status"></nb-tag>\n    <nb-tag status="basic" appearance="outline" size="tiny" [text]="data?.tool?.alias"></nb-tag>\n\n  </div>\n\n\n\n\n  \x3c!-- <div fxFill fxFlex.md="30px" fxFlex.sm="25px" fxFlex="30px" fxFlex.gt-md="30px">\n    <nb-icon status="basic" class="icon" icon="chevron-right-outline"></nb-icon>\n  </div> --\x3e\n\n\n</div>\n',host:{},styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\n:host {\n  padding-left: 0.8rem;\n  padding-right: 0.8rem;\n  padding-top: 0.4rem;\n  padding-bottom: 0.4rem;\n  margin-bottom: 2px;\n  background-color: var(--color-basic-100);\n  border-top-right-radius: 1.2rem;\n  border-bottom-right-radius: 1.2rem;\n  margin-right: 1rem;\n}\n:host:hover {\n  background-color: var(--color-basic-400);\n}\n:host.selected {\n  background-color: var(--color-success-200);\n  color: var(--navitem-selected-text);\n}\n.icon {\n  width: 100%;\n  height: 100%;\n}\nnb-tag {\n  text-transform: capitalize;\n}\n.dot {\n  font-size: 60px;\n  margin-right: 1rem;\n  margin-left: 0.3rem;\n}"]})],re);var le,ae=t("8LU1");!function(e){e.Top="top",e.Bottom="bottom",e.Left="left",e.Right="right"}(le||(le={}));let ce=class{constructor(e){this.template=e}};ce.ctorParameters=()=>[{type:s.mb}],ce=Object(o.a)([Object(s.u)({exportAs:"ngxStepContent",selector:"ng-template[ngxStepContent]"})],ce);let pe=class{constructor(e,n){this._cdr=e,this._el=n,this.activeChange=new s.y}get icon(){return this._icon}set icon(e){this._icon=e}get completeIcon(){return this._completeIcon}set completeIcon(e){this._completeIcon=e,this._cdr.markForCheck()}get active(){return this._active}set active(e){e!==this.active&&(this._active=Object(ae.e)(e),this.activeChange.emit(this._active)),this._cdr.markForCheck()}get step(){return this._step}set step(e){this._step=Object(ae.e)(e),this._cdr.markForCheck()}get total(){return this._total}set total(e){this._total=Object(ae.e)(e),this._cdr.markForCheck()}get height(){return this._el.nativeElement.clientHeight}get width(){return this._el.nativeElement.clientWidth}get stepHeight(){return this._el.nativeElement.querySelector(".ngx-step--circle").offsetHeight}get stepWidth(){return this._el.nativeElement.querySelector(".ngx-step--circle").offsetWidth}ngOnInit(){this._cdr.markForCheck()}};pe.ctorParameters=()=>[{type:s.k},{type:s.v}],pe.propDecorators={label:[{type:s.I}],icon:[{type:s.I}],completeIcon:[{type:s.I}],active:[{type:s.I}],step:[{type:s.I}],total:[{type:s.I}],activeChange:[{type:s.U}],content:[{type:s.s,args:[ce,{descendants:!1}]}]},pe=Object(o.a)([Object(s.n)({exportAs:"ngxStep",selector:"ngx-step",template:'<div class="ngx-step--title">\n  {{ label }}\n</div>\n\n<div class="ngx-step--step">\n  <div class="ngx-step--circle" (click)="active = step">\n    <i *ngIf="icon; else stepNumber" class="center ngx-step--indicator" [ngClass]="icon"></i>\n    <i class="center ngx-step--complete-icon" [ngClass]="completeIcon"></i>\n  </div>\n</div>\n\n<ng-template #stepNumber>\n  <span class="center ngx-step--indicator">{{ step + 1 }}</span>\n</ng-template>\n',host:{class:"ngx-step","[class.ngx-step--active]":"step === active && active !== undefined","[class.ngx-step--complete-last]":"step === active - 1","[class.ngx-step--complete]":"step < active"},changeDetection:s.j.OnPush,encapsulation:s.tb.None,styles:['/**\n * Colors\n */\n/**\n * Gradients\n */\n.gradient-blue {\n  background-image: linear-gradient(to top right, #6bd1f9 0%, #54a4fb 100%);\n}\n.gradient-blue-green {\n  background-image: linear-gradient(to top right, #69d1f8 0%, #59e6c8 100%);\n}\n.gradient-blue-red {\n  background-image: linear-gradient(to top right, #50a1f9 0%, #f96f50 100%);\n}\n.gradient-blue-purple {\n  background-image: linear-gradient(to top right, #73bef4 0%, #aa90ed 100%);\n}\n.gradient-red-orange {\n  background-image: linear-gradient(to top right, #fc7c5f 0%, #fcbc5a 100%);\n}\n.gradient-orange-purple {\n  background-image: linear-gradient(to top right, #f5cc98 0%, #ae94ec 100%);\n}\n/**\n * Gradient Backgrounds\n */\n.bg-linear-1 {\n  background-image: linear-gradient(to top right, #1b1e27 0%, #2a2f40 100%);\n}\n.bg-linear-2 {\n  background-image: linear-gradient(to top right, #1b1e27 0%, #1f2a40 100%);\n}\n.bg-radial-1 {\n  background-image: radial-gradient(ellipse farthest-corner at center top, #1e283e 0%, #1b1e27 100%);\n}\n.bg-radial-2 {\n  background-image: radial-gradient(ellipse farthest-corner at center top, #212736 0%, #1b1f29 100%);\n}\n/**\n * Shadow Presets\n * Concept from: https://github.com/angular/material/blob/master/src/core/style/variables.scss\n */\n.shadow-1 {\n  box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.2), 0 1px 1px 0 rgba(0, 0, 0, 0.14), 0 2px 1px -1px rgba(0, 0, 0, 0.12);\n}\n.shadow-2 {\n  box-shadow: 0 1px 5px 0 rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);\n}\n.shadow-3 {\n  box-shadow: 0 1px 8px 0 rgba(0, 0, 0, 0.2), 0 3px 4px 0 rgba(0, 0, 0, 0.14), 0 3px 3px -2px rgba(0, 0, 0, 0.12);\n}\n.shadow-4 {\n  box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.2), 0 4px 5px 0 rgba(0, 0, 0, 0.14), 0 1px 10px 0 rgba(0, 0, 0, 0.12);\n}\n.shadow-5 {\n  box-shadow: 0 3px 5px -1px rgba(0, 0, 0, 0.2), 0 5px 8px 0 rgba(0, 0, 0, 0.14), 0 1px 14px 0 rgba(0, 0, 0, 0.12);\n}\n.shadow-6 {\n  box-shadow: 0 3px 5px -1px rgba(0, 0, 0, 0.2), 0 6px 10px 0 rgba(0, 0, 0, 0.14), 0 1px 18px 0 rgba(0, 0, 0, 0.12);\n}\n.shadow-7 {\n  box-shadow: 0 4px 5px -2px rgba(0, 0, 0, 0.2), 0 7px 10px 1px rgba(0, 0, 0, 0.14), 0 2px 16px 1px rgba(0, 0, 0, 0.12);\n}\n.shadow-8 {\n  box-shadow: 0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12);\n}\n.shadow-9 {\n  box-shadow: 0 5px 6px -3px rgba(0, 0, 0, 0.2), 0 9px 12px 1px rgba(0, 0, 0, 0.14), 0 3px 16px 2px rgba(0, 0, 0, 0.12);\n}\n.shadow-10 {\n  box-shadow: 0 6px 6px -3px rgba(0, 0, 0, 0.2), 0 10px 14px 1px rgba(0, 0, 0, 0.14), 0 4px 18px 3px rgba(0, 0, 0, 0.12);\n}\n.shadow-11 {\n  box-shadow: 0 6px 7px -4px rgba(0, 0, 0, 0.2), 0 11px 15px 1px rgba(0, 0, 0, 0.14), 0 4px 20px 3px rgba(0, 0, 0, 0.12);\n}\n.shadow-12 {\n  box-shadow: 0 7px 8px -4px rgba(0, 0, 0, 0.2), 0 12px 17px 2px rgba(0, 0, 0, 0.14), 0 5px 22px 4px rgba(0, 0, 0, 0.12);\n}\n.shadow-13 {\n  box-shadow: 0 7px 8px -4px rgba(0, 0, 0, 0.2), 0 13px 19px 2px rgba(0, 0, 0, 0.14), 0 5px 24px 4px rgba(0, 0, 0, 0.12);\n}\n.shadow-14 {\n  box-shadow: 0 7px 9px -4px rgba(0, 0, 0, 0.2), 0 14px 21px 2px rgba(0, 0, 0, 0.14), 0 5px 26px 4px rgba(0, 0, 0, 0.12);\n}\n.shadow-15 {\n  box-shadow: 0 8px 9px -5px rgba(0, 0, 0, 0.2), 0 15px 22px 2px rgba(0, 0, 0, 0.14), 0 6px 28px 5px rgba(0, 0, 0, 0.12);\n}\n.shadow-16 {\n  box-shadow: 0 8px 10px -5px rgba(0, 0, 0, 0.2), 0 16px 24px 2px rgba(0, 0, 0, 0.14), 0 6px 30px 5px rgba(0, 0, 0, 0.12);\n}\n.shadow-17 {\n  box-shadow: 0 8px 11px -5px rgba(0, 0, 0, 0.2), 0 17px 26px 2px rgba(0, 0, 0, 0.14), 0 6px 32px 5px rgba(0, 0, 0, 0.12);\n}\n.shadow-18 {\n  box-shadow: 0 9px 11px -5px rgba(0, 0, 0, 0.2), 0 18px 28px 2px rgba(0, 0, 0, 0.14), 0 7px 34px 6px rgba(0, 0, 0, 0.12);\n}\n.shadow-19 {\n  box-shadow: 0 9px 12px -6px rgba(0, 0, 0, 0.2), 0 19px 29px 2px rgba(0, 0, 0, 0.14), 0 7px 36px 6px rgba(0, 0, 0, 0.12);\n}\n.shadow-20 {\n  box-shadow: 0 10px 13px -6px rgba(0, 0, 0, 0.2), 0 20px 31px 3px rgba(0, 0, 0, 0.14), 0 8px 38px 7px rgba(0, 0, 0, 0.12);\n}\n.shadow-21 {\n  box-shadow: 0 10px 13px -6px rgba(0, 0, 0, 0.2), 0 21px 33px 3px rgba(0, 0, 0, 0.14), 0 8px 40px 7px rgba(0, 0, 0, 0.12);\n}\n.shadow-22 {\n  box-shadow: 0 10px 14px -6px rgba(0, 0, 0, 0.2), 0 22px 35px 3px rgba(0, 0, 0, 0.14), 0 8px 42px 7px rgba(0, 0, 0, 0.12);\n}\n.shadow-23 {\n  box-shadow: 0 11px 14px -7px rgba(0, 0, 0, 0.2), 0 23px 36px 3px rgba(0, 0, 0, 0.14), 0 9px 44px 8px rgba(0, 0, 0, 0.12);\n}\n.shadow-24 {\n  box-shadow: 0 11px 15px -7px rgba(0, 0, 0, 0.2), 0 24px 38px 3px rgba(0, 0, 0, 0.14), 0 9px 46px 8px rgba(0, 0, 0, 0.12);\n}\n.shadow-fx {\n  transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);\n}\n.shadow-fx:hover {\n  box-shadow: 0 10px 13px -6px rgba(0, 0, 0, 0.2), 0 20px 31px 3px rgba(0, 0, 0, 0.14), 0 8px 38px 7px rgba(0, 0, 0, 0.12);\n}\n.glow-blue-050 {\n  border: 2px solid #e6f2ff;\n  box-shadow: 0px 0px 10px 0px white;\n}\n.glow-blue-100 {\n  border: 2px solid #c7e1ff;\n  box-shadow: 0px 0px 10px 0px #e0efff;\n}\n.glow-blue-150 {\n  border: 2px solid #add4ff;\n  box-shadow: 0px 0px 10px 0px #c7e1ff;\n}\n.glow-blue-200 {\n  border: 2px solid #94c6ff;\n  box-shadow: 0px 0px 10px 0px #add4ff;\n}\n.glow-blue-250 {\n  border: 2px solid #7ab9ff;\n  box-shadow: 0px 0px 10px 0px #94c6ff;\n}\n.glow-blue-300 {\n  border: 2px solid #61abff;\n  box-shadow: 0px 0px 10px 0px #7ab9ff;\n}\n.glow-blue-350 {\n  border: 2px solid #479eff;\n  box-shadow: 0px 0px 10px 0px #61abff;\n}\n.glow-blue-400 {\n  border: 2px solid #2e90ff;\n  box-shadow: 0px 0px 10px 0px #479eff;\n}\n.glow-blue-450 {\n  border: 2px solid #1483ff;\n  box-shadow: 0px 0px 10px 0px #2e90ff;\n}\n.glow-blue-500 {\n  border: 2px solid #0076fa;\n  box-shadow: 0px 0px 10px 0px #1483ff;\n}\n.glow-blue-550 {\n  border: 2px solid #006ae0;\n  box-shadow: 0px 0px 10px 0px #0076fa;\n}\n.glow-blue-600 {\n  border: 2px solid #005ec7;\n  box-shadow: 0px 0px 10px 0px #006ae0;\n}\n.glow-blue-650 {\n  border: 2px solid #0052ad;\n  box-shadow: 0px 0px 10px 0px #005ec7;\n}\n.glow-blue-700 {\n  border: 2px solid #004694;\n  box-shadow: 0px 0px 10px 0px #0052ad;\n}\n.glow-blue-725 {\n  border: 2px solid #004087;\n  box-shadow: 0px 0px 10px 0px #004ca0;\n}\n.glow-blue-750 {\n  border: 2px solid #003a7a;\n  box-shadow: 0px 0px 10px 0px #004694;\n}\n.glow-blue-775 {\n  border: 2px solid #00346d;\n  box-shadow: 0px 0px 10px 0px #004087;\n}\n.glow-blue-800 {\n  border: 2px solid #002e61;\n  box-shadow: 0px 0px 10px 0px #003a7a;\n}\n.glow-blue-825 {\n  border: 2px solid #002854;\n  box-shadow: 0px 0px 10px 0px #00346d;\n}\n.glow-blue-850 {\n  border: 2px solid #002247;\n  box-shadow: 0px 0px 10px 0px #002e61;\n}\n.glow-blue-875 {\n  border: 2px solid #001c3a;\n  box-shadow: 0px 0px 10px 0px #002854;\n}\n.glow-blue-900 {\n  border: 2px solid #00152e;\n  box-shadow: 0px 0px 10px 0px #002247;\n}\n.glow-light-blue-050 {\n  border: 2px solid #e6f8ff;\n  box-shadow: 0px 0px 10px 0px white;\n}\n.glow-light-blue-100 {\n  border: 2px solid #d1f2fe;\n  box-shadow: 0px 0px 10px 0px #eaf9ff;\n}\n.glow-light-blue-150 {\n  border: 2px solid #b8eafe;\n  box-shadow: 0px 0px 10px 0px #d1f2fe;\n}\n.glow-light-blue-200 {\n  border: 2px solid #9fe3fd;\n  box-shadow: 0px 0px 10px 0px #b8eafe;\n}\n.glow-light-blue-250 {\n  border: 2px solid #86dbfd;\n  box-shadow: 0px 0px 10px 0px #9fe3fd;\n}\n.glow-light-blue-300 {\n  border: 2px solid #6dd4fc;\n  box-shadow: 0px 0px 10px 0px #86dbfd;\n}\n.glow-light-blue-350 {\n  border: 2px solid #54cdfc;\n  box-shadow: 0px 0px 10px 0px #6dd4fc;\n}\n.glow-light-blue-400 {\n  border: 2px solid #3bc5fb;\n  box-shadow: 0px 0px 10px 0px #54cdfc;\n}\n.glow-light-blue-450 {\n  border: 2px solid #22befb;\n  box-shadow: 0px 0px 10px 0px #3bc5fb;\n}\n.glow-light-blue-500 {\n  border: 2px solid #09b7fb;\n  box-shadow: 0px 0px 10px 0px #22befb;\n}\n.glow-light-blue-550 {\n  border: 2px solid #04a6e6;\n  box-shadow: 0px 0px 10px 0px #09b7fb;\n}\n.glow-light-blue-600 {\n  border: 2px solid #0494cd;\n  box-shadow: 0px 0px 10px 0px #04a6e6;\n}\n.glow-light-blue-650 {\n  border: 2px solid #0382b4;\n  box-shadow: 0px 0px 10px 0px #0494cd;\n}\n.glow-light-blue-700 {\n  border: 2px solid #03709b;\n  box-shadow: 0px 0px 10px 0px #0382b4;\n}\n.glow-light-blue-725 {\n  border: 2px solid #03678e;\n  box-shadow: 0px 0px 10px 0px #0379a7;\n}\n.glow-light-blue-750 {\n  border: 2px solid #025e82;\n  box-shadow: 0px 0px 10px 0px #03709b;\n}\n.glow-light-blue-775 {\n  border: 2px solid #025575;\n  box-shadow: 0px 0px 10px 0px #03678e;\n}\n.glow-light-blue-800 {\n  border: 2px solid #024c69;\n  box-shadow: 0px 0px 10px 0px #025e82;\n}\n.glow-light-blue-825 {\n  border: 2px solid #02435c;\n  box-shadow: 0px 0px 10px 0px #025575;\n}\n.glow-light-blue-850 {\n  border: 2px solid #013a50;\n  box-shadow: 0px 0px 10px 0px #024c69;\n}\n.glow-light-blue-875 {\n  border: 2px solid #013143;\n  box-shadow: 0px 0px 10px 0px #02435c;\n}\n.glow-light-blue-900 {\n  border: 2px solid #012737;\n  box-shadow: 0px 0px 10px 0px #013a50;\n}\n.glow-green-050 {\n  border: 2px solid #e5fcf7;\n  box-shadow: 0px 0px 10px 0px #fbfffe;\n}\n.glow-green-100 {\n  border: 2px solid #b8f6e9;\n  box-shadow: 0px 0px 10px 0px #cef9f0;\n}\n.glow-green-150 {\n  border: 2px solid #a1f3e2;\n  box-shadow: 0px 0px 10px 0px #b8f6e9;\n}\n.glow-green-200 {\n  border: 2px solid #8bf0db;\n  box-shadow: 0px 0px 10px 0px #a1f3e2;\n}\n.glow-green-250 {\n  border: 2px solid #74edd4;\n  box-shadow: 0px 0px 10px 0px #8bf0db;\n}\n.glow-green-300 {\n  border: 2px solid #5eeacd;\n  box-shadow: 0px 0px 10px 0px #74edd4;\n}\n.glow-green-350 {\n  border: 2px solid #47e7c6;\n  box-shadow: 0px 0px 10px 0px #5eeacd;\n}\n.glow-green-400 {\n  border: 2px solid #30e4bf;\n  box-shadow: 0px 0px 10px 0px #47e7c6;\n}\n.glow-green-450 {\n  border: 2px solid #1ddeb6;\n  box-shadow: 0px 0px 10px 0px #30e4bf;\n}\n.glow-green-500 {\n  border: 2px solid #1ac7a4;\n  box-shadow: 0px 0px 10px 0px #1ddeb6;\n}\n.glow-green-550 {\n  border: 2px solid #17b191;\n  box-shadow: 0px 0px 10px 0px #1ac7a4;\n}\n.glow-green-600 {\n  border: 2px solid #149a7f;\n  box-shadow: 0px 0px 10px 0px #17b191;\n}\n.glow-green-650 {\n  border: 2px solid #11846c;\n  box-shadow: 0px 0px 10px 0px #149a7f;\n}\n.glow-green-700 {\n  border: 2px solid #0e6d5a;\n  box-shadow: 0px 0px 10px 0px #11846c;\n}\n.glow-green-725 {\n  border: 2px solid #0d6250;\n  box-shadow: 0px 0px 10px 0px #107963;\n}\n.glow-green-750 {\n  border: 2px solid #0b5747;\n  box-shadow: 0px 0px 10px 0px #0e6d5a;\n}\n.glow-green-775 {\n  border: 2px solid #0a4b3e;\n  box-shadow: 0px 0px 10px 0px #0d6250;\n}\n.glow-green-800 {\n  border: 2px solid #084035;\n  box-shadow: 0px 0px 10px 0px #0b5747;\n}\n.glow-green-825 {\n  border: 2px solid #07352b;\n  box-shadow: 0px 0px 10px 0px #0a4b3e;\n}\n.glow-green-850 {\n  border: 2px solid #052a22;\n  box-shadow: 0px 0px 10px 0px #084035;\n}\n.glow-green-875 {\n  border: 2px solid #041e19;\n  box-shadow: 0px 0px 10px 0px #07352b;\n}\n.glow-green-900 {\n  border: 2px solid #021310;\n  box-shadow: 0px 0px 10px 0px #052a22;\n}\n.glow-orange-050 {\n  border: 2px solid #fff6e6;\n  box-shadow: 0px 0px 10px 0px white;\n}\n.glow-orange-100 {\n  border: 2px solid #ffeac7;\n  box-shadow: 0px 0px 10px 0px #fff4e0;\n}\n.glow-orange-150 {\n  border: 2px solid #ffe1ad;\n  box-shadow: 0px 0px 10px 0px #ffeac7;\n}\n.glow-orange-200 {\n  border: 2px solid #ffd794;\n  box-shadow: 0px 0px 10px 0px #ffe1ad;\n}\n.glow-orange-250 {\n  border: 2px solid #ffce7a;\n  box-shadow: 0px 0px 10px 0px #ffd794;\n}\n.glow-orange-300 {\n  border: 2px solid #ffc461;\n  box-shadow: 0px 0px 10px 0px #ffce7a;\n}\n.glow-orange-350 {\n  border: 2px solid #ffbb47;\n  box-shadow: 0px 0px 10px 0px #ffc461;\n}\n.glow-orange-400 {\n  border: 2px solid #ffb12e;\n  box-shadow: 0px 0px 10px 0px #ffbb47;\n}\n.glow-orange-450 {\n  border: 2px solid #ffa814;\n  box-shadow: 0px 0px 10px 0px #ffb12e;\n}\n.glow-orange-500 {\n  border: 2px solid #fa9d00;\n  box-shadow: 0px 0px 10px 0px #ffa814;\n}\n.glow-orange-550 {\n  border: 2px solid #e08d00;\n  box-shadow: 0px 0px 10px 0px #fa9d00;\n}\n.glow-orange-600 {\n  border: 2px solid #c77d00;\n  box-shadow: 0px 0px 10px 0px #e08d00;\n}\n.glow-orange-650 {\n  border: 2px solid #ad6d00;\n  box-shadow: 0px 0px 10px 0px #c77d00;\n}\n.glow-orange-700 {\n  border: 2px solid #945d00;\n  box-shadow: 0px 0px 10px 0px #ad6d00;\n}\n.glow-orange-725 {\n  border: 2px solid #875500;\n  box-shadow: 0px 0px 10px 0px #a06500;\n}\n.glow-orange-750 {\n  border: 2px solid #7a4d00;\n  box-shadow: 0px 0px 10px 0px #945d00;\n}\n.glow-orange-775 {\n  border: 2px solid #6d4500;\n  box-shadow: 0px 0px 10px 0px #875500;\n}\n.glow-orange-800 {\n  border: 2px solid #613d00;\n  box-shadow: 0px 0px 10px 0px #7a4d00;\n}\n.glow-orange-825 {\n  border: 2px solid #543500;\n  box-shadow: 0px 0px 10px 0px #6d4500;\n}\n.glow-orange-850 {\n  border: 2px solid #472d00;\n  box-shadow: 0px 0px 10px 0px #613d00;\n}\n.glow-orange-875 {\n  border: 2px solid #3a2500;\n  box-shadow: 0px 0px 10px 0px #543500;\n}\n.glow-orange-900 {\n  border: 2px solid #2e1d00;\n  box-shadow: 0px 0px 10px 0px #472d00;\n}\n.glow-red-050 {\n  border: 2px solid #ffebe6;\n  box-shadow: 0px 0px 10px 0px white;\n}\n.glow-red-100 {\n  border: 2px solid #ffd2c7;\n  box-shadow: 0px 0px 10px 0px #ffe6e0;\n}\n.glow-red-150 {\n  border: 2px solid #ffbead;\n  box-shadow: 0px 0px 10px 0px #ffd2c7;\n}\n.glow-red-200 {\n  border: 2px solid #ffaa94;\n  box-shadow: 0px 0px 10px 0px #ffbead;\n}\n.glow-red-250 {\n  border: 2px solid #ff967a;\n  box-shadow: 0px 0px 10px 0px #ffaa94;\n}\n.glow-red-300 {\n  border: 2px solid #ff8261;\n  box-shadow: 0px 0px 10px 0px #ff967a;\n}\n.glow-red-350 {\n  border: 2px solid #ff6d47;\n  box-shadow: 0px 0px 10px 0px #ff8261;\n}\n.glow-red-400 {\n  border: 2px solid #ff592e;\n  box-shadow: 0px 0px 10px 0px #ff6d47;\n}\n.glow-red-450 {\n  border: 2px solid #ff4514;\n  box-shadow: 0px 0px 10px 0px #ff592e;\n}\n.glow-red-500 {\n  border: 2px solid #fa3400;\n  box-shadow: 0px 0px 10px 0px #ff4514;\n}\n.glow-red-550 {\n  border: 2px solid #e02f00;\n  box-shadow: 0px 0px 10px 0px #fa3400;\n}\n.glow-red-600 {\n  border: 2px solid #c72900;\n  box-shadow: 0px 0px 10px 0px #e02f00;\n}\n.glow-red-650 {\n  border: 2px solid #ad2400;\n  box-shadow: 0px 0px 10px 0px #c72900;\n}\n.glow-red-700 {\n  border: 2px solid #941f00;\n  box-shadow: 0px 0px 10px 0px #ad2400;\n}\n.glow-red-725 {\n  border: 2px solid #871c00;\n  box-shadow: 0px 0px 10px 0px #a02100;\n}\n.glow-red-750 {\n  border: 2px solid #7a1900;\n  box-shadow: 0px 0px 10px 0px #941f00;\n}\n.glow-red-775 {\n  border: 2px solid #6d1700;\n  box-shadow: 0px 0px 10px 0px #871c00;\n}\n.glow-red-800 {\n  border: 2px solid #611400;\n  box-shadow: 0px 0px 10px 0px #7a1900;\n}\n.glow-red-825 {\n  border: 2px solid #541100;\n  box-shadow: 0px 0px 10px 0px #6d1700;\n}\n.glow-red-850 {\n  border: 2px solid #470f00;\n  box-shadow: 0px 0px 10px 0px #611400;\n}\n.glow-red-875 {\n  border: 2px solid #3a0c00;\n  box-shadow: 0px 0px 10px 0px #541100;\n}\n.glow-red-900 {\n  border: 2px solid #2e0900;\n  box-shadow: 0px 0px 10px 0px #470f00;\n}\n.glow-purple-050 {\n  border: 2px solid #eee9fc;\n  box-shadow: 0px 0px 10px 0px white;\n}\n.glow-purple-100 {\n  border: 2px solid #eee9fc;\n  box-shadow: 0px 0px 10px 0px white;\n}\n.glow-purple-150 {\n  border: 2px solid #eee9fc;\n  box-shadow: 0px 0px 10px 0px white;\n}\n.glow-purple-200 {\n  border: 2px solid #ded4f9;\n  box-shadow: 0px 0px 10px 0px #efeafc;\n}\n.glow-purple-250 {\n  border: 2px solid #cdbef5;\n  box-shadow: 0px 0px 10px 0px #ded4f9;\n}\n.glow-purple-300 {\n  border: 2px solid #bda8f2;\n  box-shadow: 0px 0px 10px 0px #cdbef5;\n}\n.glow-purple-350 {\n  border: 2px solid #ac91ef;\n  box-shadow: 0px 0px 10px 0px #bda8f2;\n}\n.glow-purple-400 {\n  border: 2px solid #9b7beb;\n  box-shadow: 0px 0px 10px 0px #ac91ef;\n}\n.glow-purple-450 {\n  border: 2px solid #8a65e8;\n  box-shadow: 0px 0px 10px 0px #9b7beb;\n}\n.glow-purple-500 {\n  border: 2px solid #794fe5;\n  box-shadow: 0px 0px 10px 0px #8a65e8;\n}\n.glow-purple-550 {\n  border: 2px solid #6839e1;\n  box-shadow: 0px 0px 10px 0px #794fe5;\n}\n.glow-purple-600 {\n  border: 2px solid #5722de;\n  box-shadow: 0px 0px 10px 0px #6839e1;\n}\n.glow-purple-650 {\n  border: 2px solid #4e1ec9;\n  box-shadow: 0px 0px 10px 0px #5722de;\n}\n.glow-purple-700 {\n  border: 2px solid #461bb3;\n  box-shadow: 0px 0px 10px 0px #4e1ec9;\n}\n.glow-purple-725 {\n  border: 2px solid #4119a8;\n  box-shadow: 0px 0px 10px 0px #4a1cbe;\n}\n.glow-purple-750 {\n  border: 2px solid #3d179d;\n  box-shadow: 0px 0px 10px 0px #461bb3;\n}\n.glow-purple-775 {\n  border: 2px solid #391692;\n  box-shadow: 0px 0px 10px 0px #4119a8;\n}\n.glow-purple-800 {\n  border: 2px solid #341486;\n  box-shadow: 0px 0px 10px 0px #3d179d;\n}\n.glow-purple-825 {\n  border: 2px solid #30127b;\n  box-shadow: 0px 0px 10px 0px #391692;\n}\n.glow-purple-850 {\n  border: 2px solid #2c1170;\n  box-shadow: 0px 0px 10px 0px #341486;\n}\n.glow-purple-875 {\n  border: 2px solid #270f65;\n  box-shadow: 0px 0px 10px 0px #30127b;\n}\n.glow-purple-900 {\n  border: 2px solid #230d5a;\n  box-shadow: 0px 0px 10px 0px #2c1170;\n}\n.glow-blue-grey-050 {\n  border: 2px solid #dce0e7;\n  box-shadow: 0px 0px 10px 0px #ebedf2;\n}\n.glow-blue-grey-100 {\n  border: 2px solid #bec5d3;\n  box-shadow: 0px 0px 10px 0px #cdd2dd;\n}\n.glow-blue-grey-150 {\n  border: 2px solid #afb7c8;\n  box-shadow: 0px 0px 10px 0px #bec5d3;\n}\n.glow-blue-grey-200 {\n  border: 2px solid #a0aabe;\n  box-shadow: 0px 0px 10px 0px #afb7c8;\n}\n.glow-blue-grey-250 {\n  border: 2px solid #909cb4;\n  box-shadow: 0px 0px 10px 0px #a0aabe;\n}\n.glow-blue-grey-300 {\n  border: 2px solid #818fa9;\n  box-shadow: 0px 0px 10px 0px #909cb4;\n}\n.glow-blue-grey-350 {\n  border: 2px solid #72819f;\n  box-shadow: 0px 0px 10px 0px #818fa9;\n}\n.glow-blue-grey-400 {\n  border: 2px solid #647493;\n  box-shadow: 0px 0px 10px 0px #72819f;\n}\n.glow-blue-grey-450 {\n  border: 2px solid #5a6884;\n  box-shadow: 0px 0px 10px 0px #647493;\n}\n.glow-blue-grey-500 {\n  border: 2px solid #505c75;\n  box-shadow: 0px 0px 10px 0px #5a6884;\n}\n.glow-blue-grey-550 {\n  border: 2px solid #455066;\n  box-shadow: 0px 0px 10px 0px #505c75;\n}\n.glow-blue-grey-600 {\n  border: 2px solid #3b4457;\n  box-shadow: 0px 0px 10px 0px #455066;\n}\n.glow-blue-grey-650 {\n  border: 2px solid #313847;\n  box-shadow: 0px 0px 10px 0px #3b4457;\n}\n.glow-blue-grey-700 {\n  border: 2px solid #262c38;\n  box-shadow: 0px 0px 10px 0px #313847;\n}\n.glow-blue-grey-725 {\n  border: 2px solid #212631;\n  box-shadow: 0px 0px 10px 0px #2b3240;\n}\n.glow-blue-grey-750 {\n  border: 2px solid #1c2029;\n  box-shadow: 0px 0px 10px 0px #262c38;\n}\n.glow-blue-grey-775 {\n  border: 2px solid #171a21;\n  box-shadow: 0px 0px 10px 0px #212631;\n}\n.glow-blue-grey-800 {\n  border: 2px solid #12141a;\n  box-shadow: 0px 0px 10px 0px #1c2029;\n}\n.glow-blue-grey-825 {\n  border: 2px solid #0c0e12;\n  box-shadow: 0px 0px 10px 0px #171a21;\n}\n.glow-blue-grey-850 {\n  border: 2px solid #07080b;\n  box-shadow: 0px 0px 10px 0px #12141a;\n}\n.glow-blue-grey-875 {\n  border: 2px solid #020203;\n  box-shadow: 0px 0px 10px 0px #0c0e12;\n}\n.glow-blue-grey-900 {\n  border: 2px solid black;\n  box-shadow: 0px 0px 10px 0px #07080b;\n}\n.glow-grey-050 {\n  border: 2px solid gainsboro;\n  box-shadow: 0px 0px 10px 0px #e9e9e9;\n}\n.glow-grey-100 {\n  border: 2px solid #c2c2c2;\n  box-shadow: 0px 0px 10px 0px #cfcfcf;\n}\n.glow-grey-150 {\n  border: 2px solid #b6b6b6;\n  box-shadow: 0px 0px 10px 0px #c2c2c2;\n}\n.glow-grey-200 {\n  border: 2px solid darkgray;\n  box-shadow: 0px 0px 10px 0px #b6b6b6;\n}\n.glow-grey-250 {\n  border: 2px solid #9c9c9c;\n  box-shadow: 0px 0px 10px 0px darkgray;\n}\n.glow-grey-300 {\n  border: 2px solid #8f8f8f;\n  box-shadow: 0px 0px 10px 0px #9c9c9c;\n}\n.glow-grey-350 {\n  border: 2px solid #838383;\n  box-shadow: 0px 0px 10px 0px #8f8f8f;\n}\n.glow-grey-400 {\n  border: 2px solid #767676;\n  box-shadow: 0px 0px 10px 0px #838383;\n}\n.glow-grey-450 {\n  border: 2px solid dimgray;\n  box-shadow: 0px 0px 10px 0px #767676;\n}\n.glow-grey-500 {\n  border: 2px solid #5c5c5c;\n  box-shadow: 0px 0px 10px 0px #696969;\n}\n.glow-grey-550 {\n  border: 2px solid #505050;\n  box-shadow: 0px 0px 10px 0px #5c5c5c;\n}\n.glow-grey-600 {\n  border: 2px solid #434343;\n  box-shadow: 0px 0px 10px 0px #505050;\n}\n.glow-grey-650 {\n  border: 2px solid #363636;\n  box-shadow: 0px 0px 10px 0px #434343;\n}\n.glow-grey-700 {\n  border: 2px solid #292929;\n  box-shadow: 0px 0px 10px 0px #363636;\n}\n.glow-grey-725 {\n  border: 2px solid #232323;\n  box-shadow: 0px 0px 10px 0px #303030;\n}\n.glow-grey-750 {\n  border: 2px solid #1d1d1d;\n  box-shadow: 0px 0px 10px 0px #292929;\n}\n.glow-grey-775 {\n  border: 2px solid #161616;\n  box-shadow: 0px 0px 10px 0px #232323;\n}\n.glow-grey-800 {\n  border: 2px solid #101010;\n  box-shadow: 0px 0px 10px 0px #1d1d1d;\n}\n.glow-grey-825 {\n  border: 2px solid #090909;\n  box-shadow: 0px 0px 10px 0px #161616;\n}\n.glow-grey-850 {\n  border: 2px solid #030303;\n  box-shadow: 0px 0px 10px 0px #101010;\n}\n.glow-grey-875 {\n  border: 2px solid black;\n  box-shadow: 0px 0px 10px 0px #090909;\n}\n.glow-grey-900 {\n  border: 2px solid black;\n  box-shadow: 0px 0px 10px 0px #030303;\n}\n.ngx-step {\n  flex: 1 1 auto;\n}\n.ngx-step:last-child {\n  flex: initial;\n}\n.ngx-step:last-child .ngx-step--step:after {\n  display: none;\n}\n.ngx-step.ngx-step--active .ngx-step--title {\n  color: #1483ff;\n}\n.ngx-step.ngx-step--active .ngx-step--step:after {\n  background-image: linear-gradient(to right, #1483ff 0%, #455066 75%) !important;\n}\n.ngx-step.ngx-step--active .ngx-step--step .ngx-step--circle {\n  border: 1.75px solid #1483ff;\n  color: #1483ff;\n  box-shadow: 0px 0px 9.59842px rgba(20, 131, 255, 0.8);\n}\n.ngx-step.ngx-step--active .ngx-step--step .ngx-step--circle .marker-path {\n  fill: #1483ff;\n}\n.ngx-step.ngx-step--complete .ngx-step--circle:hover {\n  border: 1.75px solid #1483ff;\n  color: #1483ff;\n  box-shadow: 0px 0px 9.59842px rgba(20, 131, 255, 0.8);\n}\n.ngx-step.ngx-step--complete .ngx-step--circle:hover .ngx-step--indicator {\n  opacity: 1 !important;\n}\n.ngx-step.ngx-step--complete .ngx-step--circle:hover i.ngx-step--complete-icon {\n  opacity: 0 !important;\n}\n.ngx-step.ngx-step--complete .ngx-step--circle:hover .marker-path {\n  fill: #1483ff;\n}\n.ngx-step.ngx-step--complete:not(.ngx-step--complete-last) .ngx-step--title {\n  color: #1ddeb6;\n}\n.ngx-step.ngx-step--complete:not(.ngx-step--complete-last) .ngx-step--step:after {\n  background-color: #1ddeb6 !important;\n}\n.ngx-step.ngx-step--complete:not(.ngx-step--complete-last) .ngx-step--step .ngx-step--circle {\n  border: 1.75px solid #1ddeb6;\n  color: #1ddeb6;\n  box-shadow: 0px 0px 9.59842px rgba(122, 185, 255, 0.7);\n}\n.ngx-step.ngx-step--complete:not(.ngx-step--complete-last) .ngx-step--step .ngx-step--circle .marker-path {\n  fill: #1ddeb6;\n}\n.ngx-step.ngx-step--complete:not(.ngx-step--complete-last) .ngx-step--step .ngx-step--circle .ngx-step--indicator {\n  opacity: 0;\n}\n.ngx-step.ngx-step--complete:not(.ngx-step--complete-last) .ngx-step--step .ngx-step--circle i.ngx-step--complete-icon {\n  opacity: 1;\n}\n.ngx-step.ngx-step--complete.ngx-step--complete-last .ngx-step--title {\n  color: #1ddeb6;\n}\n.ngx-step.ngx-step--complete.ngx-step--complete-last .ngx-step--step:after {\n  background-image: linear-gradient(to right, #1edeb6 0%, #1483ff 75%) !important;\n}\n.ngx-step.ngx-step--complete.ngx-step--complete-last .ngx-step--step .ngx-step--circle {\n  border: 1.75px solid #1ddeb6;\n  color: #1ddeb6;\n  box-shadow: 0px 0px 9.59842px rgba(122, 185, 255, 0.7);\n}\n.ngx-step.ngx-step--complete.ngx-step--complete-last .ngx-step--step .ngx-step--circle .marker-path {\n  fill: #1ddeb6;\n}\n.ngx-step.ngx-step--complete.ngx-step--complete-last .ngx-step--step .ngx-step--circle .ngx-step--indicator {\n  opacity: 0;\n}\n.ngx-step.ngx-step--complete.ngx-step--complete-last .ngx-step--step .ngx-step--circle i.ngx-step--complete-icon {\n  opacity: 1;\n}\n.ngx-step .ngx-step--title {\n  padding: 0 5px;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  font-weight: 600;\n  font-size: 16px;\n  line-height: 22px;\n  color: #455066;\n  transition: color 0.25s ease-in-out;\n}\n.ngx-step .ngx-step--step {\n  display: flex;\n  flex: 1 1 auto;\n  align-items: center;\n}\n.ngx-step .ngx-step--step:after {\n  flex: 1 1 auto;\n  height: 1.4px;\n  background-color: #455066;\n  transition: background-color 0.25s ease-in-out, background-image 0.25s ease-in-out;\n  content: "";\n}\n.ngx-step .ngx-step--step .ngx-step--circle {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  position: relative;\n  width: 1.75rem;\n  height: 1.75rem;\n  background: linear-gradient(180deg, #262c38 0%, #12141a 100%);\n  border-radius: 50%;\n  border: 1.75px solid #455066;\n  color: #455066;\n  font-size: 0.875rem;\n  font-weight: bold;\n  transition: border-color 0.25s ease-in-out, color 0.25s ease-in-out;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  cursor: pointer;\n}\n.ngx-step .ngx-step--step .ngx-step--circle .ngx-step--indicator {\n  padding-bottom: 1px;\n}\n.ngx-step .ngx-step--step .ngx-step--circle i.ngx-step--complete-icon {\n  opacity: 0;\n}\n.ngx-step .ngx-step--step .ngx-step--circle .center {\n  margin: 0;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  transition: opacity 0.25s ease-in-out;\n}']})],pe);var he,de,be=t("R0Ic");!function(e){e.Left="left",e.Right="right",e.Current="current",e.Up="up",e.Down="down"}(he||(he={})),function(e){e.Move="move",e.Stay="stay"}(de||(de={}));const xe={horizontalStepTransition:Object(be.k)("stepHorizontalTransition",[Object(be.h)(he.Left,Object(be.i)({transform:"translate3d(-100%, 0, 0)",visibility:"hidden"})),Object(be.h)(he.Right,Object(be.i)({transform:"translate3d(100%, 0, 0)",visibility:"hidden"})),Object(be.h)(he.Current,Object(be.i)({transform:"none",visibility:"visible"})),Object(be.j)("* => *",Object(be.e)("500ms cubic-bezier(0.35, 0, 0.25, 1)"))]),verticalStepTransition:Object(be.k)("stepVerticalTransition",[Object(be.h)(he.Up,Object(be.i)({transform:"translate3d(0, -100%, 0)",visibility:"hidden"})),Object(be.h)(he.Down,Object(be.i)({transform:"translate3d(0, 100%, 0)",visibility:"hidden"})),Object(be.h)(he.Current,Object(be.i)({transform:"none",visibility:"visible"})),Object(be.j)("* <=> "+he.Current,Object(be.e)("225ms cubic-bezier(0.4, 0.0, 0.2, 1)"))]),horizontalBarTransition:Object(be.k)("stepperBarHorizontalTransition",[Object(be.h)(de.Stay,Object(be.i)({transition:"500ms cubic-bezier(0.35, 0, 0.25, 1)",transform:"translateX({{ xOffset }}px)",height:"2px",width:"calc(1.4 * {{ width }}px)"}),{params:{xOffset:0,width:0}}),Object(be.h)(de.Move,Object(be.i)({transition:"500ms cubic-bezier(0.35, 0, 0.25, 1)",transform:"translateX({{ xOffset }}px)",height:"2px",width:"calc({{ width }}px * 1.4 / 2)","margin-left":"calc(1.4 * {{ width }}px / 4)"}),{params:{xOffset:0,width:0}})]),verticalBarTransition:Object(be.k)("stepperBarVerticalTransition",[Object(be.h)(de.Stay,Object(be.i)({transition:"500ms cubic-bezier(0.35, 0, 0.25, 1)",transform:"translateY({{ yOffset }}px)",width:"2px",height:"calc(1.4 * {{ height }}px)"}),{params:{yOffset:0,height:0}}),Object(be.h)(de.Move,Object(be.i)({transition:"500ms cubic-bezier(0.35, 0, 0.25, 1)",transform:"translateY({{ yOffset }}px)",width:"2px",height:"calc({{ height }}px * 1.4 / 2)","margin-top":"calc(1.4 * {{ height }}px / 4)"}),{params:{yOffset:0,height:0}})])};let ue=class{constructor(e){this._cdr=e,this.position=le.Top,this.activeChange=new s.y,this.StepperPosition=le,this._active=0,this._readonly=!0,this._trackBar=!0,this._progress=!1,this._large=!1,this._removeHighlight=!1,this._completeIcon="ngx-icon ngx-check",this._barState=de.Stay,this._destroy$=new f.a}get completeIcon(){return this._completeIcon}set completeIcon(e){if(this._steps)for(const n of this._steps)n.completeIcon&&n.completeIcon!==this._completeIcon||(n.completeIcon=e);this._completeIcon=e}get active(){return this._active}set active(e){if(void 0!==(e=Object(ae.e)(e))&&!isNaN(e)&&e!==this._active&&e>=0&&(!this._steps||e<=this._steps.length)){if(this._active=e,this._steps)for(const n of this._steps)n.active=e;this.activeChange.emit(this._active)}}get readonly(){return this._readonly}set readonly(e){this._readonly=Object(ae.b)(e)}get progress(){return this._progress}set progress(e){this._progress=Object(ae.b)(e)}get large(){return this._large}set large(e){this._large=Object(ae.b)(e)}get removeHighlight(){return this._removeHighlight}set removeHighlight(e){this._removeHighlight=Object(ae.b)(e)}get trackBar(){return this._trackBar}set trackBar(e){this._trackBar=Object(ae.b)(e)}get steps(){return this._steps}set steps(e){this._steps=e,this._destroy$.next();for(const n of this._steps.map((e,n)=>({step:e,i:n})))setTimeout(()=>{n.step.step=n.i,n.step.active=this.active,n.step.total=this._steps.length,n.step.completeIcon||(n.step.completeIcon=this.completeIcon),n.step.activeChange.pipe(Object($.a)(this._destroy$)).subscribe(e=>this.active=e)});this._cdr.markForCheck()}get completeSteps(){return this._steps.filter(e=>e.step<this.active).length}get vertical(){return this.position===le.Left||this.position===le.Right}get barState(){return this._barState}ngOnDestroy(){this._destroy$.next(),this._destroy$.complete()}previous(){this._active>0&&this.active--}next(){this.steps.length&&this._active<this._steps.length-1&&this.active++}first(){this.active=0}last(){this.active=this._steps.length-1}complete(){this.active=this._steps.length}onResize(){this._cdr.detectChanges()}onStepAnimationStart(e){e===this._active&&setTimeout(()=>{this._barState=de.Move,this._cdr.markForCheck()})}onStepAnimationEnd(e){e===this._active&&setTimeout(()=>{this._barState=de.Stay,this._cdr.markForCheck()})}getStepState(e){const n=e-this._active;return n<0?this.vertical?he.Up:he.Left:n>0?this.vertical?he.Down:he.Right:he.Current}};ue.ctorParameters=()=>[{type:s.k}],ue.propDecorators={position:[{type:s.I}],completeIcon:[{type:s.I}],active:[{type:s.I}],readonly:[{type:s.I}],progress:[{type:s.I}],large:[{type:s.I}],removeHighlight:[{type:s.I}],trackBar:[{type:s.I}],activeChange:[{type:s.U}],steps:[{type:s.s,args:[pe]}]},ue=Object(o.a)([Object(s.n)({exportAs:"ngxStepper",selector:"ngx-stepper",template:'<div class="ngx-stepper--steps" (resizeObserver)="onResize()">\n  <ng-content select="ngx-step"></ng-content>\n</div>\n\n<div class="ngx-stepper--bar-track">\n  <div\n    *ngIf="trackBar && !vertical"\n    class="ngx-stepper--bar"\n    [@stepperBarHorizontalTransition]="{\n      value: barState,\n      params: { xOffset: steps.first.width * completeSteps, width: steps.first.stepWidth }\n    }"\n  ></div>\n\n  <div\n    *ngIf="trackBar && vertical"\n    class="ngx-stepper--bar"\n    [@stepperBarVerticalTransition]="{\n      value: barState,\n      params: { yOffset: steps.first.height * completeSteps, height: steps.first.stepHeight }\n    }"\n  ></div>\n</div>\n\n<ng-container *ngTemplateOutlet="vertical ? verticalTpl : horizontalTpl"></ng-container>\n\n<ng-template #verticalTpl>\n  <div\n    *ngFor="let step of steps; let i = index"\n    class="ngx-stepper--content"\n    [class.active]="active === i"\n    [@stepVerticalTransition]="getStepState(i)"\n    (@stepVerticalTransition.start)="onStepAnimationStart(i)"\n    (@stepVerticalTransition.done)="onStepAnimationEnd(i)"\n  >\n    <ng-container *ngIf="active === i">\n      <ng-template [ngTemplateOutlet]="step.content?.first?.template"></ng-template>\n    </ng-container>\n  </div>\n</ng-template>\n\n<ng-template #horizontalTpl>\n  <div\n    *ngFor="let step of steps; let i = index"\n    class="ngx-stepper--content"\n    [class.active]="active === i"\n    [@stepHorizontalTransition]="getStepState(i)"\n    (@stepHorizontalTransition.start)="onStepAnimationStart(i)"\n    (@stepHorizontalTransition.done)="onStepAnimationEnd(i)"\n  >\n    <ng-container *ngIf="active === i">\n      <ng-template [ngTemplateOutlet]="step.content?.first?.template"></ng-template>\n    </ng-container>\n  </div>\n</ng-template>\n',host:{class:"ngx-stepper","[class.ngx-stepper--readonly]":"readonly","[class.ngx-stepper--with-progress]":"progress","[class.ngx-stepper--lg]":"large","[class.ngx-stepper--no-highlight]":"removeHighlight","[class.ngx-stepper--top]":"position === StepperPosition.Top","[class.ngx-stepper--bottom]":"position === StepperPosition.Bottom","[class.ngx-stepper--left]":"position === StepperPosition.Left","[class.ngx-stepper--right]":"position === StepperPosition.Right"},animations:[xe.horizontalStepTransition,xe.verticalStepTransition,xe.horizontalBarTransition,xe.verticalBarTransition],changeDetection:s.j.OnPush,encapsulation:s.tb.None,styles:['/**\n * Colors\n */\n/**\n * Gradients\n */\n.gradient-blue {\n  background-image: linear-gradient(to top right, #6bd1f9 0%, #54a4fb 100%);\n}\n.gradient-blue-green {\n  background-image: linear-gradient(to top right, #69d1f8 0%, #59e6c8 100%);\n}\n.gradient-blue-red {\n  background-image: linear-gradient(to top right, #50a1f9 0%, #f96f50 100%);\n}\n.gradient-blue-purple {\n  background-image: linear-gradient(to top right, #73bef4 0%, #aa90ed 100%);\n}\n.gradient-red-orange {\n  background-image: linear-gradient(to top right, #fc7c5f 0%, #fcbc5a 100%);\n}\n.gradient-orange-purple {\n  background-image: linear-gradient(to top right, #f5cc98 0%, #ae94ec 100%);\n}\n/**\n * Gradient Backgrounds\n */\n.bg-linear-1 {\n  background-image: linear-gradient(to top right, #1b1e27 0%, #2a2f40 100%);\n}\n.bg-linear-2 {\n  background-image: linear-gradient(to top right, #1b1e27 0%, #1f2a40 100%);\n}\n.bg-radial-1 {\n  background-image: radial-gradient(ellipse farthest-corner at center top, #1e283e 0%, #1b1e27 100%);\n}\n.bg-radial-2 {\n  background-image: radial-gradient(ellipse farthest-corner at center top, #212736 0%, #1b1f29 100%);\n}\n/**\n * Shadow Presets\n * Concept from: https://github.com/angular/material/blob/master/src/core/style/variables.scss\n */\n.shadow-1 {\n  box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.2), 0 1px 1px 0 rgba(0, 0, 0, 0.14), 0 2px 1px -1px rgba(0, 0, 0, 0.12);\n}\n.shadow-2 {\n  box-shadow: 0 1px 5px 0 rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);\n}\n.shadow-3 {\n  box-shadow: 0 1px 8px 0 rgba(0, 0, 0, 0.2), 0 3px 4px 0 rgba(0, 0, 0, 0.14), 0 3px 3px -2px rgba(0, 0, 0, 0.12);\n}\n.shadow-4 {\n  box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.2), 0 4px 5px 0 rgba(0, 0, 0, 0.14), 0 1px 10px 0 rgba(0, 0, 0, 0.12);\n}\n.shadow-5 {\n  box-shadow: 0 3px 5px -1px rgba(0, 0, 0, 0.2), 0 5px 8px 0 rgba(0, 0, 0, 0.14), 0 1px 14px 0 rgba(0, 0, 0, 0.12);\n}\n.shadow-6 {\n  box-shadow: 0 3px 5px -1px rgba(0, 0, 0, 0.2), 0 6px 10px 0 rgba(0, 0, 0, 0.14), 0 1px 18px 0 rgba(0, 0, 0, 0.12);\n}\n.shadow-7 {\n  box-shadow: 0 4px 5px -2px rgba(0, 0, 0, 0.2), 0 7px 10px 1px rgba(0, 0, 0, 0.14), 0 2px 16px 1px rgba(0, 0, 0, 0.12);\n}\n.shadow-8 {\n  box-shadow: 0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12);\n}\n.shadow-9 {\n  box-shadow: 0 5px 6px -3px rgba(0, 0, 0, 0.2), 0 9px 12px 1px rgba(0, 0, 0, 0.14), 0 3px 16px 2px rgba(0, 0, 0, 0.12);\n}\n.shadow-10 {\n  box-shadow: 0 6px 6px -3px rgba(0, 0, 0, 0.2), 0 10px 14px 1px rgba(0, 0, 0, 0.14), 0 4px 18px 3px rgba(0, 0, 0, 0.12);\n}\n.shadow-11 {\n  box-shadow: 0 6px 7px -4px rgba(0, 0, 0, 0.2), 0 11px 15px 1px rgba(0, 0, 0, 0.14), 0 4px 20px 3px rgba(0, 0, 0, 0.12);\n}\n.shadow-12 {\n  box-shadow: 0 7px 8px -4px rgba(0, 0, 0, 0.2), 0 12px 17px 2px rgba(0, 0, 0, 0.14), 0 5px 22px 4px rgba(0, 0, 0, 0.12);\n}\n.shadow-13 {\n  box-shadow: 0 7px 8px -4px rgba(0, 0, 0, 0.2), 0 13px 19px 2px rgba(0, 0, 0, 0.14), 0 5px 24px 4px rgba(0, 0, 0, 0.12);\n}\n.shadow-14 {\n  box-shadow: 0 7px 9px -4px rgba(0, 0, 0, 0.2), 0 14px 21px 2px rgba(0, 0, 0, 0.14), 0 5px 26px 4px rgba(0, 0, 0, 0.12);\n}\n.shadow-15 {\n  box-shadow: 0 8px 9px -5px rgba(0, 0, 0, 0.2), 0 15px 22px 2px rgba(0, 0, 0, 0.14), 0 6px 28px 5px rgba(0, 0, 0, 0.12);\n}\n.shadow-16 {\n  box-shadow: 0 8px 10px -5px rgba(0, 0, 0, 0.2), 0 16px 24px 2px rgba(0, 0, 0, 0.14), 0 6px 30px 5px rgba(0, 0, 0, 0.12);\n}\n.shadow-17 {\n  box-shadow: 0 8px 11px -5px rgba(0, 0, 0, 0.2), 0 17px 26px 2px rgba(0, 0, 0, 0.14), 0 6px 32px 5px rgba(0, 0, 0, 0.12);\n}\n.shadow-18 {\n  box-shadow: 0 9px 11px -5px rgba(0, 0, 0, 0.2), 0 18px 28px 2px rgba(0, 0, 0, 0.14), 0 7px 34px 6px rgba(0, 0, 0, 0.12);\n}\n.shadow-19 {\n  box-shadow: 0 9px 12px -6px rgba(0, 0, 0, 0.2), 0 19px 29px 2px rgba(0, 0, 0, 0.14), 0 7px 36px 6px rgba(0, 0, 0, 0.12);\n}\n.shadow-20 {\n  box-shadow: 0 10px 13px -6px rgba(0, 0, 0, 0.2), 0 20px 31px 3px rgba(0, 0, 0, 0.14), 0 8px 38px 7px rgba(0, 0, 0, 0.12);\n}\n.shadow-21 {\n  box-shadow: 0 10px 13px -6px rgba(0, 0, 0, 0.2), 0 21px 33px 3px rgba(0, 0, 0, 0.14), 0 8px 40px 7px rgba(0, 0, 0, 0.12);\n}\n.shadow-22 {\n  box-shadow: 0 10px 14px -6px rgba(0, 0, 0, 0.2), 0 22px 35px 3px rgba(0, 0, 0, 0.14), 0 8px 42px 7px rgba(0, 0, 0, 0.12);\n}\n.shadow-23 {\n  box-shadow: 0 11px 14px -7px rgba(0, 0, 0, 0.2), 0 23px 36px 3px rgba(0, 0, 0, 0.14), 0 9px 44px 8px rgba(0, 0, 0, 0.12);\n}\n.shadow-24 {\n  box-shadow: 0 11px 15px -7px rgba(0, 0, 0, 0.2), 0 24px 38px 3px rgba(0, 0, 0, 0.14), 0 9px 46px 8px rgba(0, 0, 0, 0.12);\n}\n.shadow-fx {\n  transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);\n}\n.shadow-fx:hover {\n  box-shadow: 0 10px 13px -6px rgba(0, 0, 0, 0.2), 0 20px 31px 3px rgba(0, 0, 0, 0.14), 0 8px 38px 7px rgba(0, 0, 0, 0.12);\n}\n.glow-blue-050 {\n  border: 2px solid #e6f2ff;\n  box-shadow: 0px 0px 10px 0px white;\n}\n.glow-blue-100 {\n  border: 2px solid #c7e1ff;\n  box-shadow: 0px 0px 10px 0px #e0efff;\n}\n.glow-blue-150 {\n  border: 2px solid #add4ff;\n  box-shadow: 0px 0px 10px 0px #c7e1ff;\n}\n.glow-blue-200 {\n  border: 2px solid #94c6ff;\n  box-shadow: 0px 0px 10px 0px #add4ff;\n}\n.glow-blue-250 {\n  border: 2px solid #7ab9ff;\n  box-shadow: 0px 0px 10px 0px #94c6ff;\n}\n.glow-blue-300 {\n  border: 2px solid #61abff;\n  box-shadow: 0px 0px 10px 0px #7ab9ff;\n}\n.glow-blue-350 {\n  border: 2px solid #479eff;\n  box-shadow: 0px 0px 10px 0px #61abff;\n}\n.glow-blue-400 {\n  border: 2px solid #2e90ff;\n  box-shadow: 0px 0px 10px 0px #479eff;\n}\n.glow-blue-450 {\n  border: 2px solid #1483ff;\n  box-shadow: 0px 0px 10px 0px #2e90ff;\n}\n.glow-blue-500 {\n  border: 2px solid #0076fa;\n  box-shadow: 0px 0px 10px 0px #1483ff;\n}\n.glow-blue-550 {\n  border: 2px solid #006ae0;\n  box-shadow: 0px 0px 10px 0px #0076fa;\n}\n.glow-blue-600 {\n  border: 2px solid #005ec7;\n  box-shadow: 0px 0px 10px 0px #006ae0;\n}\n.glow-blue-650 {\n  border: 2px solid #0052ad;\n  box-shadow: 0px 0px 10px 0px #005ec7;\n}\n.glow-blue-700 {\n  border: 2px solid #004694;\n  box-shadow: 0px 0px 10px 0px #0052ad;\n}\n.glow-blue-725 {\n  border: 2px solid #004087;\n  box-shadow: 0px 0px 10px 0px #004ca0;\n}\n.glow-blue-750 {\n  border: 2px solid #003a7a;\n  box-shadow: 0px 0px 10px 0px #004694;\n}\n.glow-blue-775 {\n  border: 2px solid #00346d;\n  box-shadow: 0px 0px 10px 0px #004087;\n}\n.glow-blue-800 {\n  border: 2px solid #002e61;\n  box-shadow: 0px 0px 10px 0px #003a7a;\n}\n.glow-blue-825 {\n  border: 2px solid #002854;\n  box-shadow: 0px 0px 10px 0px #00346d;\n}\n.glow-blue-850 {\n  border: 2px solid #002247;\n  box-shadow: 0px 0px 10px 0px #002e61;\n}\n.glow-blue-875 {\n  border: 2px solid #001c3a;\n  box-shadow: 0px 0px 10px 0px #002854;\n}\n.glow-blue-900 {\n  border: 2px solid #00152e;\n  box-shadow: 0px 0px 10px 0px #002247;\n}\n.glow-light-blue-050 {\n  border: 2px solid #e6f8ff;\n  box-shadow: 0px 0px 10px 0px white;\n}\n.glow-light-blue-100 {\n  border: 2px solid #d1f2fe;\n  box-shadow: 0px 0px 10px 0px #eaf9ff;\n}\n.glow-light-blue-150 {\n  border: 2px solid #b8eafe;\n  box-shadow: 0px 0px 10px 0px #d1f2fe;\n}\n.glow-light-blue-200 {\n  border: 2px solid #9fe3fd;\n  box-shadow: 0px 0px 10px 0px #b8eafe;\n}\n.glow-light-blue-250 {\n  border: 2px solid #86dbfd;\n  box-shadow: 0px 0px 10px 0px #9fe3fd;\n}\n.glow-light-blue-300 {\n  border: 2px solid #6dd4fc;\n  box-shadow: 0px 0px 10px 0px #86dbfd;\n}\n.glow-light-blue-350 {\n  border: 2px solid #54cdfc;\n  box-shadow: 0px 0px 10px 0px #6dd4fc;\n}\n.glow-light-blue-400 {\n  border: 2px solid #3bc5fb;\n  box-shadow: 0px 0px 10px 0px #54cdfc;\n}\n.glow-light-blue-450 {\n  border: 2px solid #22befb;\n  box-shadow: 0px 0px 10px 0px #3bc5fb;\n}\n.glow-light-blue-500 {\n  border: 2px solid #09b7fb;\n  box-shadow: 0px 0px 10px 0px #22befb;\n}\n.glow-light-blue-550 {\n  border: 2px solid #04a6e6;\n  box-shadow: 0px 0px 10px 0px #09b7fb;\n}\n.glow-light-blue-600 {\n  border: 2px solid #0494cd;\n  box-shadow: 0px 0px 10px 0px #04a6e6;\n}\n.glow-light-blue-650 {\n  border: 2px solid #0382b4;\n  box-shadow: 0px 0px 10px 0px #0494cd;\n}\n.glow-light-blue-700 {\n  border: 2px solid #03709b;\n  box-shadow: 0px 0px 10px 0px #0382b4;\n}\n.glow-light-blue-725 {\n  border: 2px solid #03678e;\n  box-shadow: 0px 0px 10px 0px #0379a7;\n}\n.glow-light-blue-750 {\n  border: 2px solid #025e82;\n  box-shadow: 0px 0px 10px 0px #03709b;\n}\n.glow-light-blue-775 {\n  border: 2px solid #025575;\n  box-shadow: 0px 0px 10px 0px #03678e;\n}\n.glow-light-blue-800 {\n  border: 2px solid #024c69;\n  box-shadow: 0px 0px 10px 0px #025e82;\n}\n.glow-light-blue-825 {\n  border: 2px solid #02435c;\n  box-shadow: 0px 0px 10px 0px #025575;\n}\n.glow-light-blue-850 {\n  border: 2px solid #013a50;\n  box-shadow: 0px 0px 10px 0px #024c69;\n}\n.glow-light-blue-875 {\n  border: 2px solid #013143;\n  box-shadow: 0px 0px 10px 0px #02435c;\n}\n.glow-light-blue-900 {\n  border: 2px solid #012737;\n  box-shadow: 0px 0px 10px 0px #013a50;\n}\n.glow-green-050 {\n  border: 2px solid #e5fcf7;\n  box-shadow: 0px 0px 10px 0px #fbfffe;\n}\n.glow-green-100 {\n  border: 2px solid #b8f6e9;\n  box-shadow: 0px 0px 10px 0px #cef9f0;\n}\n.glow-green-150 {\n  border: 2px solid #a1f3e2;\n  box-shadow: 0px 0px 10px 0px #b8f6e9;\n}\n.glow-green-200 {\n  border: 2px solid #8bf0db;\n  box-shadow: 0px 0px 10px 0px #a1f3e2;\n}\n.glow-green-250 {\n  border: 2px solid #74edd4;\n  box-shadow: 0px 0px 10px 0px #8bf0db;\n}\n.glow-green-300 {\n  border: 2px solid #5eeacd;\n  box-shadow: 0px 0px 10px 0px #74edd4;\n}\n.glow-green-350 {\n  border: 2px solid #47e7c6;\n  box-shadow: 0px 0px 10px 0px #5eeacd;\n}\n.glow-green-400 {\n  border: 2px solid #30e4bf;\n  box-shadow: 0px 0px 10px 0px #47e7c6;\n}\n.glow-green-450 {\n  border: 2px solid #1ddeb6;\n  box-shadow: 0px 0px 10px 0px #30e4bf;\n}\n.glow-green-500 {\n  border: 2px solid #1ac7a4;\n  box-shadow: 0px 0px 10px 0px #1ddeb6;\n}\n.glow-green-550 {\n  border: 2px solid #17b191;\n  box-shadow: 0px 0px 10px 0px #1ac7a4;\n}\n.glow-green-600 {\n  border: 2px solid #149a7f;\n  box-shadow: 0px 0px 10px 0px #17b191;\n}\n.glow-green-650 {\n  border: 2px solid #11846c;\n  box-shadow: 0px 0px 10px 0px #149a7f;\n}\n.glow-green-700 {\n  border: 2px solid #0e6d5a;\n  box-shadow: 0px 0px 10px 0px #11846c;\n}\n.glow-green-725 {\n  border: 2px solid #0d6250;\n  box-shadow: 0px 0px 10px 0px #107963;\n}\n.glow-green-750 {\n  border: 2px solid #0b5747;\n  box-shadow: 0px 0px 10px 0px #0e6d5a;\n}\n.glow-green-775 {\n  border: 2px solid #0a4b3e;\n  box-shadow: 0px 0px 10px 0px #0d6250;\n}\n.glow-green-800 {\n  border: 2px solid #084035;\n  box-shadow: 0px 0px 10px 0px #0b5747;\n}\n.glow-green-825 {\n  border: 2px solid #07352b;\n  box-shadow: 0px 0px 10px 0px #0a4b3e;\n}\n.glow-green-850 {\n  border: 2px solid #052a22;\n  box-shadow: 0px 0px 10px 0px #084035;\n}\n.glow-green-875 {\n  border: 2px solid #041e19;\n  box-shadow: 0px 0px 10px 0px #07352b;\n}\n.glow-green-900 {\n  border: 2px solid #021310;\n  box-shadow: 0px 0px 10px 0px #052a22;\n}\n.glow-orange-050 {\n  border: 2px solid #fff6e6;\n  box-shadow: 0px 0px 10px 0px white;\n}\n.glow-orange-100 {\n  border: 2px solid #ffeac7;\n  box-shadow: 0px 0px 10px 0px #fff4e0;\n}\n.glow-orange-150 {\n  border: 2px solid #ffe1ad;\n  box-shadow: 0px 0px 10px 0px #ffeac7;\n}\n.glow-orange-200 {\n  border: 2px solid #ffd794;\n  box-shadow: 0px 0px 10px 0px #ffe1ad;\n}\n.glow-orange-250 {\n  border: 2px solid #ffce7a;\n  box-shadow: 0px 0px 10px 0px #ffd794;\n}\n.glow-orange-300 {\n  border: 2px solid #ffc461;\n  box-shadow: 0px 0px 10px 0px #ffce7a;\n}\n.glow-orange-350 {\n  border: 2px solid #ffbb47;\n  box-shadow: 0px 0px 10px 0px #ffc461;\n}\n.glow-orange-400 {\n  border: 2px solid #ffb12e;\n  box-shadow: 0px 0px 10px 0px #ffbb47;\n}\n.glow-orange-450 {\n  border: 2px solid #ffa814;\n  box-shadow: 0px 0px 10px 0px #ffb12e;\n}\n.glow-orange-500 {\n  border: 2px solid #fa9d00;\n  box-shadow: 0px 0px 10px 0px #ffa814;\n}\n.glow-orange-550 {\n  border: 2px solid #e08d00;\n  box-shadow: 0px 0px 10px 0px #fa9d00;\n}\n.glow-orange-600 {\n  border: 2px solid #c77d00;\n  box-shadow: 0px 0px 10px 0px #e08d00;\n}\n.glow-orange-650 {\n  border: 2px solid #ad6d00;\n  box-shadow: 0px 0px 10px 0px #c77d00;\n}\n.glow-orange-700 {\n  border: 2px solid #945d00;\n  box-shadow: 0px 0px 10px 0px #ad6d00;\n}\n.glow-orange-725 {\n  border: 2px solid #875500;\n  box-shadow: 0px 0px 10px 0px #a06500;\n}\n.glow-orange-750 {\n  border: 2px solid #7a4d00;\n  box-shadow: 0px 0px 10px 0px #945d00;\n}\n.glow-orange-775 {\n  border: 2px solid #6d4500;\n  box-shadow: 0px 0px 10px 0px #875500;\n}\n.glow-orange-800 {\n  border: 2px solid #613d00;\n  box-shadow: 0px 0px 10px 0px #7a4d00;\n}\n.glow-orange-825 {\n  border: 2px solid #543500;\n  box-shadow: 0px 0px 10px 0px #6d4500;\n}\n.glow-orange-850 {\n  border: 2px solid #472d00;\n  box-shadow: 0px 0px 10px 0px #613d00;\n}\n.glow-orange-875 {\n  border: 2px solid #3a2500;\n  box-shadow: 0px 0px 10px 0px #543500;\n}\n.glow-orange-900 {\n  border: 2px solid #2e1d00;\n  box-shadow: 0px 0px 10px 0px #472d00;\n}\n.glow-red-050 {\n  border: 2px solid #ffebe6;\n  box-shadow: 0px 0px 10px 0px white;\n}\n.glow-red-100 {\n  border: 2px solid #ffd2c7;\n  box-shadow: 0px 0px 10px 0px #ffe6e0;\n}\n.glow-red-150 {\n  border: 2px solid #ffbead;\n  box-shadow: 0px 0px 10px 0px #ffd2c7;\n}\n.glow-red-200 {\n  border: 2px solid #ffaa94;\n  box-shadow: 0px 0px 10px 0px #ffbead;\n}\n.glow-red-250 {\n  border: 2px solid #ff967a;\n  box-shadow: 0px 0px 10px 0px #ffaa94;\n}\n.glow-red-300 {\n  border: 2px solid #ff8261;\n  box-shadow: 0px 0px 10px 0px #ff967a;\n}\n.glow-red-350 {\n  border: 2px solid #ff6d47;\n  box-shadow: 0px 0px 10px 0px #ff8261;\n}\n.glow-red-400 {\n  border: 2px solid #ff592e;\n  box-shadow: 0px 0px 10px 0px #ff6d47;\n}\n.glow-red-450 {\n  border: 2px solid #ff4514;\n  box-shadow: 0px 0px 10px 0px #ff592e;\n}\n.glow-red-500 {\n  border: 2px solid #fa3400;\n  box-shadow: 0px 0px 10px 0px #ff4514;\n}\n.glow-red-550 {\n  border: 2px solid #e02f00;\n  box-shadow: 0px 0px 10px 0px #fa3400;\n}\n.glow-red-600 {\n  border: 2px solid #c72900;\n  box-shadow: 0px 0px 10px 0px #e02f00;\n}\n.glow-red-650 {\n  border: 2px solid #ad2400;\n  box-shadow: 0px 0px 10px 0px #c72900;\n}\n.glow-red-700 {\n  border: 2px solid #941f00;\n  box-shadow: 0px 0px 10px 0px #ad2400;\n}\n.glow-red-725 {\n  border: 2px solid #871c00;\n  box-shadow: 0px 0px 10px 0px #a02100;\n}\n.glow-red-750 {\n  border: 2px solid #7a1900;\n  box-shadow: 0px 0px 10px 0px #941f00;\n}\n.glow-red-775 {\n  border: 2px solid #6d1700;\n  box-shadow: 0px 0px 10px 0px #871c00;\n}\n.glow-red-800 {\n  border: 2px solid #611400;\n  box-shadow: 0px 0px 10px 0px #7a1900;\n}\n.glow-red-825 {\n  border: 2px solid #541100;\n  box-shadow: 0px 0px 10px 0px #6d1700;\n}\n.glow-red-850 {\n  border: 2px solid #470f00;\n  box-shadow: 0px 0px 10px 0px #611400;\n}\n.glow-red-875 {\n  border: 2px solid #3a0c00;\n  box-shadow: 0px 0px 10px 0px #541100;\n}\n.glow-red-900 {\n  border: 2px solid #2e0900;\n  box-shadow: 0px 0px 10px 0px #470f00;\n}\n.glow-purple-050 {\n  border: 2px solid #eee9fc;\n  box-shadow: 0px 0px 10px 0px white;\n}\n.glow-purple-100 {\n  border: 2px solid #eee9fc;\n  box-shadow: 0px 0px 10px 0px white;\n}\n.glow-purple-150 {\n  border: 2px solid #eee9fc;\n  box-shadow: 0px 0px 10px 0px white;\n}\n.glow-purple-200 {\n  border: 2px solid #ded4f9;\n  box-shadow: 0px 0px 10px 0px #efeafc;\n}\n.glow-purple-250 {\n  border: 2px solid #cdbef5;\n  box-shadow: 0px 0px 10px 0px #ded4f9;\n}\n.glow-purple-300 {\n  border: 2px solid #bda8f2;\n  box-shadow: 0px 0px 10px 0px #cdbef5;\n}\n.glow-purple-350 {\n  border: 2px solid #ac91ef;\n  box-shadow: 0px 0px 10px 0px #bda8f2;\n}\n.glow-purple-400 {\n  border: 2px solid #9b7beb;\n  box-shadow: 0px 0px 10px 0px #ac91ef;\n}\n.glow-purple-450 {\n  border: 2px solid #8a65e8;\n  box-shadow: 0px 0px 10px 0px #9b7beb;\n}\n.glow-purple-500 {\n  border: 2px solid #794fe5;\n  box-shadow: 0px 0px 10px 0px #8a65e8;\n}\n.glow-purple-550 {\n  border: 2px solid #6839e1;\n  box-shadow: 0px 0px 10px 0px #794fe5;\n}\n.glow-purple-600 {\n  border: 2px solid #5722de;\n  box-shadow: 0px 0px 10px 0px #6839e1;\n}\n.glow-purple-650 {\n  border: 2px solid #4e1ec9;\n  box-shadow: 0px 0px 10px 0px #5722de;\n}\n.glow-purple-700 {\n  border: 2px solid #461bb3;\n  box-shadow: 0px 0px 10px 0px #4e1ec9;\n}\n.glow-purple-725 {\n  border: 2px solid #4119a8;\n  box-shadow: 0px 0px 10px 0px #4a1cbe;\n}\n.glow-purple-750 {\n  border: 2px solid #3d179d;\n  box-shadow: 0px 0px 10px 0px #461bb3;\n}\n.glow-purple-775 {\n  border: 2px solid #391692;\n  box-shadow: 0px 0px 10px 0px #4119a8;\n}\n.glow-purple-800 {\n  border: 2px solid #341486;\n  box-shadow: 0px 0px 10px 0px #3d179d;\n}\n.glow-purple-825 {\n  border: 2px solid #30127b;\n  box-shadow: 0px 0px 10px 0px #391692;\n}\n.glow-purple-850 {\n  border: 2px solid #2c1170;\n  box-shadow: 0px 0px 10px 0px #341486;\n}\n.glow-purple-875 {\n  border: 2px solid #270f65;\n  box-shadow: 0px 0px 10px 0px #30127b;\n}\n.glow-purple-900 {\n  border: 2px solid #230d5a;\n  box-shadow: 0px 0px 10px 0px #2c1170;\n}\n.glow-blue-grey-050 {\n  border: 2px solid #dce0e7;\n  box-shadow: 0px 0px 10px 0px #ebedf2;\n}\n.glow-blue-grey-100 {\n  border: 2px solid #bec5d3;\n  box-shadow: 0px 0px 10px 0px #cdd2dd;\n}\n.glow-blue-grey-150 {\n  border: 2px solid #afb7c8;\n  box-shadow: 0px 0px 10px 0px #bec5d3;\n}\n.glow-blue-grey-200 {\n  border: 2px solid #a0aabe;\n  box-shadow: 0px 0px 10px 0px #afb7c8;\n}\n.glow-blue-grey-250 {\n  border: 2px solid #909cb4;\n  box-shadow: 0px 0px 10px 0px #a0aabe;\n}\n.glow-blue-grey-300 {\n  border: 2px solid #818fa9;\n  box-shadow: 0px 0px 10px 0px #909cb4;\n}\n.glow-blue-grey-350 {\n  border: 2px solid #72819f;\n  box-shadow: 0px 0px 10px 0px #818fa9;\n}\n.glow-blue-grey-400 {\n  border: 2px solid #647493;\n  box-shadow: 0px 0px 10px 0px #72819f;\n}\n.glow-blue-grey-450 {\n  border: 2px solid #5a6884;\n  box-shadow: 0px 0px 10px 0px #647493;\n}\n.glow-blue-grey-500 {\n  border: 2px solid #505c75;\n  box-shadow: 0px 0px 10px 0px #5a6884;\n}\n.glow-blue-grey-550 {\n  border: 2px solid #455066;\n  box-shadow: 0px 0px 10px 0px #505c75;\n}\n.glow-blue-grey-600 {\n  border: 2px solid #3b4457;\n  box-shadow: 0px 0px 10px 0px #455066;\n}\n.glow-blue-grey-650 {\n  border: 2px solid #313847;\n  box-shadow: 0px 0px 10px 0px #3b4457;\n}\n.glow-blue-grey-700 {\n  border: 2px solid #262c38;\n  box-shadow: 0px 0px 10px 0px #313847;\n}\n.glow-blue-grey-725 {\n  border: 2px solid #212631;\n  box-shadow: 0px 0px 10px 0px #2b3240;\n}\n.glow-blue-grey-750 {\n  border: 2px solid #1c2029;\n  box-shadow: 0px 0px 10px 0px #262c38;\n}\n.glow-blue-grey-775 {\n  border: 2px solid #171a21;\n  box-shadow: 0px 0px 10px 0px #212631;\n}\n.glow-blue-grey-800 {\n  border: 2px solid #12141a;\n  box-shadow: 0px 0px 10px 0px #1c2029;\n}\n.glow-blue-grey-825 {\n  border: 2px solid #0c0e12;\n  box-shadow: 0px 0px 10px 0px #171a21;\n}\n.glow-blue-grey-850 {\n  border: 2px solid #07080b;\n  box-shadow: 0px 0px 10px 0px #12141a;\n}\n.glow-blue-grey-875 {\n  border: 2px solid #020203;\n  box-shadow: 0px 0px 10px 0px #0c0e12;\n}\n.glow-blue-grey-900 {\n  border: 2px solid black;\n  box-shadow: 0px 0px 10px 0px #07080b;\n}\n.glow-grey-050 {\n  border: 2px solid gainsboro;\n  box-shadow: 0px 0px 10px 0px #e9e9e9;\n}\n.glow-grey-100 {\n  border: 2px solid #c2c2c2;\n  box-shadow: 0px 0px 10px 0px #cfcfcf;\n}\n.glow-grey-150 {\n  border: 2px solid #b6b6b6;\n  box-shadow: 0px 0px 10px 0px #c2c2c2;\n}\n.glow-grey-200 {\n  border: 2px solid darkgray;\n  box-shadow: 0px 0px 10px 0px #b6b6b6;\n}\n.glow-grey-250 {\n  border: 2px solid #9c9c9c;\n  box-shadow: 0px 0px 10px 0px darkgray;\n}\n.glow-grey-300 {\n  border: 2px solid #8f8f8f;\n  box-shadow: 0px 0px 10px 0px #9c9c9c;\n}\n.glow-grey-350 {\n  border: 2px solid #838383;\n  box-shadow: 0px 0px 10px 0px #8f8f8f;\n}\n.glow-grey-400 {\n  border: 2px solid #767676;\n  box-shadow: 0px 0px 10px 0px #838383;\n}\n.glow-grey-450 {\n  border: 2px solid dimgray;\n  box-shadow: 0px 0px 10px 0px #767676;\n}\n.glow-grey-500 {\n  border: 2px solid #5c5c5c;\n  box-shadow: 0px 0px 10px 0px #696969;\n}\n.glow-grey-550 {\n  border: 2px solid #505050;\n  box-shadow: 0px 0px 10px 0px #5c5c5c;\n}\n.glow-grey-600 {\n  border: 2px solid #434343;\n  box-shadow: 0px 0px 10px 0px #505050;\n}\n.glow-grey-650 {\n  border: 2px solid #363636;\n  box-shadow: 0px 0px 10px 0px #434343;\n}\n.glow-grey-700 {\n  border: 2px solid #292929;\n  box-shadow: 0px 0px 10px 0px #363636;\n}\n.glow-grey-725 {\n  border: 2px solid #232323;\n  box-shadow: 0px 0px 10px 0px #303030;\n}\n.glow-grey-750 {\n  border: 2px solid #1d1d1d;\n  box-shadow: 0px 0px 10px 0px #292929;\n}\n.glow-grey-775 {\n  border: 2px solid #161616;\n  box-shadow: 0px 0px 10px 0px #232323;\n}\n.glow-grey-800 {\n  border: 2px solid #101010;\n  box-shadow: 0px 0px 10px 0px #1d1d1d;\n}\n.glow-grey-825 {\n  border: 2px solid #090909;\n  box-shadow: 0px 0px 10px 0px #161616;\n}\n.glow-grey-850 {\n  border: 2px solid #030303;\n  box-shadow: 0px 0px 10px 0px #101010;\n}\n.glow-grey-875 {\n  border: 2px solid black;\n  box-shadow: 0px 0px 10px 0px #090909;\n}\n.glow-grey-900 {\n  border: 2px solid black;\n  box-shadow: 0px 0px 10px 0px #030303;\n}\n.ngx-stepper {\n  display: flex;\n  position: relative;\n  flex-direction: column;\n  overflow: hidden;\n  padding: 0.635rem;\n}\n.ngx-stepper.ngx-stepper--top .ngx-stepper--steps, .ngx-stepper.ngx-stepper--bottom .ngx-stepper--steps {\n  margin-left: 0.35rem;\n  margin-right: 0.35rem;\n}\n.ngx-stepper.ngx-stepper--top .ngx-step--title, .ngx-stepper.ngx-stepper--bottom .ngx-step--title {\n  position: absolute;\n  display: inline-block;\n  transform: translateX(calc(-50% + 1.75rem / 2));\n  text-align: center;\n  font-size: 12px;\n}\n.ngx-stepper.ngx-stepper--top .ngx-stepper--bar {\n  bottom: 0;\n  margin-top: 0.635rem;\n}\n.ngx-stepper.ngx-stepper--top .ngx-step--title {\n  top: 100%;\n}\n.ngx-stepper.ngx-stepper--bottom {\n  flex-direction: column-reverse;\n}\n.ngx-stepper.ngx-stepper--bottom .ngx-stepper--bar {\n  top: 0;\n  margin-bottom: 0.635rem;\n}\n.ngx-stepper.ngx-stepper--bottom .ngx-step--title {\n  top: calc(-100% + 5px);\n}\n.ngx-stepper.ngx-stepper--left {\n  flex-direction: row;\n}\n.ngx-stepper.ngx-stepper--left .ngx-step {\n  flex-direction: row;\n}\n.ngx-stepper.ngx-stepper--left .ngx-step .ngx-step--title {\n  margin-right: 0.635rem;\n}\n.ngx-stepper.ngx-stepper--left .ngx-stepper--bar-track {\n  width: 20px;\n}\n.ngx-stepper.ngx-stepper--left .ngx-stepper--bar-track .ngx-stepper--bar {\n  right: 0;\n  margin-left: 0.635rem;\n}\n.ngx-stepper.ngx-stepper--right {\n  flex-direction: row-reverse;\n}\n.ngx-stepper.ngx-stepper--right .ngx-step {\n  flex-direction: row-reverse;\n}\n.ngx-stepper.ngx-stepper--right .ngx-step .ngx-step--title {\n  margin-left: 0.635rem;\n}\n.ngx-stepper.ngx-stepper--right .ngx-stepper--bar-track {\n  width: 20px;\n}\n.ngx-stepper.ngx-stepper--right .ngx-stepper--bar-track .ngx-stepper--bar {\n  left: 0;\n  margin-right: 0.635rem;\n}\n.ngx-stepper.ngx-stepper--left .ngx-stepper--steps, .ngx-stepper.ngx-stepper--right .ngx-stepper--steps {\n  margin-top: 0.35rem;\n  margin-bottom: 0.35rem;\n  flex-direction: column;\n}\n.ngx-stepper.ngx-stepper--left .ngx-stepper--steps .ngx-step, .ngx-stepper.ngx-stepper--right .ngx-stepper--steps .ngx-step {\n  display: flex;\n}\n.ngx-stepper.ngx-stepper--left .ngx-stepper--steps .ngx-step.ngx-step--complete-last .ngx-step--step:after, .ngx-stepper.ngx-stepper--right .ngx-stepper--steps .ngx-step.ngx-step--complete-last .ngx-step--step:after {\n  background-image: linear-gradient(to bottom, #1edeb6 0%, #1483ff 75%) !important;\n}\n.ngx-stepper.ngx-stepper--left .ngx-stepper--steps .ngx-step.ngx-step--active .ngx-step--step:after, .ngx-stepper.ngx-stepper--right .ngx-stepper--steps .ngx-step.ngx-step--active .ngx-step--step:after {\n  background-image: linear-gradient(to bottom, #1483ff 0%, #455066 75%) !important;\n}\n.ngx-stepper.ngx-stepper--left .ngx-stepper--steps .ngx-step .ngx-step--title, .ngx-stepper.ngx-stepper--right .ngx-stepper--steps .ngx-step .ngx-step--title {\n  position: unset;\n  display: block;\n  transform: unset;\n  margin-bottom: 0;\n  max-width: 100px;\n  width: 100px;\n  text-align: unset;\n}\n.ngx-stepper.ngx-stepper--left .ngx-stepper--steps .ngx-step .ngx-step--step, .ngx-stepper.ngx-stepper--right .ngx-stepper--steps .ngx-step .ngx-step--step {\n  flex-direction: column;\n}\n.ngx-stepper.ngx-stepper--left .ngx-stepper--steps .ngx-step .ngx-step--step:after, .ngx-stepper.ngx-stepper--right .ngx-stepper--steps .ngx-step .ngx-step--step:after {\n  min-width: 1.4px;\n  height: initial;\n  min-height: 1.75rem;\n  width: 1.4px;\n}\n.ngx-stepper.ngx-stepper--readonly .ngx-step.ngx-step--complete .ngx-step--circle:hover {\n  border: initial;\n  color: initial;\n  box-shadow: initial;\n}\n.ngx-stepper.ngx-stepper--readonly .ngx-step.ngx-step--complete .ngx-step--circle:hover .ngx-step--indicator {\n  opacity: initial;\n}\n.ngx-stepper.ngx-stepper--readonly .ngx-step.ngx-step--complete .ngx-step--circle:hover i.ngx-step--complete-icon {\n  opacity: initial;\n}\n.ngx-stepper.ngx-stepper--readonly .ngx-step.ngx-step--complete .ngx-step--circle:hover .marker-path {\n  fill: initial;\n}\n.ngx-stepper.ngx-stepper--readonly .ngx-step .ngx-step--circle {\n  cursor: default;\n  pointer-events: none !important;\n}\n.ngx-stepper.ngx-stepper--with-progress .ngx-step.ngx-step--active .ngx-step--step .ngx-step--circle {\n  border: none !important;\n  box-shadow: none;\n}\n@-webkit-keyframes spinner {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n@keyframes spinner {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n.ngx-stepper.ngx-stepper--with-progress .ngx-step.ngx-step--active .ngx-step--step .ngx-step--circle::before {\n  -webkit-animation: 1.5s linear infinite spinner;\n          animation: 1.5s linear infinite spinner;\n  -webkit-animation-play-state: inherit;\n          animation-play-state: inherit;\n  border: solid 1px transparent;\n  border-bottom-color: #1483ff;\n  border-right-color: #1483ff;\n  border-radius: 50%;\n  content: "";\n  height: 100%;\n  width: 100%;\n  will-change: transform;\n}\n.ngx-stepper .ngx-stepper--steps {\n  display: flex;\n  position: relative;\n  justify-content: space-between;\n  min-width: 1.75rem;\n}\n.ngx-stepper .ngx-stepper--bar-track {\n  min-height: 25px;\n  position: relative;\n}\n.ngx-stepper .ngx-stepper--bar-track .ngx-stepper--bar {\n  position: absolute;\n  background-color: #1483ff;\n}\n.ngx-stepper .ngx-stepper--content {\n  flex: 1;\n  display: none;\n}\n.ngx-stepper .ngx-stepper--content.active {\n  display: initial;\n}\n.ngx-stepper.ngx-stepper--lg .ngx-stepper--steps {\n  min-width: 5.5rem;\n}\n.ngx-stepper.ngx-stepper--lg .ngx-stepper--steps .ngx-step .ngx-step--step .ngx-step--circle {\n  width: 5.5rem;\n  height: 5.5rem;\n  font-size: 2.75rem;\n}\n.ngx-stepper.ngx-stepper--lg.ngx-stepper--top .ngx-stepper--steps, .ngx-stepper.ngx-stepper--lg.ngx-stepper--bottom .ngx-stepper--steps {\n  margin-left: 1.1rem;\n  margin-right: 1.1rem;\n}\n.ngx-stepper.ngx-stepper--lg.ngx-stepper--top .ngx-step--title, .ngx-stepper.ngx-stepper--lg.ngx-stepper--bottom .ngx-step--title {\n  transform: translateX(calc(-50% + 5.5rem / 2));\n}\n.ngx-stepper.ngx-stepper--lg.ngx-stepper--left .ngx-stepper--steps, .ngx-stepper.ngx-stepper--lg.ngx-stepper--right .ngx-stepper--steps {\n  margin-top: 1.1rem;\n  margin-bottom: 1.1rem;\n}\n.ngx-stepper.ngx-stepper--lg.ngx-stepper--left .ngx-stepper--steps .ngx-step .ngx-step--step:after, .ngx-stepper.ngx-stepper--lg.ngx-stepper--right .ngx-stepper--steps .ngx-step .ngx-step--step:after {\n  min-height: 5.5rem;\n}\n.ngx-stepper.ngx-stepper--no-highlight .ngx-stepper--steps .ngx-step.ngx-step--complete:not(.ngx-step--complete-last) .ngx-step--title {\n  color: #1483ff;\n}\n.ngx-stepper.ngx-stepper--no-highlight .ngx-stepper--steps .ngx-step.ngx-step--complete:not(.ngx-step--complete-last) .ngx-step--step:after {\n  background-color: #1483ff !important;\n}\n.ngx-stepper.ngx-stepper--no-highlight .ngx-stepper--steps .ngx-step.ngx-step--complete:not(.ngx-step--complete-last) .ngx-step--step .ngx-step--circle {\n  border-color: #1483ff;\n  color: #1483ff;\n}\n.ngx-stepper.ngx-stepper--no-highlight .ngx-stepper--steps .ngx-step.ngx-step--complete:not(.ngx-step--complete-last) .ngx-step--step .ngx-step--circle .marker-path {\n  fill: #1483ff;\n}\n.ngx-stepper.ngx-stepper--no-highlight .ngx-stepper--steps .ngx-step.ngx-step--complete.ngx-step--complete-last .ngx-step--title {\n  color: #1483ff;\n}\n.ngx-stepper.ngx-stepper--no-highlight .ngx-stepper--steps .ngx-step.ngx-step--complete.ngx-step--complete-last .ngx-step--step:after {\n  background-image: linear-gradient(to right, #1483ff 0%, #1483ff 75%) !important;\n}\n.ngx-stepper.ngx-stepper--no-highlight .ngx-stepper--steps .ngx-step.ngx-step--complete.ngx-step--complete-last .ngx-step--step .ngx-step--circle {\n  border-color: #1483ff;\n  color: #1483ff;\n}\n.ngx-stepper.ngx-stepper--no-highlight .ngx-stepper--steps .ngx-step.ngx-step--complete.ngx-step--complete-last .ngx-step--step .ngx-step--circle .marker-path {\n  fill: #1483ff;\n}']})],ue);let me=class{};me=Object(o.a)([Object(s.N)({imports:[i.c],declarations:[ue,pe,ce],exports:[ue,pe,ce]})],me);let we=class{constructor(e,n,t){this.stateSyncService=e,this.router=n,this.route=t,this.SelectedJob=this.stateSyncService.SelectedJob.pipe(O)}ngOnInit(){}openToToolsSelection(e){let n={};n=null==e?{outlets:{tool_list:["tools"]}}:{outlets:{tool_list:["tool",e]}},this.router.navigate([n],{relativeTo:this.route.parent}),this.stateSyncService.toggle()}};we.ctorParameters=()=>[{type:B},{type:r.f},{type:r.a}],we=Object(o.a)([Object(s.n)({selector:"app-selected-job",template:'<div fxLayout="row" fxLayoutAlign="start center">\n\n  <button shape="round" (click)="openToToolsSelection(  )" ghost status="basic" class="action" size="large" nbButton>\n    <nb-icon icon="menu-outline">\n\n    </nb-icon>\n  </button>\n\n  <div (click)="openToToolsSelection( SelectedJob?.tool?._id )" fxLayout="column"\n    *ngIf="SelectedJob | async as SelectedJob" class="container">\n\n    <div fxLayoutAlign="start center " fxLayout="row" id="primeContainer">\n\n      <div id="tool_name" class="caption-2">\n        {{SelectedJob?.tool?.alias }}\n      </div>\n\n      <div id="slash">\n        /\n      </div>\n      <div id="job_name" class="caption">\n        {{SelectedJob?._id}}\n      </div>\n\n    </div>\n\n    <div fxLayoutAlign="start start " fxLayout="row" id="secContainer">\n\n      <div id="date" class="caption">\n        <nb-tag id="status" size="tiny" appearance="filled" status="primary" [text]="SelectedJob?.doc | date">\n          \x3c!-- {{SelectedJob?.exec_status | titlecase}} --\x3e\n        </nb-tag>\n        \x3c!-- {{SelectedJob?.doc | date}} --\x3e\n      </div>\n\n      <div id="slash">\n\n      </div>\n\n\n      <div class="caption-2">\n        <nb-tag id="status" size="tiny" appearance="outline" \n        [status]="SelectedJob?._status"\n        \n        [text]="SelectedJob?.exec_status">\n          \x3c!-- {{SelectedJob?.exec_status | titlecase}} --\x3e\n        </nb-tag>\n      </div>\n\n    </div>\n\n\n  </div>\n</div>\n',styles:["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/*\n  Declare variables before making them global.\n  dart-sass doesn't allow to declare variable with !global.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n/**\n * This mixin generates keyfames.\n * Because of all keyframes can't be scoped,\n * we need to puts unique name in each btn-pulse call.\n */\n/*\n\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\n:host and :host-context are pseudo-classes. So we assume they could be combined,\nlike other pseudo-classes, even same ones.\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\n\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\nso direction could be overridden on any component level.\n\nImplementation code:\n\n@mixin nb-rtl() {\n  // add # to scss interpolation statement.\n  // it works in comments and we can't use it here\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\n    @content;\n  }\n}\n\nAnd when we call it somewhere:\n\n:host {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n:host-context(...) {\n  .some-class {\n    @include nb-rtl() {\n      ...\n    }\n  }\n}\n\nResult will look like:\n\n:host-context([dir=rtl]):host .some-class {\n  ...\n}\n:host-context([dir=rtl]):host-context(...) .some-class {\n  ...\n}\n\n*\n  Side note:\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\n\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\n  so order is not important.\n*\n\n\nCurrently, there're two problems with this approach:\n\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\nFor the moment of writing, the only possible way is:\n:host {\n  :host-context(...) {\n    ...\n  }\n}\nIt doesn't work for us because mixin could be called somewhere deeper, like:\n:host {\n  p {\n    @include nb-rtl() { ... }\n  }\n}\nWe are not able to go up to :host level to place content passed to mixin.\n\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\n  *\n    Side note:\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\n    :host-context($theme) once we will be able to use multiple shadow selectors.\n  *\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\n  ***\n    Possible solution\n    check if we in theme by some theme variables and if so append, otherwise nest like\n    @at-root :host-context([dir=rtl]) {\n      // add # to scss interpolation statement.\n      // it works in comments and we can't use it here\n      {&} {\n        @content;\n      }\n    }\n    What if :host specified? Can we add space in :host-context(...) :host?\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\n  ***\n\n\nProblems with the current approach.\n\n1. Direction can be applied only on document level, because mixin prepends theme class,\nwhich placed on the body.\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\nattribute to [dir=rtl] attribute as well.\n\n\nGeneral problems.\n\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\n*/\n:root {\n  --small-checkbox: 16px ;\n}\n:host {\n  margin-left: 0.5rem;\n}\n:host nb-tag {\n  font-size: 0.6rem !important;\n  line-height: 1.2rem;\n  padding-top: 0.1rem !important;\n  padding-bottom: 0.1rem !important;\n  padding-left: 0.8rem !important;\n  padding-right: 0.8rem !important;\n  height: 1.2rem;\n  text-transform: capitalize !important;\n}\n:host #date {\n  font-size: 0.7rem;\n}\n:host #job_name {\n  font-size: 1rem;\n  border-radius: 1rem;\n}\n:host #job_name:hover {\n  color: var(--color-basic-650);\n}\n:host #slash {\n  color: var(--text-hint-color);\n  padding: 0.2rem;\n  font-size: 1.4rem;\n}\n:host #tool_name {\n  border-radius: 1rem;\n  font-size: 1rem;\n}\n:host #tool_name:hover {\n  color: var(--color-basic-650);\n}\n:host #primeContainer {\n  height: 2.5rem;\n}\n:host #secContainer {\n  height: 1.5rem;\n}\n.container {\n  height: 4rem;\n  margin-left: 5px;\n}"]})],we);let ge=class{};ge=Object(o.a)([Object(s.N)({declarations:[W,te,J,V,l,H,re,X,Y,U,G,we],imports:[i.c,Q,Z.p,Z.E.forRoot({name:"default"}),ee.a,Z.n,g.c,ne.a,Z.a,Z.q,Z.f,Z.e,Z.D,Z.A,Z.z.forRoot(),Z.d,oe.a,se.b,ie.a,Z.y,Z.C,Z.w,N.m,me,Z.r,Z.b,Z.h],providers:[F,B]})],ge)}}]);